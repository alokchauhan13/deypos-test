<?xml version="1.0"?>
<doc>
    <assembly>
        "SEALNET"
    </assembly>
    <members>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.GetPolyCRTBuilder">
            <summary>Returns a reference to the underlying C++ PolyCRTBuilder.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.PolyCRTBuilder.SlotCount">
            <summary>Returns the number of slots.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.Compose(System.Collections.Generic.List`1{System.UInt64})">
            <summary>Writes a given list of unsigned integers (represented by System::UInt64) modulo the 
                plaintext modulus into the slots of a plaintext polynomial, and returns it.</summary>
            <remarks>
                <para>
                Writes a given list of unsigned integers modulo the plaintext modulus into the slots of
                a plaintext polynomial, and returns it.
                </para>
                <para>
                The number of elements in the vector of inputs must be equal to the number of slots, which is
                equal to the degree of the polynomial modulus. Each entry in the vector of inputs must have value
                less than the plaintext modulus. The returned polynomial will automatically be resized to have correct
                size, i.e. the same number of coefficients as the polynomial modulus, and each coefficient of the
                same bit count as the plaintext modulus.
                </para>
            </remarks>
            <param name="values">The list of values to write into the slots</param>
            <exception cref="T:System.ArgumentNullException">if values is null</exception>
            <exception cref="T:System.InvalidOperationException">if the plaintext modulus is bigger than 64 bits</exception>
            <exception cref="T:System.ArgumentException">if the values list has incorrect size</exception>
            <exception cref="T:System.ArgumentException">if the entries in the values list have incorrect size</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.Compose(System.Collections.Generic.List`1{Microsoft.Research.SEAL.BigUInt})">
            <summary>Writes a given list of unsigned integers modulo the plaintext modulus into the slots of 
                a plaintext polynomial, and returns it.</summary>
            <remarks>
                <para>
                Writes a given list of unsigned integers modulo the plaintext modulus into the slots of
                a plaintext polynomial, and returns it.
                </para>
                <para>
                The number of elements in the list of inputs must be equal to the number of slots, which is
                equal to the degree of the polynomial modulus. Each entry in the list of inputs must have
                bit count equal to that of the plaintext modulus and is expected to be already reduced modulo
                the plaintext modulus. The returned polynomial will automatically be resized to have correct
                size, i.e. the same number of coefficients as the polynomial modulus, and each coefficient of the
                same bit count as the plaintext modulus.
                </para>
            </remarks>
            <param name="values">The list of values to write into the slots</param>
            <exception cref="T:System.ArgumentNullException">if values is null</exception>
            <exception cref="T:System.ArgumentException">if the values list has incorrect size</exception>
            <exception cref="T:System.ArgumentException">if the entries in the values list have incorrect size</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.Compose(System.Collections.Generic.List`1{System.UInt64},Microsoft.Research.SEAL.BigPoly)">
            <summary>Writes a given list of unsigned integers (represented by System::UInt64) modulo the 
                plaintext modulus into the slots of a given plaintext polynomial.</summary>
            <remarks>
                <para>
                Writes a given list of unsigned integers (represented by System::UInt64) modulo the plaintext 
                modulus into the slots of a given plaintext polynomial.
                </para>
                <para>
                The number of elements in the list of inputs must be equal to the number of slots, which is
                equal to the degree of the polynomial modulus. Each entry in the vector of inputs must have value
                less than the plaintext modulus. The destination polynomial will automatically be resized to have 
                correct size, i.e. the same number of coefficients as the polynomial modulus, and each coefficient 
                of the same bit count as the plaintext modulus.
                </para>
            </remarks>
            <param name="values">The list of values to write into the slots</param>
            <param name="destination">The plaintext polynomial to overwrite with the result</param>
            <exception cref="T:System.ArgumentNullException">if values or destination is null</exception>
            <exception cref="T:System.InvalidOperationException">if the plaintext modulus is bigger than 64 bits</exception>
            <exception cref="T:System.ArgumentException">if the values list has incorrect size</exception>
            <exception cref="T:System.ArgumentException">if the entries in the values list have incorrect size</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.Compose(System.Collections.Generic.List`1{Microsoft.Research.SEAL.BigUInt},Microsoft.Research.SEAL.BigPoly)">
            <summary>Writes a given list of unsigned integers modulo the plaintext modulus into the slots of 
                a given plaintext polynomial.</summary>
            <remarks>
                <para>
                Writes a given list of unsigned integers modulo the plaintext modulus into the slots of a given 
                plaintext polynomial.
                </para>
                <para>
                The number of elements in the list of inputs must be equal to the number of slots, which is
                equal to the degree of the polynomial modulus. Each entry in the list of inputs must have
                bit count equal to that of the plaintext modulus and is expected to be already reduced modulo
                the plaintext modulus. The destination polynomial will automatically be resized to have correct
                size, i.e. the same number of coefficients as the polynomial modulus, and each coefficient of the
                same bit count as the plaintext modulus.
                </para>
            </remarks>
            <param name="values">The list of values to write into the slots</param>
            <param name="destination">The plaintext polynomial to overwrite with the result</param>
            <exception cref="T:System.ArgumentNullException">if values or destination is null</exception>
            <exception cref="T:System.ArgumentException">if the values list has incorrect size</exception>
            <exception cref="T:System.ArgumentException">if the entries in the values list have incorrect size</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.Finalize">
            <summary>Destroys the PolyCRTBuilder</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.Dispose">
            <summary>Destroys the PolyCRTBuilder</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.#ctor(Microsoft.Research.SEAL.PolyCRTBuilder)">
            <summary>Creates a copy of a PolyCRTBuilder.</summary>
            <param name="copy">The PolyCRTBuilder to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a PolyCRTBuilder instance given a set of encryption parameters.</summary>
            <remarks>
                Creates a PolyCRTBuilder instance given a set of encryption parameters. It is necessary that the given set of
                encryption parameters supports batching. The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use 
                a custom memory pool instead of the global memory pool (default).
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if parms or pool is null</exception>
            <exception cref="T:System.ArgumentException">if parms are not valid or do not support batching</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more information about encryption
                parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameterQualifiers">See EncryptionParameterQualifiers for more information about encryption
                parameters that support batching.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.PolyCRTBuilder.#ctor(Microsoft.Research.SEAL.EncryptionParameters)">
            <summary>Creates a PolyCRTBuilder instance given a set of encryption parameters.</summary>
            <remarks>
                Creates a PolyCRTBuilder instance given a set of encryption parameters. It is necessary that the given set of
                encryption parameters supports batching.
                </remarks>
            <param name="parms">The encryption parameters</param>
            <exception cref="T:System.ArgumentNullException">if parms is null</exception>
            <exception cref="T:System.ArgumentException">if parms are not valid or do not support batching</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more information about encryption
                parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameterQualifiers">See EncryptionParameterQualifiers for more information about encryption
                parameters that support batching.</seealso>
        </member>
        <member name="M:seal.PolyCRTBuilder.get_slot_count">
Returns the number of slots.

</member>
        <member name="M:seal.PolyCRTBuilder.decompose(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Reads the values in the slots of a given plaintext polynomial and writes them as the entries of
        a vector, which is then returned. This is the inverse of what compose() does.

        @par Format of Parameters
        The plaintext polynomial poly must have the same number of coefficients as the polynomial modulus,
        and its coefficients must have bit count equal to that of the plaintext modulus. Moreover, poly is
        expected to be already reduced modulo polynomial modulus, and its coefficients are expected
        to be already reduced modulo the plaintext modulus. The number of elements in the returned vector
        will be equal the number of slots, the elements themselves will have bit count equal to that
        of the plaintext modulus, and their values will be reduced modulo the plaintext modulus.

        @param[in] poly The plaintext polynomial from which the slots will be read
        @throws std::invalid_argument if poly has incorrect size

</member>
        <member name="M:seal.PolyCRTBuilder.decompose(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,std.vector&lt;seal.BigUInt,std.allocator&lt;seal.BigUInt&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Reads the values in the slots of a given plaintext polynomial and writes them as the entries of 
        a given vector. This is the inverse of what compose() does.

        @par Format of Parameters
        The plaintext polynomial poly must have the same number of coefficients as the polynomial modulus,
        and its coefficients must have bit count equal to that of the plaintext modulus. Moreover, poly is
        expected to be already reduced modulo polynomial modulus, and its coefficients are expected
        to be already reduced modulo the plaintext modulus. The number of elements in the destination
        vector will be set to equal the number of slots, the elements themselves will be set to have
        bit count equal to that of the plaintext modulus, and their values will be reduced modulo the 
        plaintext modulus.

        @param[in] poly The plaintext polynomial from which the slots will be read
        @param[out] destination The vector to be overwritten with the values of the slots
        @throws std::invalid_argument if poly has incorrect size

</member>
        <member name="M:seal.PolyCRTBuilder.compose(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Writes a given vector of unsigned integers (represented by std::uint64_t) modulo the
        plaintext modulus into the slots of a plaintext polynomial, and returns it.

        @par Format of Parameters
        The number of elements in the vector of inputs must be equal to the number of slots, which is
        equal to the degree of the polynomial modulus. Each entry in the vector of inputs must have value
        less than the plaintext modulus. The returned polynomial will automatically be resized to have correct
        size, i.e. the same number of coefficients as the polynomial modulus, and each coefficient of the
        same bit count as the plaintext modulus.

        @param[in] values The vector of values to write into the slots
        @throws std::logic_error if the plaintext modulus is bigger than 64 bits
        @throws std::invalid_argument if the values vector has incorrect size
        @throws std::invalid_argument if the entries in the values vector have incorrect size

</member>
        <member name="M:seal.PolyCRTBuilder.compose(std.vector&lt;seal.BigUInt,std.allocator&lt;seal.BigUInt&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Writes a given vector of unsigned integers modulo the plaintext modulus into the slots of
        a plaintext polynomial, and returns it.

        @par Format of Parameters
        The number of elements in the vector of inputs must be equal to the number of slots, which is
        equal to the degree of the polynomial modulus. Each entry in the vector of inputs must have
        bit count equal to that of the plaintext modulus and is expected to be already reduced modulo
        the plaintext modulus. The returned polynomial will automatically be resized to have correct
        size, i.e. the same number of coefficients as the polynomial modulus, and each coefficient of the
        same bit count as the plaintext modulus.

        @param[in] values The vector of values to write into the slots
        @throws std::invalid_argument if the values vector has incorrect size
        @throws std::invalid_argument if the entries in the values vector have incorrect size

</member>
        <member name="M:seal.PolyCRTBuilder.compose(std.vector&lt;System.UInt64,std.allocator&lt;System.UInt64&gt;&gt;,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Writes a given vector of unsigned integers (represented by std::uint64_t) modulo the 
        plaintext modulus into the slots of a given plaintext polynomial.

        @par Format of Parameters
        The number of elements in the vector of inputs must be equal to the number of slots, which is
        equal to the degree of the polynomial modulus. Each entry in the vector of inputs must have value
        less than the plaintext modulus. The destination polynomial will automatically be resized to have 
        correct size, i.e. the same number of coefficients as the polynomial modulus, and each coefficient 
        of the same bit count as the plaintext modulus.

        @param[in] values The vector of values to write into the slots
        @param[out] destination The plaintext polynomial to overwrite with the result
        @throws std::logic_error if the plaintext modulus is bigger than 64 bits
        @throws std::invalid_argument if the values vector has incorrect size
        @throws std::invalid_argument if the entries in the values vector have incorrect size

</member>
        <member name="M:seal.PolyCRTBuilder.compose(std.vector&lt;seal.BigUInt,std.allocator&lt;seal.BigUInt&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new PolyCRTBuilder by moving an old one.

        @param[in] source The PolyCRTBuilder to move from

        Writes a given vector of unsigned integers modulo the plaintext modulus into the slots of a given 
        plaintext polynomial. 

        @par Format of Parameters
        The number of elements in the vector of inputs must be equal to the number of slots, which is
        equal to the degree of the polynomial modulus. Each entry in the vector of inputs must have
        bit count equal to that of the plaintext modulus and is expected to be already reduced modulo 
        the plaintext modulus. The destination polynomial will automatically be resized to have correct 
        size, i.e. the same number of coefficients as the polynomial modulus, and each coefficient of the 
        same bit count as the plaintext modulus.

        @param[in] values The vector of values to write into the slots
        @param[out] destination The plaintext polynomial to overwrite with the result
        @throws std::invalid_argument if the values vector has incorrect size
        @throws std::invalid_argument if the entries in the values vector have incorrect size

</member>
        <member name="M:seal.PolyCRTBuilder.#ctor(seal.PolyCRTBuilder!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a copy of a PolyCRTBuilder.

        @param[in] copy The PolyCRTBuilder to copy from

</member>
        <member name="M:seal.PolyCRTBuilder.#ctor(seal.EncryptionParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a PolyCRTBuilder instance given a set of encryption parameters. It is necessary that the 
        given set of encryption parameters supports batching. Optionally, the user can give a reference 
        to a MemoryPoolHandle object to use a custom memory pool instead of the global memory pool (default).

        @param[in] parms The encryption parameters
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if parms are not valid or do not support batching
        @see EncryptionParameters for more information about encryption parameters.
        @see EncryptionParameterQualifiers for more information about encryption parameters that support batching.
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.PolyCRTBuilder">
    Provides functionality for encrypting several plaintext numbers into one ciphertext
    for improved memory efficiency and efficient vector operations (SIMD). Multiplying and 
    adding such ciphertexts together performs the respective operation on each of the slots 
    independently and simultaneously. This functionality is often called "batching" in
    homomorphic encryption literature.

    @par Mathematical Background
    Mathematically speaking, if poly_modulus is X^N+1, N is a power of two, and plain_modulus 
    is a prime number t such that 2N divides t-1, then integers modulo t contain a primitive 
    2N-th root of unity and the polynomial X^N+1 splits into n distinct linear factors as 
    X^N+1 = (X-a_1)*...*(X-a_N) mod t, where the constants a_1, ..., a_n are all the distinct 
    primitive 2N-th roots of unity in integers modulo t. The Chinese Remainder Theorem (CRT) 
    states that the plaintext space Z_t[X]/(X^N+1) in this case is isomorphic (as an algebra) 
    to the N-fold direct product of fields Z_t. The isomorphism is easy to compute explicitly 
    in both directions, which is what an instance of this class can be used for.

    @par Valid Parameters
    Whether batching can be used depends strongly on the encryption parameters. Thus, to
    construct a PolyCRTBuilder the user must provide an instance of EncryptionParameters
    such that the EncryptionParameterQualifiers object returned by the function 
    EncryptionParameters::GetQualifiers() has the flags parameters_set and enable_batching
    set to true.

    @see EncryptionParameters for more information about encryption parameters.
    @see EncryptionParameterQualifiers for more information about encryption parameters that support batching.

</member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.GetDecryptor">
            <summary>Returns a reference to the underlying C++ Decryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.Finalize">
            <summary>Destroys the Decryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.Dispose">
            <summary>Destroys the Decryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.InherentNoise(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigUInt)">
            <summary>Computes the inherent noise in a ciphertext.</summary>
            <remarks>
                Computes the inherent noise in a ciphertext. The result is written in a BigUInt given as a parameter. The user can
                easily compare this with the maximum possible value returned by the function EncryptionParameters::inherentNoiseMax().
                It is often easier to analyze the size of the inherent noise by using the functions <see cref="M:Microsoft.Research.SEAL.Decryptor.InherentNoiseBits(Microsoft.Research.SEAL.BigPolyArray)" /> 
                and EncryptionParameters::InherentNoiseMax(). Instead of this function, consider using 
                <see cref="M:Microsoft.Research.SEAL.Decryptor.InvariantNoiseBudget(Microsoft.Research.SEAL.BigPolyArray)" />, which has several subtle advantages.
                </remarks>
            <param name="encrypted">The ciphertext</param>
            <param name="destination">The BigUInt to overwrite with the inherent noise</param>
            <exception cref="T:System.ArgumentNullException">if encrypted or destination is null</exception>
            <exception cref="T:System.ArgumentException">if encrypted is not a valid ciphertext for the encryption
                parameters</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Decryptor.InherentNoiseBits(Microsoft.Research.SEAL.BigPolyArray)">See InherentNoiseBits for returning the significant bit count of the 
                inherent noise instead.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.InherentNoiseBits(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Computes and returns the number of bits of inherent noise in a ciphertext.</summary>
            <remarks>
                Computes and returns the number of bits of inherent noise in a ciphertext. The user can easily compare this 
                with the maximum possible value returned by the function EncryptionParameters::InherentNoiseBitsMax(). 
                Instead of this function, consider using <see cref="M:Microsoft.Research.SEAL.Decryptor.InvariantNoiseBudget(Microsoft.Research.SEAL.BigPolyArray)" />, which has several subtle 
                advantages.
                </remarks>
            <param name="encrypted">The ciphertext</param>
            <exception cref="T:System.ArgumentNullException">if encrypted is null</exception>
            <exception cref="T:System.ArgumentException">if encrypted is not a valid ciphertext for the encryption
                parameters</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Decryptor.InherentNoise(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigUInt)">See InherentNoise for computing the exact size of inherent noise.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.InvariantNoiseBudget(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Computes the invariant noise budget (in bits) of a ciphertext.</summary>
            <remarks>
                <para>
Computes the invariant noise budget (in bits) of a ciphertext. The invariant noise budget measures 
the amount of room there is for the noise to grow while ensuring correct decryptions.
</para>
                <para>
The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
correctly.
</para>
            </remarks>
            <param name="encrypted">The ciphertext</param>
            <exception cref="T:System.ArgumentNullException">if encrypted is null</exception>
            <exception cref="T:System.ArgumentException">if encrypted is not a valid ciphertext for the encryption
parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.Decrypt(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Decrypts an BigPolyArray and returns the result.</summary>
            <param name="encrypted">The ciphertext to decrypt</param>
            <exception cref="T:System.ArgumentNullException">if encrypted is null</exception>
            <exception cref="T:System.ArgumentException">if the ciphertext is not a valid ciphertext for the
encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.Decrypt(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">
            <summary>Decrypts an BigPolyArray and stores the result in the destination parameter.</summary>
            <remarks>
                Decrypts an BigPolyArray and stores the result in the destination parameter.
                </remarks>
            <param name="encrypted">The ciphertext to decrypt</param>
            <param name="destination">The plaintext to overwrite with the decrypted ciphertext</param>
            <exception cref="T:System.ArgumentNullException">if encrypted or destination is null</exception>
            <exception cref="T:System.ArgumentException">if the ciphertext is not a valid ciphertext for the
                encryption parameters</exception>
            <exception cref="T:System.InvalidOperationException">If destination is an alias but needs to be resized</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.Decryptor.SecretKey">
            <summary>Returns the secret key used by the Decryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.#ctor(Microsoft.Research.SEAL.Decryptor)">
            <summary>Creates a copy of a Decryptor.</summary>
            <param name="copy">The Decryptor to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a Decryptor instance initialized with the specified encryption parameters and secret key.</summary>
            <remarks>
                Creates a Decryptor instance initialized with the specified encryption parameters and secret key.
                The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool instead 
                of the global memory pool (default).
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="secretKey">The secret key</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if parms, secretKey, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters or secret key are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Decryptor.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.BigPoly)">
            <summary>Creates a Decryptor instance initialized with the specified encryption parameters and secret key.</summary>
            <param name="parms">The encryption parameters</param>
            <param name="secretKey">The secret key</param>
            <exception cref="T:System.ArgumentNullException">if parms or secretKey is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters or secret key are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
parameters.</seealso>
        </member>
        <member name="T:Microsoft.Research.SEAL.Decryptor">
            <summary>Decrypts BigPolyArray objects into BigPoly objects.</summary>
            <remarks>
                <para>
            Decrypts <see cref="T:Microsoft.Research.SEAL.BigPolyArray" /> objects into <see cref="T:Microsoft.Research.SEAL.BigPoly" /> objects. Constructing a
            Decryptor requires the encryption parameters (set through an <see cref="T:Microsoft.Research.SEAL.EncryptionParameters" /> object) and the
            secret key polynomial. The public and evaluation keys are not needed for decryption.
            </para>
            </remarks>
        </member>
        <member name="M:seal.Decryptor.inherent_noise(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Computes the inherent noise in a ciphertext. The result is written in a BigUInt given as a parameter.
        The user can easily compare this with the maximum possible value returned by the function
        EncryptionParameters::inherent_noise_max(). It is often easier to analyze the size of the inherent
        noise by using the functions inherent_noise_bits() and EncryptionParameters::inherent_noise_max().
        Instead of this function, consider using invariant_noise_budget(), which has several subtle advantages.

        @param[in] encrypted The ciphertext
        @param[out] destination The BigUInt to overwrite with the inherent noise
        @throws std::invalid_argument if encrypted is not a valid ciphertext for the encryption parameters
        @see inherent_noise_bits for returning the significant bit count of the inherent noise instead.

</member>
        <member name="M:seal.Decryptor.inherent_noise_bits(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Computes and returns the number of bits of inherent noise in a ciphertext. The user can easily compare
        this with the maximum possible value returned by the function EncryptionParameters::inherent_noise_bits_max().
        Instead of this function, consider using invariant_noise_budget(), which has several subtle advantages.

        @param[in] encrypted The ciphertext
        @throws std::invalid_argument if encrypted is not a valid ciphertext for the encryption parameters
        @see inherent_noise for computing the exact size of inherent noise.

</member>
        <member name="M:seal.Decryptor.secret_key">
Returns the secret key used by the Decryptor.

</member>
        <member name="M:seal.Decryptor.decrypt(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decrypts an BigPolyArray and returns the result.

        @param[in] encrypted The ciphertext to decrypt
        @throws std::invalid_argument if the ciphertext is not a valid ciphertext for the encryption parameters

</member>
        <member name="M:seal.Decryptor.decrypt(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new Decryptor by moving an old one.

        @param[in] source The Decryptor to move from

</member>
        <member name="M:seal.Decryptor.#ctor(seal.Decryptor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a copy of a Decryptor.

        @param[in] copy The Decryptor to copy from

</member>
        <member name="M:seal.Decryptor.#ctor(seal.EncryptionParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates an Decryptor instance initialized with the specified encryption parameters and secret key. 
        Optionally, the user can give a reference to a MemoryPoolHandle object to use a custom memory pool
        instead of the global memory pool (default).

        @param[in] parms The encryption parameters
        @param[in] secret_key The secret key
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if encryption parameters or secret key are not valid
        @see EncryptionParameters for more details on valid encryption parameters.
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.Decryptor">
Decrypts BigPolyArray objects into BigPoly objects. Constructing an Decryptor requires the encryption
parameters (set through an EncryptionParameters object) and the secret key. The public and evaluation keys 
are not needed for decryption.

</member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.GetBigPolyArith">
            <summary>Returns a reference to the underlying C++ BigPolyArith instance.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Finalize">
            <summary>Destroys the BigPolyArithmetic instance.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Dispose">
            <summary>Destroys the BigPolyArithmetic instance.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.TryInvert(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Attempts to invert a polynomial with the specified coefficient and polynomial moduli, returning whether or not
                the inverse was successful and setting the result parameter to the inverse.</summary>
            <remarks>
                Attempts to invert a polynomial with the specified coefficient and polynomial moduli, returning whether or not the
                inverse was successful and setting the result parameter to the inverse. The poly polynomials must have fewer
                significant coefficients than polyMod and have coefficients less-than coeffMod. The result polynomial is resized if it
                has fewer coefficients than polyMod's significant coefficient count or if it's coefficient bit count is smaller than
                coeffMod's bit count.
                </remarks>
            <param name="poly">The polynomial to invert</param>
            <param name="polyMod">The polynomial modulus</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="result">The polynomial to store the inverse result</param>
            <exception cref="T:System.ArgumentNullException">If poly, polyMod, coeffMod, or result is null</exception>
            <exception cref="T:System.ArgumentException">If polyMod is zero</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly has greater-than or equal significant coefficient count to polyMod
                or has any coefficients greater than or equal to coeffMod</exception>
            <exception cref="T:System.ArgumentException">If polyMod has any coefficients greater than or equal to
                coeffMod</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Modulo(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and returns the
                remainder.</summary>
            <remarks>
                Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and returns the remainder.
                The input numerator and denominator polynomials are not modified. All coefficients in numerator and denominator must
                be less-than coeffMod. The returned polynomial is sized to have a coefficient count equal to the larger of numerator
                and denominator's coefficient counts, and a coefficient bit count equal to coeffMod's bit count.
                </remarks>
            <param name="numerator">The numerator to divide</param>
            <param name="denominator">The denominator to divide</param>
            <param name="coeffMod">The coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">If numerator, denominator, or coeffMod is null</exception>
            <exception cref="T:System.ArgumentException">If denominator is zero</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If numerator or denominator has any coefficients greater than or equal to
                coeffMod</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Modulo(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and stores the
                remainder in remainder.</summary>
            <remarks>
                Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and stores the remainder in
                remainder. The input numerator and denominator polynomials are not modified. All coefficients in numerator and
                denominator must be less-than coeffMod. The remainder polynomial is resized if it has fewer coefficients than the
                larger of numerator and denominator's coefficient counts, or if it's coefficient bit count is smaller than coeffMod's
                bit count.
                </remarks>
            <param name="numerator">The numerator to divide</param>
            <param name="denominator">The denominator to divide</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="remainder">The polynomial to store the remainder of the division result</param>
            <exception cref="T:System.ArgumentNullException">If numerator, denominator, coeffMod, or remainder is null</exception>
            <exception cref="T:System.ArgumentException">If denominator is zero</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If numerator or denominator has any coefficients greater than or equal to
                coeffMod</exception>
            <exception cref="T:System.InvalidOperationException">If remainder is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Divide(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and stores the
                quotient and remainder in provided parameters.</summary>
            <remarks>
                Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and stores the quotient and
                remainder in provided parameters. The input numerator and denominator polynomials are not modified. All coefficients in
                numerator and denominator must be less-than coeffMod. The quotient and remainder polynomials are resized if they have
                fewer coefficients than the greater of numerator and denominator's coefficient counts, or if their coefficient bit
                counts are smaller than coeffMod's bit count.
                </remarks>
            <param name="numerator">The numerator to divide</param>
            <param name="denominator">The denominator to divide</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="quotient">The polynomial to store the quotient of the division result</param>
            <param name="remainder">The polynomial to store the remainder of the division result</param>
            <exception cref="T:System.ArgumentNullException">If numerator, denominator, coeffMod, quotient, or remainder is null
                </exception>
            <exception cref="T:System.ArgumentException">If denominator is zero</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If numerator or denominator has any coefficients greater than or equal to
                coeffMod</exception>
            <exception cref="T:System.ArgumentException">If quotient and remainder point to the same backing array</exception>
            <exception cref="T:System.InvalidOperationException">If quotient or remainder is an alias but needs to be resized to fit
                the result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Multiplies a polynomial by an integer, and returns the result.</summary>
            <remarks>
                Multiplies a polynomial by an integer, and returns the result. The inputs poly1 and uint2 are not modified. The
                returned polynomial is sized to have a coefficient count equal to poly1's coefficient count, and a coefficient bit
                count equal to the sum of poly1's significant coefficient bit count and uint2's significant bit count.
                </remarks>
            <param name="poly1">The polynomial to multiply</param>
            <param name="uint2">The integer to multiply</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Multiplies a polynomial by an integer, and stores the result in result.</summary>
            <remarks>
                Multiplies a polynomial by an integer, and stores the result in result. The inputs poly1 and uint2 are not modified.
                The result polynomial is resized if it has fewer coefficients than poly1's coefficient count, or if its coefficient
                bit count is smaller than the sum of poly1's significant coefficient bit count and uint2's significant bit count.
                </remarks>
            <param name="poly1">The polynomial to multiply</param>
            <param name="uint2">The integer to multiply</param>
            <param name="result">The polynomial to store the multiplication result</param>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Multiplies a polynomial by an integer modulo the specified coefficient modulus, and returns the
                result.</summary>
            <remarks>
                Multiplies a polynomial by an integer modulo the specified coefficient modulus, and returns the result. The inputs
                poly1 and uint2 are not modified. All coefficients in poly1 and uint2 must be less-than coeffMod. The returned
                polynomial is sized to have a coefficient count equal to poly1's coefficient count, and a coefficient bit count equal
                to coeffMod's bit count.
                </remarks>
            <param name="poly1">The polynomial to multiply</param>
            <param name="uint2">The integer to multiply</param>
            <param name="coeffMod">The coefficient modulus</param>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 has any coefficients greater than or equal to coeffMod</exception>
            <exception cref="T:System.ArgumentException">If uint2 is greater than or equal to coeffMod</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Multiplies a polynomial by an integer modulo the specified coefficient modulus, and stores the result in
                result.</summary>
            <remarks>
                Multiplies a polynomial by an integer modulo the specified coefficient modulus, and stores the result in result. The
                inputs poly1 and uint2 are not modified. All coefficients in poly1 and uint2 must be less-than coeffMod. The result
                polynomial is resized if it has fewer coefficients than poly1's coefficient count, or if its coefficient bit count is
                smaller than coeffMod's bit count.
                </remarks>
            <param name="poly1">The first polynomial to multiply</param>
            <param name="uint2">The integer to multiply</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="result">The polynomial to store the multiplication result</param>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 has any coefficients greater than or equal to coeffMod</exception>
            <exception cref="T:System.ArgumentException">If uint2 is greater than or equal to coeffMod</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Multiplies the poly1 and poly2 polynomials, and returns the result.</summary>
            <remarks>
                Multiplies the poly1 and poly2 polynomials, and returns the result. The input poly1 and poly2 polynomials are not
                modified. The returned polynomial is sized to have a coefficient count equal to one less than the sum of poly1 and
                poly2's significant coefficient counts, and a coefficient bit count equal to the sum of poly1 and poly2's significant
                coefficient bit count added with the significant bit count of the smaller of poly1 and poly2's significant coefficient
                count (i.e., poly1.significantCoeffBitCount() + poly2.significantCoeffBitCount() +
                getSignificantBitCount(min(poly1.significantCoeffCount(), poly2.significantCoeffCount()))).
                </remarks>
            <param name="poly1">The first polynomial to multiply</param>
            <param name="poly2">The second polynomial to multiply</param>
            <exception cref="T:System.ArgumentNullException">If poly1 or poly2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Multiplies the poly1 and poly2 polynomials, and stores the result in result.</summary>
            <remarks>
                Multiplies the poly1 and poly2 polynomials, and stores the result in result. The input poly1 and poly2 polynomials are
                not modified. The result polynomial is resized if it has fewer coefficients than one less than the sum of poly1 and
                poly2's significant coefficient counts, or if it's coefficient bit count is smaller than the sum of poly1 and poly2's
                significant coefficient bit count added with the significant bit count of the smaller of poly1 and poly2's significant
                coefficient count (i.e., poly1.significantCoeffBitCount() + poly2.significantCoeffBitCount() +
                getSignificantBitCount(min(poly1.significantCoeffCount(), poly2.significantCoeffCount()))).
                </remarks>
            <param name="poly1">The first polynomial to multiply</param>
            <param name="poly2">The second polynomial to multiply</param>
            <param name="result">The polynomial to store the multiplication result</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, or result is null</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Multiplies the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the
                result.</summary>
            <remarks>
                Multiplies the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the result. The input
                poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than coeffMod. The
                returned polynomial is sized to have a coefficient count equal to one less than the sum of poly1 and poly2's
                significant coefficient counts, and a coefficient bit count equal to coeffMod's bit count.
                </remarks>
            <param name="poly1">The first polynomial to multiply</param>
            <param name="poly2">The second polynomial to multiply</param>
            <param name="coeffMod">The coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, or coeffMod is null</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 or poly2 has any coefficients greater than or equal to
                coeffMod</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Multiplies the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in
                result.</summary>
            <remarks>
                Multiplies the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in result.
                The input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than
                coeffMod. The result polynomial is resized if it has fewer coefficients than one less than the sum of poly1 and
                poly2's significant coefficient counts, or if it's coefficient bit count is smaller than coeffMod's bit count.
                </remarks>
            <param name="poly1">The first polynomial to multiply</param>
            <param name="poly2">The second polynomial to multiply</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="result">The polynomial to store the multiplication result</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, coeffMod, or result is null</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 or poly2 has any coefficients greater than or equal to
                coeffMod</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Multiplies the poly1 and poly2 polynomials modulo the specified polynomial and coefficient moduli, and returns
                the result.</summary>
            <remarks>
                Multiplies the poly1 and poly2 polynomials modulo the specified polynomial and coefficient moduli, and returns the
                result. The input poly1 and poly2 polynomials are not modified. Both polynomials must have fewer significant
                coefficients than polyMod and have coefficients less-than coeffMod. The returned polynomial is sized to have a
                coefficient count equal to polyMod's significant coefficient count and a coefficient bit count equal to coeffMod's bit
                count.
                </remarks>
            <param name="poly1">The first polynomial to multiply</param>
            <param name="poly2">The second polynomial to multiply</param>
            <param name="polyMod">The polynomial modulus</param>
            <param name="coeffMod">The coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, polyMod, or coeffMod is null</exception>
            <exception cref="T:System.ArgumentException">If polyMod is zero</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 or poly2 has greater-than or equal significant coefficient count
                to polyMod or has any coefficients greater than or equal to coeffMod</exception>
            <exception cref="T:System.ArgumentException">If polyMod has any coefficients greater than or equal to
                coeffMod</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Multiply(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Multiplies the poly1 and poly2 polynomials modulo the specified polynomial and coefficient moduli, and stores
                the result in result.</summary>
            <remarks>
                Multiplies the poly1 and poly2 polynomials modulo the specified polynomial and coefficient moduli, and stores the
                result in result. The input poly1 and poly2 polynomials are not modified. Both polynomials must have fewer significant
                coefficients than polyMod and have coefficients less-than coeffMod. The result polynomial is resized if it has fewer
                coefficients than polyMod's significant coefficient count or if it's coefficient bit count is smaller than coeffMod's
                bit count.
                </remarks>
            <param name="poly1">The first polynomial to multiply</param>
            <param name="poly2">The second polynomial to multiply</param>
            <param name="polyMod">The polynomial modulus</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="result">The polynomial to store the multiplication result</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, polyMod, coeffMod, or result is null</exception>
            <exception cref="T:System.ArgumentException">If polyMod is zero</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 or poly2 has greater-than or equal significant coefficient count
                to polyMod or has any coefficients greater than or equal to coeffMod</exception>
            <exception cref="T:System.ArgumentException">If polyMod has any coefficients greater than or equal to
                coeffMod</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Sub(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Subtracts the poly1 and poly2 polynomials, and returns the result.</summary>
            <remarks>
                Subtracts the poly1 and poly2 polynomials, and returns the result. The input poly1 and poly2 polynomials are not
                modified. The result polynomial is sized to have a coefficient count equal to the larger of poly1 or poly2's
                coefficient counts, and a coefficient bit count equal to the larger of poly1 and poly2's coefficient bit count.
                </remarks>
            <param name="poly1">The first polynomial to subtract</param>
            <param name="poly2">The second polynomial to subtract</param>
            <exception cref="T:System.ArgumentNullException">If poly1 or poly2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Sub(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Subtracts the poly1 and poly2 polynomials, and stores the result in result.</summary>
            <remarks>
                Subtracts the poly1 and poly2 polynomials, and stores the result in result. The input poly1 and poly2 polynomials are
                not modified. The result polynomial is resized if it has fewer coefficients than the larger of poly1 or poly2's
                coefficient counts, or if it's coefficient bit count is smaller than the larger of poly1 and poly2's coefficient bit
                count.
                </remarks>
            <param name="poly1">The first polynomial to subtract</param>
            <param name="poly2">The second polynomial to subtract</param>
            <param name="result">The polynomial to store the subtraction result</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, or result is null</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Add(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Adds the poly1 and poly2 polynomials, and returns the result.</summary>
            <remarks>
                Adds the poly1 and poly2 polynomials, and returns the result. The input poly1 and poly2 polynomials are not modified.
                The result polynomial is sized to have a coefficient count equal to the larger of poly1 or poly2's coefficient counts,
                and a coefficient bit count equal to one greater than the larger of poly1 and poly2's significant coefficient bit
                count.
                </remarks>
            <param name="poly1">The first polynomial to add</param>
            <param name="poly2">The second polynomial to add</param>
            <exception cref="T:System.ArgumentNullException">If poly1 or poly2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Add(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Adds the poly1 and poly2 polynomials, and stores the result in result.</summary>
            <remarks>
                Adds the poly1 and poly2 polynomials, and stores the result in result. The input poly1 and poly2 polynomials are not
                modified. The result polynomial is resized if it has fewer coefficients than the larger of poly1 or poly2's
                coefficient counts, or if it's coefficient bit count is smaller than one greater than the larger of poly1 and poly2's
                significant coefficient bit count.
                </remarks>
            <param name="poly1">The first polynomial to add</param>
            <param name="poly2">The second polynomial to add</param>
            <param name="result">The polynomial to store the addition result</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, or result is null</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Sub(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Subtracts the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the
                result.</summary>
            <remarks>
                Subtracts the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the result. The input
                poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than coeffMod. The
                returned polynomial is sized to have a coefficient count equal to the larger of poly1 or poly2's coefficient counts,
                and a coefficient bit count equal to coeffMod's bit count.
                </remarks>
            <param name="poly1">The first polynomial to subtract</param>
            <param name="poly2">The second polynomial to subtract</param>
            <param name="coeffMod">The coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, or coeffMod is null</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 or poly2 has any coefficients greater than or equal to
                coeffMod</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Sub(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Subtracts the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in
                result.</summary>
            <remarks>
                Subtracts the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in result.
                The input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than
                coeffMod. The result polynomial is resized if it has fewer coefficients than the larger of poly1 or poly2's
                coefficient counts, or if it's coefficient bit count is smaller than coeffMod's bit count.
                </remarks>
            <param name="poly1">The first polynomial to subtract</param>
            <param name="poly2">The second polynomial to subtract</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="result">The polynomial to store the subtraction result</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, coeffMod, or result is null</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 or poly2 has any coefficients greater than or equal to
                coeffMod</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Add(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Adds the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the
                result.</summary>
            <remarks>
                Adds the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the result. The input poly1
                and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than coeffMod. The returned
                polynomial is sized to have a coefficient count equal to the larger of poly1 or poly2's coefficient counts, and a
                coefficient bit count equal to coeffMod's bit count.
                </remarks>
            <param name="poly1">The first polynomial to add</param>
            <param name="poly2">The second polynomial to add</param>
            <param name="coeffMod">The coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, or coeffMod is null</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 or poly2 has any coefficients greater than or equal to
                coeffMod</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Add(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Adds the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in
                result.</summary>
            <remarks>
                Adds the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in result. The
                input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than coeffMod.
                The result polynomial is resized if it has fewer coefficients than the larger of poly1 or poly2's coefficient counts,
                or if it's coefficient bit count is smaller than coeffMod's bit count.
                </remarks>
            <param name="poly1">The first polynomial to add</param>
            <param name="poly2">The second polynomial to add</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="result">The polynomial to store the addition result</param>
            <exception cref="T:System.ArgumentNullException">If poly1, poly2, coeffMod, or result is null</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly1 or poly2 has any coefficients greater than or equal to
                coeffMod</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Negate(Microsoft.Research.SEAL.BigPoly)">
            <summary>Negates the coefficients of a specified polynomial and returns the result.</summary>
            <remarks>
                Negates the coefficients of a specified polynomial and returns the result. The input poly parameter is not modified.
                The returned polynomial is sized identical to poly.
                </remarks>
            <param name="poly">The polynomial to negate</param>
            <exception cref="T:System.ArgumentNullException">If poly is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Negate(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Negates the coefficients of a specified polynomial and stores the result in result.</summary>
            <remarks>
                Negates the coefficients of a specified polynomial and stores the result in result. The input poly parameter is not
                modified. The result polynomial is resized if it is smaller than poly's coefficient count or coefficient bit count.
                </remarks>
            <param name="poly">The polynomial to negate</param>
            <param name="result">The polynomial to store the negated result</param>
            <exception cref="T:System.ArgumentNullException">If poly or result is null</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Negate(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Negates the coefficients of a specified polynomial modulo the specified coefficient modulus, and returns the
                result.</summary>
            <remarks>
                Negates the coefficients of a specified polynomial modulo the specified coefficient modulus, and returns the result.
                The input poly parameter is not modified. All coefficients in poly must be less-than coeffMod. The returned polynomial
                is sized to have poly's coefficient count and coeffMod's bit count.
                </remarks>
            <param name="poly">The polynomial to negate</param>
            <param name="coeffMod">The coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">If poly or coeffMod is null</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly has any coefficients greater than or equal to coeffMod</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.Negate(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Negates the coefficients of a specified polynomial modulo the specified coefficient modulus, and stores the
                result in result.</summary>
            <remarks>
                Negates the coefficients of a specified polynomial modulo the specified coefficient modulus, and stores the result in
                result. The input poly parameter is not modified. All coefficients in poly must be less-than coeffMod. The result
                polynomial is resized if it has fewer coefficients than poly's coefficient count or coeffMod's bit count.
                </remarks>
            <param name="poly">The polynomial to negate</param>
            <param name="coeffMod">The coefficient modulus</param>
            <param name="result">The polynomial to store the negated result</param>
            <exception cref="T:System.ArgumentNullException">If poly, coeffMod, or result is null</exception>
            <exception cref="T:System.ArgumentException">If coeffMod is zero</exception>
            <exception cref="T:System.ArgumentException">If poly has any coefficients greater than or equal to coeffMod</exception>
            <exception cref="T:System.InvalidOperationException">If result is an alias but needs to be resized to fit the
                result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArithmetic.#ctor">
            <summary>Creates an BigPolyArithmetic instance.</summary>
        </member>
        <member name="T:Microsoft.Research.SEAL.BigPolyArithmetic">
            <summary>Provides arithmetic and modular arithmetic functions for operating on polynomials (represented by
            BigPoly's).</summary>
            <remarks>
                <para>
            Provides arithmetic and modular arithmetic functions for operating on polynomials (represented by BigPoly's).
            </para>
                <para>
            All functions in BigPolyArith are not thread safe and a separate BigPolyArith instance is needed for each potentially
            concurrent invocation.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.BigPoly">See BigPoly for more details on polynomials.</seealso>
        </member>
        <member name="M:seal.BigPolyArith.try_invert(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Attempts to invert a polynomial with the specified coefficient and polynomial moduli, returning whether or not
        the inverse was successful and setting the result parameter to the inverse. The poly polynomials must have fewer
        significant coefficients than poly_mod and have coefficients less-than coeff_mod. The result polynomial is resized
        if it has fewer coefficients than poly_mod's significant coefficient count or if it's coefficient bit count is
        smaller than coeff_mod's bit count.

        @param[in] poly The polynomial to invert
        @param[in] poly_mod The polynomial modulus
        @param[in] coeff_mod The coefficient modulus
        @param[out] result The polynomial to store the inverse result
        @throws std::invalid_argument If poly_mod is zero
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly has greater-than or equal significant coefficient count to poly_mod or has any
        coefficients greater than or equal to coeff_mod
        @throws std::invalid_argument If poly_mod has any coefficients greater than or equal to coeff_mod
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.modulo(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and returns the
        remainder. The input numerator and denominator polynomials are not modified. All coefficients in numerator and
        denominator must be less-than coeff_mod. The returned polynomial is sized to have a coefficient count equal to
        the larger of numerator and denominator's coefficient counts, and a coefficient bit count equal to coeff_mod's
        bit count.

        @param[in] numerator The numerator to divide
        @param[in] denominator The denominator to divide
        @param[in] coeff_mod The coefficient modulus
        @throws std::invalid_argument If denominator is zero
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If numerator or denominator has any coefficients greater than or equal to coeff_mod
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.modulo(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and stores the remainder
        in remainder. The input numerator and denominator polynomials are not modified. All coefficients in numerator and
        denominator must be less-than coeff_mod. The remainder polynomial is resized if it has fewer coefficients than the
        larger of numerator and denominator's coefficient counts, or if it's coefficient bit count is smaller than
        coeff_mod's bit count.

        @param[in] numerator The numerator to divide
        @param[in] denominator The denominator to divide
        @param[in] coeff_mod The coefficient modulus
        @param[out] remainder The polynomial to store the remainder of the division result
        @throws std::invalid_argument If denominator is zero
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If numerator or denominator has any coefficients greater than or equal to coeff_mod
        @throws std::logic_error If remainder is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.divide(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides the numerator and denominator polynomials modulo the specified coefficient modulus, and stores the quotient
        and remainder in provided parameters. The input numerator and denominator polynomials are not modified. All
        coefficients in numerator and denominator must be less-than coeff_mod. The quotient and remainder polynomials are
        resized if they have fewer coefficients than the greater of numerator and denominator's coefficient counts, or if
        their coefficient bit counts are smaller than coeff_mod's bit count.

        @param[in] numerator The numerator to divide
        @param[in] denominator The denominator to divide
        @param[in] coeff_mod The coefficient modulus
        @param[out] quotient The polynomial to store the quotient of the division result
        @param[out] remainder The polynomial to store the remainder of the division result
        @throws std::invalid_argument If denominator is zero
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If numerator or denominator has any coefficients greater than or equal to coeff_mod
        @throws std::invalid_argument If quotient and remainder point to the same backing array
        @throws std::logic_error If quotient or remainder is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies a polynomial by an integer, and returns the result. The inputs poly1 and uint2 are not modified. The returned
        polynomial is sized to have a coefficient count equal to poly1's coefficient count, and a coefficient bit count equal to
        the sum of poly1's significant coefficient bit count and uint2's significant bit count.

        @param[in] poly1 The polynomial to multiply
        @param[in] uint2 The integer to multiply
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies a polynomial by an integer, and stores the result in result. The inputs poly1 and uint2 are not modified.
        The result polynomial is resized if it has fewer coefficients than poly1's coefficient count, or if its coefficient bit
        count is smaller than the sum of poly1's significant coefficient bit count and uint2's significant bit count.

        @param[in] poly1 The polynomial to multiply
        @param[in] uint2 The integer to multiply
        @param[out] result The polynomial to store the multiplication result
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies a polynomial by an integer modulo the specified coefficient modulus, and returns the result. The inputs
        poly1 and uint2 are not modified. All coefficients in poly1 and uint2 must be less-than coeff_mod. The returned
        polynomial is sized to have a coefficient count equal to poly1's coefficient count, and a coefficient bit count
        equal to coeff_mod's bit count.

        @param[in] poly1 The polynomial to multiply
        @param[in] uint2 The integer to multiply
        @param[in] coeff_mod The coefficient modulus
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 has any coefficients greater than or equal to coeff_mod
        @throws std::invalid_argument If uint2 is greater than or equal to coeff_mod
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies a polynomial by an integer modulo the specified coefficient modulus, and stores the result in result.
        The inputs poly1 and uint2 are not modified. All coefficients in poly1 and uint2 must be less-than coeff_mod.
        The result polynomial is resized if it has fewer coefficients than poly1's coefficient count, or if its
        coefficient bit count is smaller than coeff_mod's bit count.

        @param[in] poly1 The first polynomial to multiply
        @param[in] uint2 The integer to multiply
        @param[in] coeff_mod The coefficient modulus
        @param[out] result The polynomial to store the multiplication result
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 has any coefficients greater than or equal to coeff_mod
        @throws std::invalid_argument If uint2 is greater than or equal to coeff_mod
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies the poly1 and poly2 polynomials, and returns the result. The input poly1 and poly2 polynomials are not
        modified. The returned polynomial is sized to have a coefficient count equal to one less than the sum of poly1 and
        poly2's significant coefficient counts, and a coefficient bit count equal to the sum of poly1 and poly2's significant
        coefficient bit count added with the significant bit count of the smaller of poly1 and poly2's significant coefficient
        count (i.e., poly1.significant_coeff_bit_count() + poly2.significant_coeff_bit_count() +
        get_significant_bit_count(min(poly1.significant_coeff_count(), poly2.significant_coeff_count()))).

        @param[in] poly1 The first polynomial to multiply
        @param[in] poly2 The second polynomial to multiply
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies the poly1 and poly2 polynomials, and stores the result in result. The input poly1 and poly2 polynomials are
        not modified. The result polynomial is resized if it has fewer coefficients than one less than the sum of poly1 and
        poly2's significant coefficient counts, or if it's coefficient bit count is smaller than the sum of poly1 and poly2's
        significant coefficient bit count added with the significant bit count of the smaller of poly1 and poly2's significant
        coefficient count (i.e., poly1.significant_coeff_bit_count() + poly2.significant_coeff_bit_count() +
        get_significant_bit_count(min(poly1.significant_coeff_count(), poly2.significant_coeff_count()))).

        @param[in] poly1 The first polynomial to multiply
        @param[in] poly2 The second polynomial to multiply
        @param[out] result The polynomial to store the multiplication result
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the result. The
        input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than coeff_mod.
        The returned polynomial is sized to have a coefficient count equal to one less than the sum of poly1 and poly2's
        significant coefficient counts, and a coefficient bit count equal to coeff_mod's bit count.

        @param[in] poly1 The first polynomial to multiply
        @param[in] poly2 The second polynomial to multiply
        @param[in] coeff_mod The coefficient modulus
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 or poly2 has any coefficients greater than or equal to coeff_mod
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in result.
        The input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than
        coeff_mod. The result polynomial is resized if it has fewer coefficients than one less than the sum of poly1 and
        poly2's significant coefficient counts, or if it's coefficient bit count is smaller than coeff_mod's bit count.

        @param[in] poly1 The first polynomial to multiply
        @param[in] poly2 The second polynomial to multiply
        @param[in] coeff_mod The coefficient modulus
        @param[out] result The polynomial to store the multiplication result
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 or poly2 has any coefficients greater than or equal to coeff_mod
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies the poly1 and poly2 polynomials modulo the specified polynomial and coefficient moduli, and returns the
        result. The input poly1 and poly2 polynomials are not modified. Both polynomials must have fewer significant
        coefficients than poly_mod and have coefficients less-than coeff_mod. The returned polynomial is sized to have a
        coefficient count equal to poly_mod's significant coefficient count and a coefficient bit count equal to
        coeff_mod's bit count.

        @param[in] poly1 The first polynomial to multiply
        @param[in] poly2 The second polynomial to multiply
        @param[in] poly_mod The polynomial modulus
        @param[in] coeff_mod The coefficient modulus
        @throws std::invalid_argument If poly_mod is zero
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 or poly2 has greater-than or equal significant coefficient count to poly_mod
        or has any coefficients greater than or equal to coeff_mod
        @throws std::invalid_argument If poly_mod has any coefficients greater than or equal to coeff_mod
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.multiply(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies the poly1 and poly2 polynomials modulo the specified polynomial and coefficient moduli, and stores the
        result in result. The input poly1 and poly2 polynomials are not modified. Both polynomials must have fewer
        significant coefficients than poly_mod and have coefficients less-than coeff_mod. The result polynomial is resized
        if it has fewer coefficients than poly_mod's significant coefficient count or if it's coefficient bit count is
        smaller than coeff_mod's bit count.

        @param[in] poly1 The first polynomial to multiply
        @param[in] poly2 The second polynomial to multiply
        @param[in] poly_mod The polynomial modulus
        @param[in] coeff_mod The coefficient modulus
        @param[out] result The polynomial to store the multiplication result
        @throws std::invalid_argument If poly_mod is zero
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 or poly2 has greater-than or equal significant coefficient count to poly_mod
        or has any coefficients greater than or equal to coeff_mod
        @throws std::invalid_argument If poly_mod has any coefficients greater than or equal to coeff_mod
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.sub(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts the poly1 and poly2 polynomials, and returns the result. The input poly1 and poly2 polynomials are not
        modified. The result polynomial is sized to have a coefficient count equal to the larger of poly1 or poly2's
        coefficient counts, and a coefficient bit count equal to the larger of poly1 and poly2's coefficient bit count.

        @param[in] poly1 The first polynomial to subtract
        @param[in] poly2 The second polynomial to subtract
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.sub(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts the poly1 and poly2 polynomials, and stores the result in result. The input poly1 and poly2 polynomials
        are not modified. The result polynomial is resized if it has fewer coefficients than the larger of poly1 or
        poly2's coefficient counts, or if it's coefficient bit count is smaller than the larger of poly1 and poly2's
        coefficient bit count.

        @param[in] poly1 The first polynomial to subtract
        @param[in] poly2 The second polynomial to subtract
        @param[out] result The polynomial to store the subtraction result
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.add(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds the poly1 and poly2 polynomials, and returns the result. The input poly1 and poly2 polynomials are not
        modified. The result polynomial is sized to have a coefficient count equal to the larger of poly1 or poly2's
        coefficient counts, and a coefficient bit count equal to one greater than the larger of poly1 and poly2's
        significant coefficient bit count.

        @param[in] poly1 The first polynomial to add
        @param[in] poly2 The second polynomial to add
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.add(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds the poly1 and poly2 polynomials, and stores the result in result. The input poly1 and poly2 polynomials
        are not modified. The result polynomial is resized if it has fewer coefficients than the larger of poly1 or
        poly2's coefficient counts, or if it's coefficient bit count is smaller than one greater than the larger of
        poly1 and poly2's significant coefficient bit count.

        @param[in] poly1 The first polynomial to add
        @param[in] poly2 The second polynomial to add
        @param[out] result The polynomial to store the addition result
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.sub(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the result.
        The input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be
        less-than coeff_mod. The returned polynomial is sized to have a coefficient count equal to the larger of
        poly1 or poly2's coefficient counts, and a coefficient bit count equal to coeff_mod's bit count.

        @param[in] poly1 The first polynomial to subtract
        @param[in] poly2 The second polynomial to subtract
        @param[in] coeff_mod The coefficient modulus
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 or poly2 has any coefficients greater than or equal to coeff_mod
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.sub(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in
        result. The input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be
        less-than coeff_mod. The result polynomial is resized if it has fewer coefficients than the larger of poly1
        or poly2's coefficient counts, or if it's coefficient bit count is smaller than coeff_mod's bit count.

        @param[in] poly1 The first polynomial to subtract
        @param[in] poly2 The second polynomial to subtract
        @param[in] coeff_mod The coefficient modulus
        @param[out] result The polynomial to store the subtraction result
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 or poly2 has any coefficients greater than or equal to coeff_mod
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.add(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds the poly1 and poly2 polynomials modulo the specified coefficient modulus, and returns the result. The
        input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than
        coeff_mod. The returned polynomial is sized to have a coefficient count equal to the larger of poly1 or
        poly2's coefficient counts, and a coefficient bit count equal to coeff_mod's bit count.

        @param[in] poly1 The first polynomial to add
        @param[in] poly2 The second polynomial to add
        @param[in] coeff_mod The coefficient modulus
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 or poly2 has any coefficients greater than or equal to coeff_mod
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.add(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds the poly1 and poly2 polynomials modulo the specified coefficient modulus, and stores the result in result.
        The input poly1 and poly2 polynomials are not modified. All coefficients in both polynomials must be less-than
        coeff_mod. The result polynomial is resized if it has fewer coefficients than the larger of poly1 or poly2's
        coefficient counts, or if its coefficient bit count is smaller than coeff_mod's bit count.

        @param[in] poly1 The first polynomial to add
        @param[in] poly2 The second polynomial to add
        @param[in] coeff_mod The coefficient modulus
        @param[out] result The polynomial to store the addition result
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly1 or poly2 has any coefficients greater than or equal to coeff_mod
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.negate(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Negates the coefficients of a specified polynomial and returns the result. The input poly parameter is not modified.
        The returned polynomial is sized identical to poly.

        @param[in] poly The polynomial to negate
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.negate(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Negates the coefficients of a specified polynomial and stores the result in result. The input poly parameter is not
        modified. The result polynomial is resized if it is smaller than poly's coefficient count or coefficient bit count.

        @param[in] poly The polynomial to negate
        @param[out] result The polynomial to store the negated result
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.negate(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Negates the coefficients of a specified polynomial modulo the specified coefficient modulus, and returns the
        result. The input poly parameter is not modified. All coefficients in poly must be less-than coeff_mod. The
        returned polynomial is sized to have poly's coefficient count and coeff_mod's bit count.

        @param[in] poly The polynomial to negate
        @param[in] coeff_mod The coefficient modulus
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly has any coefficients greater than or equal to coeff_mod
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="M:seal.BigPolyArith.negate(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Negates the coefficients of a specified polynomial modulo the specified coefficient modulus, and stores the result
        in result. The input poly parameter is not modified. All coefficients in poly must be less-than coeff_mod. The
        result polynomial is resized if it has fewer coefficients than poly's coefficient count or coeff_mod's bit count.

        @param[in] poly The polynomial to negate
        @param[in] coeff_mod The coefficient modulus
        @param[out] result The polynomial to store the negated result
        @throws std::invalid_argument If coeff_mod is zero
        @throws std::invalid_argument If poly has any coefficients greater than or equal to coeff_mod
        @throws std::logic_error If result is an alias but needs to be resized to fit the result
        @warning all functions in BigPolyArith are not thread-safe

</member>
        <member name="T:seal.BigPolyArith">
    Provides arithmetic and modular arithmetic functions for operating on polynomials (represented by BigPoly's).

    @warning All functions in BigPolyArith are not thread safe and a separate BigPolyArith instance is needed for each
    potentially concurrent invocation.

    @see BigPoly for more details on polynomials.

</member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncryptor.GetEncryptor">
            <summary>Returns a reference to the underlying C++ ChooserEncryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncryptor.Decrypt(Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Returns a copy of a given ChooserPoly, but sets the operation history to null.</summary>
            <remarks>
Returns a copy of a given <see cref="T:Microsoft.Research.SEAL.ChooserPoly" />, but sets the operation history to null. This amounts to "decryption" in the
sense that the output only carries information about the size of a plaintext polynomial.
</remarks>
            <param name="encrypted">The ChooserPoly modeling a ciphertext polynomial (e.g. constructed with <see cref="T:Microsoft.Research.SEAL.ChooserEncoder" />)</param>
            <exception cref="T:System.ArgumentNullException">if encrypted is null</exception>
            <exception cref="T:System.ArgumentException">if encrypted has null operation history</exception>
            <seealso>See Encryptor::Decrypt() for the corresponding operation on real plaintext/ciphertext polynomials.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncryptor.Decrypt(Microsoft.Research.SEAL.ChooserPoly,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Overwrites the referenced ChooserPoly destination with the referenced ChooserPoly encrypted, and sets the
operation history of destination to null.</summary>
            <remarks>
Overwrites the referenced <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> destination with the referenced ChooserPoly encrypted, and sets the operation
history of destination to null. This amounts to "decryption" in the sense that destination only carries information
about the size of a plaintext polynomial.
</remarks>
            <param name="encrypted">The ChooserPoly modeling a ciphertext polynomial (e.g. constructed with <see cref="T:Microsoft.Research.SEAL.ChooserEncoder" />)</param>
            <param name="destination">The ChooserPoly to overwrite with the "decrypted" ChooserPoly</param>
            <exception cref="T:System.ArgumentNullException">if encrypted or destination is null</exception>
            <exception cref="T:System.ArgumentException">if encrypted has null operation history</exception>
            <seealso>See Decryptor::Decrypt() for the corresponding operation on real plaintext/ciphertext polynomials.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncryptor.Encrypt(Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Makes a copy of a given <see cref="T:Microsoft.Research.SEAL.ChooserPoly" />, but sets the operation history to that of a freshly encrypted ciphertext.</summary>
            <param name="plain">The ChooserPoly modeling a plaintext polynomial (e.g. constructed with <see cref="T:Microsoft.Research.SEAL.ChooserEncoder" />)</param>
            <exception cref="T:System.ArgumentNullException">if plain is null</exception>
            <exception cref="T:System.ArgumentException">if plain has non-null operation history</exception>
            <seealso>See Encryptor::Encrypt() for the corresponding operation on real plaintext/ciphertext polynomials.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncryptor.Encrypt(Microsoft.Research.SEAL.ChooserPoly,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Overwrites the referenced <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> destination with the referenced ChooserPoly plain, and sets the
operation history of destination to that of a freshly encrypted ciphertext.</summary>
            <param name="plain">The ChooserPoly modeling a plaintext polynomial (e.g. constructed with <see cref="T:Microsoft.Research.SEAL.ChooserEncoder" />)</param>
            <param name="destination">The ChooserPoly to overwrite with the "encrypted" ChooserPoly</param>
            <exception cref="T:System.ArgumentNullException">if plain or destination is null</exception>
            <exception cref="T:System.ArgumentException">if plain has non-null operation history</exception>
            <seealso>See Encryptor::Encrypt() for the corresponding operation on real plaintext/ciphertext polynomials.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncryptor.Finalize">
            <summary>Destroys the ChooserEncryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncryptor.Dispose">
            <summary>Destroys the ChooserEncryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncryptor.#ctor">
            <summary>Creates a ChooserEncryptor object.</summary>
        </member>
        <member name="T:Microsoft.Research.SEAL.ChooserEncryptor">
            <summary>Manipulates ChooserPoly objects created by ChooserEncoder by setting their operation history to that of a
freshly encrypted ciphertext.</summary>
            <remarks>
Manipulates <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects created by <see cref="T:Microsoft.Research.SEAL.ChooserEncoder" /> by setting their operation history to that of a freshly
encrypted ciphertext. This converts them from carriers of only information about the size of plaintext polynomials
into carriers of also a model of inherent noise. After the ChooserPoly objects have been "encrypted" using
ChooserEncryptor::Encrypt(), they can further be manipulated using the many functions of <see cref="T:Microsoft.Research.SEAL.ChooserEvaluator" />. This class
is a part of the automatic parameter selection module.
</remarks>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserPoly">See ChooserPoly for the object modeling encrypted/plaintext data for automatic parameter
selection.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEvaluator">See ChooserEvaluator for manipulating instances of ChooserPoly.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncoder">See ChooserEncoder for modeling the behavior of encoding with ChooserPoly
objects.</seealso>
            <seealso>See Encryptor for the corresponding operations on real plaintext polynomials.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.Simulation">See Simulation for the class that handles the inherent noise growth estimates.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.GetEncoder">
            <summary>Returns a reference to the underlying C++ ChooserEncoder.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.ChooserEncoder.Base">
            <summary>Returns the base used for encoding.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Encode(System.UInt32)">
            <summary>Encodes a number (represented by System::UInt32) into a ChooserPoly object.</summary>
            <remarks>
Encodes a number (represented by System::UInt32) into a <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> object. This is done by first encoding it with
<see cref="T:Microsoft.Research.SEAL.IntegerEncoder" /> and then simply reading the number of coefficients and the maximal absolute value of the coefficients
in the polynomial. In the returned ChooserPoly the computation history is set to null.
</remarks>
            <param name="value">The non-negative integer to encode</param>
            <seealso>See IntegerEncoder::Encode() for the corresponding function returning a real polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Encode(System.Int32)">
            <summary>Encodes a number (represented by System::Int32) into a ChooserPoly object.</summary>
            <remarks>
Encodes a number (represented by System::Int32) into a <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> object. This is done by first encoding it with
<see cref="T:Microsoft.Research.SEAL.IntegerEncoder" /> and then simply reading the number of coefficients and the maximal absolute value of the coefficients
in the polynomial. In the returned ChooserPoly the computation history is set to null.
</remarks>
            <param name="value">The integer to encode</param>
            <seealso>See IntegerEncoder::Encode() for the corresponding function returning a real polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Encode(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Encodes a number (represented by BigUInt) into a ChooserPoly object given as an argument.</summary>
            <remarks>
Encodes a number (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) into a <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> object given as an argument. This is done by first
encoding it with <see cref="T:Microsoft.Research.SEAL.IntegerEncoder" /> and then simply reading the number of coefficients and the maximal absolute value of
the coefficients in the polynomial. In the output ChooserPoly the operation history is set to null.
</remarks>
            <param name="value">The non-negative integer to encode</param>
            <param name="destination">Reference to a ChooserPoly where the output will be stored</param>
            <exception cref="T:System.ArgumentNullException">if value is null</exception>
            <seealso>See IntegerEncoder::Encode() for the corresponding function returning a real polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Encode(Microsoft.Research.SEAL.BigUInt)">
            <summary>Encodes a number (represented by BigUInt) into a ChooserPoly object.</summary>
            <remarks>
Encodes a number (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) into a <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> object. This is done by first encoding it with
<see cref="T:Microsoft.Research.SEAL.IntegerEncoder" /> and then simply reading the number of coefficients and the maximal absolute value of the coefficients
in the polynomial. In the returned ChooserPoly the computation history is set to null.
</remarks>
            <param name="value">The non-negative integer to encode</param>
            <exception cref="T:System.ArgumentNullException">if value is null</exception>
            <seealso>See IntegerEncoder::Encode() for the corresponding function returning a real polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Encode(System.Int64,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Encodes a number (represented by System::Int64) into a ChooserPoly object given as an argument.</summary>
            <remarks>
Encodes a number (represented by System::Int64) into a <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> object given as an argument. This is done by first
encoding it with <see cref="T:Microsoft.Research.SEAL.IntegerEncoder" /> and then simply reading the number of coefficients and the maximal absolute value of
the coefficients in the polynomial. In the output ChooserPoly the operation history is set to null.
</remarks>
            <param name="value">The integer to encode</param>
            <param name="destination">Reference to a ChooserPoly where the output will be stored</param>
            <seealso>See IntegerEncoder::Encode() for the corresponding function returning a real polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Encode(System.Int64)">
            <summary>Encodes a number (represented by System::Int64) into a ChooserPoly object.</summary>
            <remarks>
Encodes a number (represented by System::Int64) into a <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> object. This is done by first encoding it with
<see cref="T:Microsoft.Research.SEAL.IntegerEncoder" /> and then simply reading the number of coefficients and the maximal absolute value of the coefficients
in the polynomial. In the returned ChooserPoly the computation history is set to null.
</remarks>
            <param name="value">The integer to encode</param>
            <seealso>See IntegerEncoder::Encode() for the corresponding function returning a real polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Encode(System.UInt64,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Encodes a number (represented by System::UInt64) into a ChooserPoly object given as an argument.</summary>
            <remarks>
Encodes a number (represented by System::UInt64) into a <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> object given as an argument. This is done by first
encoding it with <see cref="T:Microsoft.Research.SEAL.IntegerEncoder" /> and then simply reading the number of coefficients and the maximal absolute value of
the coefficients in the polynomial. In the output ChooserPoly the operation history is set to null.
</remarks>
            <param name="value">The non-negative integer to encode</param>
            <param name="destination">Reference to a ChooserPoly where the output will be stored</param>
            <seealso>See IntegerEncoder::Encode() for the corresponding function returning a real polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Encode(System.UInt64)">
            <summary>Encodes a number (represented by System::UInt64) into a ChooserPoly object.</summary>
            <remarks>
Encodes a number (represented by System::UInt64) into a <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> object. This is done by first encoding it with
<see cref="T:Microsoft.Research.SEAL.IntegerEncoder" /> and then simply reading the number of coefficients and the maximal absolute value of the coefficients
in the polynomial. In the returned ChooserPoly the computation history is set to null.
</remarks>
            <param name="value">The non-negative integer to encode</param>
            <seealso>See IntegerEncoder::Encode() for the corresponding function returning a real polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Finalize">
            <summary>Destroys the ChooserEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.Dispose">
            <summary>Destroys the ChooserEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.#ctor(System.UInt64)">
            <summary>Creates a ChooserEncoder that can be used to create ChooserPoly objects modeling plaintext polynomials encoded
with IntegerEncoder with the base given as argument.</summary>
            <remarks>
Creates a ChooserEncoder that can be used to create <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects modeling plaintext polynomials encoded with
<see cref="T:Microsoft.Research.SEAL.IntegerEncoder" />. The base is given by the user as a parameter, and it can be any integer at least 2.
</remarks>
            <param name="base">The base to be used for encoding (default value is 2)</param>
            <exception cref="T:System.ArgumentException">if base is not an integer and at least 2</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEncoder.#ctor">
            <summary>Creates a ChooserEncoder that can be used to create ChooserPoly objects modeling plaintext polynomials encoded
with <see cref="T:Microsoft.Research.SEAL.IntegerEncoder" />, with base set to 2.</summary>
        </member>
        <member name="T:Microsoft.Research.SEAL.ChooserEncoder">
            <summary>Constructs ChooserPoly objects representing encoded plaintexts.</summary>
            <remarks>
                <para>
Constructs <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects representing encoded plaintexts. ChooserPoly objects constructed in 
this way have null operation history. They can be further used by <see cref="T:Microsoft.Research.SEAL.ChooserEncryptor" />, or in the 
functions ChooserEvaluator::MultiplyPlain(), ChooserEvaluator::AddPlain(), ChooserEvaluator::SubPlain() 
representing plaintext operands. Only the integer encodings (those provided by <see cref="T:Microsoft.Research.SEAL.IntegerEncoder" />) 
are supported by ChooserEncoder. This class is a part of the automatic parameter selection module.
</para>
            </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserPoly">See ChooserPoly for the object modeling encrypted/plaintext data for automatic parameter
selection.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEvaluator">See ChooserEvaluator for manipulating instances of ChooserPoly.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncryptor">See ChooserEncryptor for modeling the behavior of encryption with ChooserPoly
objects.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.IntegerEncoder">See IntegerEncoder for the corresponding encoder for real data.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.Simulation">See Simulation for the class that handles the noise budget consumption estimates.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.GetEvaluator">
            <summary>Returns a reference to the underlying C++ ChooserEvaluator.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultNoiseMaxDeviation">
            <summary>Returns the default value for the maximal deviation of the noise (error) distribution.</summary>
            <remarks>
Returns the default value for the maximal deviation of the noise (error) distribution.
An expert user might want to give a modified value as an argument to SelectParameters().
</remarks>
        </member>
        <member name="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultNoiseStandardDeviation">
            <summary>Returns the default value for the standard deviation of the noise (error) distribution.</summary>
            <remarks>
Returns the default value for the standard deviation of the noise (error) distribution.
An expert user might want to give a modified value as an argument to SelectParameters().
</remarks>
        </member>
        <member name="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultParameterOptions">
            <summary>Returns the default set of (degree(polynomial modulus),coeffModulus)-pairs.</summary>
            <remarks>
Returns the default set of (degree(polynomial modulus),coeffModulus)-pairs. The function returns a dictionary 
of entries where the degree of the polynomial modulus acts as the key, and the corresponding modulus is the value.
An expert user might want to give a modified dictionary as an argument to SelectParameters() for better results.
</remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.SelectParameters(System.Collections.Generic.List`1{Microsoft.Research.SEAL.ChooserPoly},System.Int32,System.Double,System.Double,System.Collections.Generic.Dictionary`2{System.Int32,Microsoft.Research.SEAL.BigUInt},Microsoft.Research.SEAL.EncryptionParameters)">
            <summary>Provides the user with optimized encryption parameters that are large enough to support the
operations performed on all of the given <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects.</summary>
            <remarks>
                <para>
Provides the user with optimized encryption parameters that are large enough to support the
operations performed on all of the given <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. The standard deviation 
of the noise distribution, the maximal deviation, and the list from which we choose the size of the
polynomial modulus and the coefficient modulus are provided by the user as input parameters. 
The function returns true or false depending on whether a working parameter set was found or not.
</para>
                <para>
The budgetGap parameter can be used to ensure that a certain amount of noise budget remains unused.
</para>
                <para>
The parameter options are given as a dictionary, where the sizes of the polynomial moduli are the
keys, and the corresponding values are the coefficient moduli (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />).
The sizes of the polynomial moduli must be at least 512 and powers of 2.
</para>
            </remarks>
            <param name="operands">The ChooserPolys for which the parameters are optimized</param>
            <param name="budgetGap">The amount of noise budget (bits) that should remain unused</param>
            <param name="noiseStandardDeviation">The noise standard deviation</param>
            <param name="noiseMaxDeviation">The maximal noise deviation</param>
            <param name="parameterOptions">The parameter options to be used</param>
            <param name="destination">The encryption parameters to overwrite with the selected parameter set</param>
            <exception cref="T:System.ArgumentNullException">if operands list or any of its elements is null</exception>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
            <exception cref="T:System.ArgumentNullException">if parameterOptions or any of its values is null</exception>
            <exception cref="T:System.InvalidOperationException">if operation history is null</exception>
            <exception cref="T:System.ArgumentException">if operands is empty</exception>
            <exception cref="T:System.ArgumentException">if budgetGap is negative</exception>
            <exception cref="T:System.ArgumentException">if noiseStandardDeviation is negative</exception>
            <exception cref="T:System.ArgumentException">if noiseMaxDeviation is negative</exception>
            <exception cref="T:System.ArgumentException">if parameterOptions is empty</exception>
            <exception cref="T:System.ArgumentException">if parameterOptions has keys that are less than 512 or not powers of 2</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for a description of the encryption parameters.</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultNoiseStandardDeviation">See DefaultNoiseStandardDeviation() for the default noise standard deviation.</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultNoiseMaxDeviation">See DefaultNoiseMaxDeviation() for the default maximal noise deviation.</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultParameterOptions">See DefaultParameterOptions() for the default set of parameter options.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.SelectParameters(System.Collections.Generic.List`1{Microsoft.Research.SEAL.ChooserPoly},System.Int32,Microsoft.Research.SEAL.EncryptionParameters)">
            <summary>Provides the user with optimized encryption parameters that are large enough to support the operations
performed on all of the given <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects.</summary>
            <remarks>
                <para>
Provides the user with optimized encryption parameters that are large enough to support the operations
performed on all of the given <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. The function returns true or false 
depending on whether a working parameter set was found or not.
</para>
                <para>
The budgetGap parameter can be used to ensure that a certain amount of noise budget remains unused.
</para>
            </remarks>
            <param name="operands">The ChooserPolys for which the parameters are optimized</param>
            <param name="budgetGap">The amount of noise budget (bits) that should remain unused</param>
            <param name="destination">The encryption parameters to overwrite with the selected parameter set</param>
            <exception cref="T:System.ArgumentNullException">if operands list or any of its elements is null</exception>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
            <exception cref="T:System.InvalidOperationException">if operation history of any of the given ChooserPolys is null</exception>
            <exception cref="T:System.ArgumentException">if operands is empty</exception>
            <exception cref="T:System.ArgumentException">if budgetGap is negative</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for a description of the encryption parameters.</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultNoiseStandardDeviation">See DefaultNoiseStandardDeviation() for the default noise standard deviation.</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultNoiseMaxDeviation">See DefaultNoiseMaxDeviation() for the default maximal noise deviation.</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.ChooserEvaluator.DefaultParameterOptions">See DefaultParameterOptions() for the default set of parameter options.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Negate(Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::Negate() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::Negate() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history 
accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to negate</param>
            <exception cref="T:System.ArgumentNullException">if operand is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <seealso>See Evaluator::Negate() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::Negate() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Exponentiate(Microsoft.Research.SEAL.ChooserPoly,System.UInt64)">
            <summary>Performs an operation modeling Evaluator::Exponentiate() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::Exponentiate() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This 
operation creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext
polynomial and on the absolute values of the coefficients based on the inputs, and sets the operation 
history accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to raise to a power</param>
            <param name="exponent">The power to raise the ChooserPoly object to</param>
            <exception cref="T:System.ArgumentNullException">if operand is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if exponent is zero</exception>
            <seealso>See Evaluator::Exponentiate() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::Exponentiate() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.SubPlain(Microsoft.Research.SEAL.ChooserPoly,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::SubPlain() on ChooserPoly objects.</summary>
            <remarks>
                <para>
Performs an operation modeling Evaluator::SubPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</para>
                <para>
This variant of the function takes the plaintext to subtract as input in the form of another ChooserPoly.
If the plaintext to be subtracted is already known at the time of performing the automatic parameter 
selection, one can use ChooserEncoder to construct the appropriate ChooserPoly for plainChooserPoly. 
This function completely ignores the operation history possibly carried by plainChooserPoly.
</para>
            </remarks>
            <param name="operand">The ChooserPoly object to subtract from</param>
            <param name="plainChooserPoly">The plaintext polynomial to subtract represented by a ChooserPoly</param>
            <exception cref="T:System.ArgumentNullException">if operand or plainChooserPoly is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainChooserPoly is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainChooserPoly has a non-positive bound on the number of non-zero coefficients</exception>
            <seealso>See Evaluator::SubPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::SubPlain() for the corresponding operation on Simulation objects.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncoder">See ChooserEncoder for constructing the ChooserPoly for the plaintext to subtract.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.SubPlain(Microsoft.Research.SEAL.ChooserPoly,System.Int32,System.UInt64)">
            <summary>Performs an operation modeling Evaluator::SubPlain() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::SubPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to subtract from</param>
            <param name="plainMaxCoeffCount">Bound on the number of non-zero coefficients in the plaintext polynomial to subtract</param>
            <param name="plainMaxAbsValue">Bound on the absolute value of coefficients of the plaintext polynomial to subtract</param>
            <exception cref="T:System.ArgumentNullException">if operand is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is not positive</exception>
            <seealso>See Evaluator::SubPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::SubPlain() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.SubPlain(Microsoft.Research.SEAL.ChooserPoly,System.Int32,Microsoft.Research.SEAL.BigUInt)">
            <summary>Performs an operation modeling Evaluator::SubPlain() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::SubPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to subtract from</param>
            <param name="plainMaxCoeffCount">Bound on the number of non-zero coefficients in the plaintext polynomial to subtract</param>
            <param name="plainMaxAbsValue">Bound on the absolute value of coefficients of the plaintext polynomial to subtract</param>
            <exception cref="T:System.ArgumentNullException">if operand or plainMaxAbsValue is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is not positive</exception>
            <seealso>See Evaluator::SubPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::SubPlain() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.AddPlain(Microsoft.Research.SEAL.ChooserPoly,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::AddPlain() on ChooserPoly objects.</summary>
            <remarks>
                <para>
Performs an operation modeling Evaluator::AddPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</para>
                <para>
This variant of the function takes the plaintext to add as input in the form of another ChooserPoly. If the plaintext
to be added is already known at the time of performing the automatic parameter selection, one can use ChooserEncoder to
construct the appropriate ChooserPoly for plainChooserPoly. This function completely ignores the operation history
possibly carried by plainChooserPoly.
</para>
            </remarks>
            <param name="operand">The ChooserPoly object to add</param>
            <param name="plainChooserPoly">The plaintext polynomial to add represented by a ChooserPoly</param>
            <exception cref="T:System.ArgumentNullException">if operand or plainChooserPoly is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainChooserPoly is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainChooserPoly has a non-positive bound on the number of non-zero coefficients</exception>
            <seealso>See Evaluator::AddPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::AddPlain() for the corresponding operation on Simulation objects.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncoder">See ChooserEncoder for constructing the ChooserPoly for the plaintext to add.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.AddPlain(Microsoft.Research.SEAL.ChooserPoly,System.Int32,System.UInt64)">
            <summary>Performs an operation modeling Evaluator::AddPlain() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::AddPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to add</param>
            <param name="plainMaxCoeffCount">Bound on the number of non-zero coefficients in the plaintext polynomial to add</param>
            <param name="plainMaxAbsValue">Bound on the absolute value of coefficients of the plaintext polynomial to add</param>
            <exception cref="T:System.ArgumentNullException">if operand is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is not positive</exception>
            <seealso>See Evaluator::AddPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::AddPlain() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.AddPlain(Microsoft.Research.SEAL.ChooserPoly,System.Int32,Microsoft.Research.SEAL.BigUInt)">
            <summary>Performs an operation modeling Evaluator::AddPlain() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::AddPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to add</param>
            <param name="plainMaxCoeffCount">Bound on the number of non-zero coefficients in the plaintext polynomial to add</param>
            <param name="plainMaxAbsValue">Bound on the absolute value of coefficients of the plaintext polynomial to add</param>
            <exception cref="T:System.ArgumentNullException">if operand or plainMaxAbsValue is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is not positive</exception>
            <seealso>See Evaluator::AddPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::AddPlain() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.MultiplyPlain(Microsoft.Research.SEAL.ChooserPoly,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::MultiplyPlain() on ChooserPoly objects.</summary>
            <remarks>
                <para>
Performs an operation modeling Evaluator::MultiplyPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This 
operation creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext 
polynomial and on the absolute values of the coefficients based on the inputs, and sets the operation 
history accordingly.
</para>
                <para>
This variant of the function takes the plaintext multiplier as input in the form of another ChooserPoly.
If the plaintext multiplier is already known at the time of performing the automatic parameter selection,
one can use <see cref="T:Microsoft.Research.SEAL.ChooserEncoder" /> to construct the appropriate ChooserPoly for plainChooserPoly. This function
completely ignores the operation history possibly carried by plainChooserPoly.
</para>
            </remarks>
            <param name="operand">The ChooserPoly object to multiply</param>
            <param name="plainChooserPoly">The plaintext polynomial to multiply represented by a ChooserPoly</param>
            <exception cref="T:System.ArgumentNullException">if operand or plainChooserPoly is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainChooserPoly is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainChooserPoly models a zero plaintext</exception>
            <seealso>See Evaluator::MultiplyPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::MultiplyPlain() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncoder">See ChooserEncoder for constructing a ChooserPoly representing the plaintext multiplier.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.MultiplyPlain(Microsoft.Research.SEAL.ChooserPoly,System.Int32,System.UInt64)">
            <summary>Performs an operation modeling Evaluator::MultiplyPlain() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::MultiplyPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This 
operation creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext 
polynomial and on the absolute values of the coefficients based on the inputs, and sets the operation 
history accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to multiply</param>
            <param name="plainMaxCoeffCount">Bound on the number of non-zero coefficients in the plaintext polynomial to multiply</param>
            <param name="plainMaxAbsValue">Bound on the absolute value of coefficients of the plaintext polynomial to multiply</param>
            <exception cref="T:System.ArgumentNullException">if operand is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is not positive</exception>
            <exception cref="T:System.ArgumentException">if plainMaxAbsValue is zero</exception>
            <seealso>See Evaluator::MultiplyPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::MultiplyPlain() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.MultiplyPlain(Microsoft.Research.SEAL.ChooserPoly,System.Int32,Microsoft.Research.SEAL.BigUInt)">
            <summary>Performs an operation modeling Evaluator::MultiplyPlain() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::MultiplyPlain() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This 
operation creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext 
polynomial and on the absolute values of the coefficients based on the inputs, and sets the operation 
history accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to multiply</param>
            <param name="plainMaxCoeffCount">Bound on the number of non-zero coefficients in the plaintext polynomial to multiply</param>
            <param name="plainMaxAbsValue">Bound on the absolute value of coefficients of the plaintext polynomial to multiply</param>
            <exception cref="T:System.ArgumentNullException">if operand or plainMaxAbsValue is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is not positive</exception>
            <exception cref="T:System.ArgumentException">if plainMaxAbsValue is zero</exception>
            <seealso>See Evaluator::MultiplyPlain() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::MultiplyPlain() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Relinearize(Microsoft.Research.SEAL.ChooserPoly,System.Int32)">
            <summary>Performs an operation modeling Evaluator::Relinearize() on ChooserPoly objects.</summary>
            <remarks>
                <para>
Performs an operation modeling Evaluator::Relinearize() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This 
operation creates a new ChooserPoly with the same bounds on the degree of the corresponding plaintext
polynomial and on the absolute values of the coefficients as the input, but sets the operation history 
to include the relinearization operation.
</para>
                <para>
The parameter destinationSize is not verified for correctness in this function. Instead,
if an impossible value is given, simulating the noise growth in the returned ChooserPoly
will throw an exception.
</para>
            </remarks>
            <param name="operand">The ChooserPoly object to relinearize</param>
            <param name="destinationSize">The size of the output ciphertext that is being modeled</param>
            <exception cref="T:System.ArgumentNullException">if operand is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <seealso>See Evaluator::Relinearize() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::Relinearize() for the corresponding
operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Relinearize(Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::Relinearize() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::Relinearize() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This 
operation creates a new ChooserPoly with the same bounds on the degree of the corresponding plaintext 
polynomial and on the absolute values of the coefficients as the input, but sets the operation history
to include the relinearization operation.
</remarks>
            <param name="operand">The ChooserPoly object to relinearize</param>
            <exception cref="T:System.ArgumentNullException">if operand is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <seealso>See Evaluator::Relinearize() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::Relinearize() for the corresponding
operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Square(Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::Square() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::Square() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This
operation creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext 
polynomial and on the absolute values of the coefficients based on the inputs, and sets the operation 
history accordingly.
</remarks>
            <param name="operand">The ChooserPoly object to square</param>
            <exception cref="T:System.ArgumentNullException">if operand is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not correctly initialized</exception>
            <seealso>See Evaluator::Square() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::Square() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Multiply(Microsoft.Research.SEAL.ChooserPoly,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::Multiply() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::Multiply() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This 
operation creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext 
polynomial and on the absolute values of the coefficients based on the inputs, and sets the operation 
history accordingly.
</remarks>
            <param name="operand1">The first ChooserPoly object to multiply</param>
            <param name="operand2">The second ChooserPoly object to multiply</param>
            <exception cref="T:System.ArgumentNullException">if operand1 or operand2 is null</exception>
            <exception cref="T:System.ArgumentException">if either operand1 or operand2 is not correctly initialized</exception>
            <seealso>See Evaluator::Multiply() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::Multiply() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Sub(Microsoft.Research.SEAL.ChooserPoly,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::Sub() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::Sub() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</remarks>
            <param name="operand1">The ChooserPoly object to subtract from</param>
            <param name="operand2">The ChooserPoly object to subtract</param>
            <exception cref="T:System.ArgumentNullException">if operand1 or operand2 is null</exception>
            <exception cref="T:System.ArgumentException">if either operand1 or operand2 is not correctly initialized</exception>
            <seealso>See Evaluator::Sub() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::Sub() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.AddMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.ChooserPoly})">
            <summary>Performs an operation modeling Evaluator::AddMany() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::AddMany() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</remarks>
            <param name="operands">The ChooserPoly object to add</param>
            <exception cref="T:System.ArgumentNullException">if operands or any of its elements is null</exception>
            <exception cref="T:System.ArgumentException">if any of the elements of operands is not correctly initialized</exception>
            <seealso>See Evaluator::AddMany() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::AddMany() for the corresponding operation on Simulation objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Add(Microsoft.Research.SEAL.ChooserPoly,Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Performs an operation modeling Evaluator::Add() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::Add() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This operation 
creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial 
and on the absolute values of the coefficients based on the inputs, and sets the operation history accordingly.
</remarks>
            <param name="operand1">The first ChooserPoly object to add</param>
            <param name="operand2">The second ChooserPoly object to add</param>
            <exception cref="T:System.ArgumentNullException">if operand1 or operand2 is null</exception>
            <exception cref="T:System.ArgumentException">if either operand1 or operand2 is not correctly initialized</exception>
            <seealso>See Evaluator::Add() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::Add() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.MultiplyMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.ChooserPoly})">
            <summary>Performs an operation modeling Evaluator::MultiplyMany() on ChooserPoly objects.</summary>
            <remarks>
Performs an operation modeling Evaluator::MultiplyMany() on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects. This 
operation creates a new <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> with updated bounds on the degree of the corresponding 
plaintext polynomial and on the absolute values of the coefficients based on the inputs, and sets the 
operation history accordingly.
</remarks>
            <param name="operands">The list of ChooserPoly objects to multiply</param>
            <exception cref="T:System.ArgumentNullException">if operands list or any of its elements is null</exception>
            <exception cref="T:System.ArgumentException">if operands list is empty</exception>
            <exception cref="T:System.ArgumentException">if any of the ChooserPoly objects in operands list is not correctly
initialized</exception>
            <seealso>See Evaluator::MultiplyMany() for the corresponding operation on ciphertexts.</seealso>
            <seealso>See SimulationEvaluator::MultiplyMany() for the corresponding operation on <see cref="T:Microsoft.Research.SEAL.Simulation" /> objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Finalize">
            <summary>Destroys the ChooserEvaluator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.Dispose">
            <summary>Destroys the ChooserEvaluator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.#ctor(Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a ChooserEvaluator.</summary>
            <remarks>
                Creates a ChooserEvaluator. The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object 
                to use a custom memory pool instead of the global memory pool (default).
                </remarks>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if pool is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserEvaluator.#ctor">
            <summary>Creates a ChooserEvaluator.</summary>
        </member>
        <member name="T:Microsoft.Research.SEAL.ChooserEvaluator">
            <summary>Models arithmetic operations on ChooserPoly objects rather than performing them on real data.</summary>
            <remarks>
                <para>
            Models arithmetic operations on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects rather than performing them on real 
            data. The class ChooserEvaluator has a public API similar to that of Evaluator, making it easy for 
            the user to run existing code on <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects rather than on actual data. All of 
            these operations take as input a varying number of <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> objects and return a new 
            one with an appropriately extended operation history. This class is a part of the automatic parameter 
            selection module.
            </para>
                <para>
            The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
            a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
            of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
            the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
            invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
            starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
            computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
            correctly.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserPoly">See ChooserPoly for the object modeling encrypted/plaintext data 
            for automatic parameter selection.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncoder">See ChooserEncoder for modeling the behavior of encoding with 
            ChooserPoly objects.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncryptor">See ChooserEncryptor for modeling the behavior of encryption
            with ChooserPoly objects.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.Simulation">See Simulation for the class that handles the noise budget consumption 
            estimates.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.#ctor(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of a C++ ChooserPoly.</summary>
            <remarks>
Creates a deep copy of a C++ ChooserPoly. The created ChooserPoly will model plaintext data with same size bounds as the
original one, and contains a clone of the original operation history.
</remarks>
            <param name="value">The ChooserPoly to copy from</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.GetChooserPoly">
            <summary>Returns a reference to the underlying C++ ChooserPoly.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.SetFresh">
            <summary>Sets the operation history to that of a freshly encrypted ciphertext.</summary>
            <remarks>
                <para>
Sets the operation history to that of a freshly encrypted ciphertext. This function leaves the bounds on the degree and
the absolute value of the coefficients of the modeled plaintext polynomial unchanged.
</para>
            </remarks>
            <seealso cref="P:Microsoft.Research.SEAL.ChooserPoly.MaxCoeffCount">See MaxCoeffCount to set the bound on the degree of the modeled plaintext polynomial.</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.ChooserPoly.MaxAbsValue">See MaxAbsValue to set the bound on the absolute value of coefficients of the modeled
plaintext polynomial.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.Reset">
            <summary>Sets the bounds on the degree and the absolute value of the coefficients of the modeled plaintext polynomial
                to zero, and sets the operation history to null.</summary>
            <remarks>
                <para>
                Sets the bounds on the degree and the absolute value of the coefficients of the modeled plaintext polynomial to zero,
                and sets the operation history to null.
                </para>
                <para>
                Note that a null operation history is not the same as that of a freshly encrypted ciphertext.
                </para>
            </remarks>
            <seealso cref="M:Microsoft.Research.SEAL.ChooserPoly.SetFresh">See SetFresh() for setting the operation history to that of a freshly encrypted
                ciphertext.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.Simulate(Microsoft.Research.SEAL.EncryptionParameters)">
            <summary>Simulates noise budget consumption in the operation history of the current instance of 
                ChooserPoly.</summary>
            <remarks>
                Simulates noise budget consumption in the operation history of the current instance of ChooserPoly.
                The return value is a Simulation object.
                </remarks>
            <param name="parms">The encryption parameters</param>
            <exception cref="T:System.ArgumentNullException">if parms is null</exception>
            <exception cref="T:System.InvalidOperationException">if operation history is null, i.e. the current ChooserPoly models a
                plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
                parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.Simulation">See Simulation for the class that handles the noise budget consumption estimates.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.TestParameters(Microsoft.Research.SEAL.EncryptionParameters,System.Int32)">
            <summary>Determines whether given encryption parameters are large enough to support operations in 
                the operation history of the current ChooserPoly.</summary>
            <remarks>
                <para>
                Determines whether given encryption parameters are large enough to support operations in the operation 
                history of the current ChooserPoly. A ChooserPoly produced as a result of some number of arithmetic
                operations (with <see cref="T:Microsoft.Research.SEAL.ChooserEvaluator" />) contains information about bounds on the number of 
                non-zero coefficients in a corresponding plaintext polynomial and on the absolute values of the 
                coefficients. For decryption to work correctly, these bounds must be small enough to be supported
                by the encryption parameters. Additionally, the encryption parameters must be large enough to provide 
                enough invariant noise budget for the performed operations.
                </para>
                <para>
                The budgetGap parameter can be used to ensure that a certain amount of noise budget remains unused.
                </para>
                <para>
                The return value is true or false depending on whether given encryption parameters are large enough to support the
                operations in the operation history of the current ChooserPoly.
                </para>
            </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="budgetGap">The amount of noise budget (bits) that should remain unused</param>
            <exception cref="T:System.ArgumentNullException">if parms is null</exception>
            <exception cref="T:System.InvalidOperationException">if the current operation history is null, i.e. the current ChooserPoly models a
                plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <exception cref="T:System.ArgumentException">if budgetGap is negative</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
                parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.Simulation">See Simulation for the class that handles the noise budget consumption estimates.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.ChooserPoly.MaxAbsValue">
            <summary>Gets/sets the upper bound on the absolute value of coefficients (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) of the
                plaintext modeled by the current instance of ChooserPoly.</summary>
            <exception cref="T:System.ArgumentNullException">if value is null</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.ChooserPoly.MaxCoeffCount">
            <summary>Gets/Sets the upper bound on the number of non-zero coefficients in the plaintext modeled by the current
instance of ChooserPoly.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.Set(Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Overwrites the ChooserPoly with the value of the specified ChooserPoly.</summary>
            <remarks>
Overwrites the ChooserPoly with the value of the specified ChooserPoly. This includes creating a deep copy of the
operation history or the original one.
</remarks>
            <param name="assign">The ChooserPoly whose value should be assigned to the current ChooserPoly</param>
            <exception cref="T:System.ArgumentNullException">if assign is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.#ctor(Microsoft.Research.SEAL.ChooserPoly)">
            <summary>Creates a deep copy of a ChooserPoly.</summary>
            <remarks>
Creates a deep copy of a ChooserPoly. The created ChooserPoly will model plaintext data with same size bounds as the
original one, and contains a clone of the original operation history.
</remarks>
            <param name="copy">The ChooserPoly to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.Finalize">
            <summary>Destroys the ChooserPoly.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.Dispose">
            <summary>Destroys the ChooserPoly.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.#ctor(System.Int32,System.UInt64)">
            <summary>Creates a ChooserPoly object.</summary>
            <remarks>
                Creates a ChooserPoly object. The ChooserPoly instance models plaintext data with a given bound on the number of
                non-zero coefficients, and a given bound on the size of the absolute value of the coefficients (represented by 
                System::UInt64. This constructor sets the operation history to that of a freshly encrypted ciphertext.
                </remarks>
            <param name="maxCoeffCount">An upper bound on the number of non-zero coefficients in the modeled plaintext data</param>
            <param name="maxAbsValue">An upper bound on the absolute value of the coefficients in the modeled plaintext
                data</param>
            <exception cref="T:System.ArgumentException">if maxCoeffCount is less than or equal to zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.#ctor(System.Int32,Microsoft.Research.SEAL.BigUInt)">
            <summary>Creates a ChooserPoly object.</summary>
            <remarks>
                Creates a ChooserPoly object. The ChooserPoly instance models plaintext data with a given bound on the number of
                non-zero coefficients, and a given bound on the size of the absolute value of the coefficients (represented by
                <see cref="T:Microsoft.Research.SEAL.BigUInt" />). This constructor sets the operation history to that of a freshly encrypted ciphertext.
                </remarks>
            <param name="maxCoeffCount">An upper bound on the number of non-zero coefficients in the modeled plaintext data</param>
            <param name="maxAbsValue">An upper bound on the absolute value of the coefficients in the modeled plaintext
                data</param>
            <exception cref="T:System.ArgumentNullException">if maxAbsValue is null</exception>
            <exception cref="T:System.ArgumentException">if maxCoeffCount is less than or equal to zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.ChooserPoly.#ctor">
            <summary>Creates a ChooserPoly object.</summary>
            <remarks>
                Creates a ChooserPoly object. The ChooserPoly instance models a plaintext with no non-zero coefficients. More
                precisely, the number of non-zero coefficients, and the upper bound on the absolute values of the coefficients of the
                modeled plaintext polynomial are both set to zero. The operation history is set to null, which indicates that the
                ChooserPoly object does not represent a ciphertext but only a plaintext.
                </remarks>
        </member>
        <member name="T:Microsoft.Research.SEAL.ChooserPoly">
            <summary>Models ciphertexts for the automatic parameter selection module.</summary>
            <remarks>
                <para>
            Models ciphertexts for the automatic parameter selection module. Choosing appropriate and secure
            parameters for homomorphic cryptosystems is difficult, and beyond what a non-expert user should have
            to worry about. The user programs their computations as they normally would, but replace plaintexts with
            ChooserPoly objects. When the program is executed, ChooserPoly objects store the computation as a directed
            acyclic graph, and can later be used to estimate the invariant noise budget consumption in the stored
            computation. The estimated noise budget in the output ciphertext is given by the <see cref="M:Microsoft.Research.SEAL.ChooserPoly.Simulate(Microsoft.Research.SEAL.EncryptionParameters)" /> 
            function. This class is a part of the automatic parameter selection module.
            </para>
                <para>
            Each instance of ChooserPoly stores an estimate of the number of non-zero coefficients, and an estimate
            for their largest absolute value (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) that a plaintext polynomial can 
            be expected to contain after some number of homomorphic operations have been performed on it. In addition,
            each ChooserPoly stores a directed acyclic graph of computations that it has gone through (operation history).
            </para>
                <para>
            Instances of ChooserPoly can be manipulated using an instance of <see cref="T:Microsoft.Research.SEAL.ChooserEvaluator" />, which 
            has a public API similar to Evaluator, making existing code easy to run on ChooserPoly objects instead 
            of running it on actual encrypted data. In other words, using <see cref="T:Microsoft.Research.SEAL.ChooserEvaluator" />, ChooserPoly 
            objects can be added, multiplied, subtracted, negated, etc., and the result is always a new ChooserPoly 
            object whose estimated noise budget can be obtained using the <see cref="M:Microsoft.Research.SEAL.ChooserPoly.Simulate(Microsoft.Research.SEAL.EncryptionParameters)" /> function, 
            which uses heuristic worst-case analysis of the noise behavior in the encryption scheme.
            </para>
                <para>
            The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
            a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
            of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
            the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
            invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
            starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
            computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
            correctly.
            </para>
                <para>
            In general, reading a ChooserPoly is thread-safe while mutating is not. Specifically, concurrent 
            access must be avoided if the size bounds of the modeled plaintext data, or the operation history 
            are expected to be changed.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEvaluator">See ChooserEvaluator for manipulating instances of ChooserPoly.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncoder">See ChooserEncoder for modeling the behavior of encoding with ChooserPoly objects.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.ChooserEncryptor">See ChooserEncryptor for modeling the behavior of encryption with ChooserPoly objects.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.Simulation">See Simulation for the class that handles the noise budget consumption estimates.</seealso>
        </member>
        <member name="M:seal.ChooserEncryptor.decrypt(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns a copy of a given ChooserPoly, but sets the operation history to null.
        This amounts to "decryption" in the sense that the output only carries information
        about the size of a plaintext polynomial.

        @param[in] encrypted The ChooserPoly modeling a ciphertext polynomial (e.g. constructed with ChooserEncoder)
        @throws std::invalid_argument if encrypted has null operation history
        @see Encryptor::decrypt() for the corresponding operation on real plaintext/ciphertext polynomials.

</member>
        <member name="M:seal.ChooserEncryptor.decrypt(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.ChooserPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Overwrites the referenced ChooserPoly destination with the referenced ChooserPoly encrypted,
        and sets the operation history of destination to null. This amounts to "decryption" in the sense that
        destination only carries information about the size of a plaintext polynomial.

        @param[in] encrypted The ChooserPoly modeling a ciphertext polynomial (e.g. constructed with ChooserEncoder)
        @param[out] destination The ChooserPoly to overwrite with the "decrypted" ChooserPoly
        @throws std::invalid_argument if encrypted has null operation history
        @see Decryptor::decrypt() for the corresponding operation on real plaintext/ciphertext polynomials.

</member>
        <member name="M:seal.ChooserEncryptor.encrypt(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Makes a copy of a given ChooserPoly, but sets the operation history to that of a freshly encrypted ciphertext.

        @param[in] plain The ChooserPoly modeling a plaintext polynomial (e.g. constructed with ChooserEncoder)
        @throws std::invalid_argument if plain has non-null operation history
        @see Encryptor::encrypt() for the corresponding operation on real plaintext/ciphertext polynomials.

</member>
        <member name="M:seal.ChooserEncryptor.encrypt(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.ChooserPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Overwrites the referenced ChooserPoly destination with the referenced ChooserPoly plain,
        and sets the operation history of destination to that of a freshly encrypted ciphertext.

        @param[in] plain The ChooserPoly modeling a plaintext polynomial (e.g. constructed with ChooserEncoder)
        @param[out] destination The ChooserPoly to overwrite with the "encrypted" ChooserPoly
        @throws std::invalid_argument if plain has non-null operation history
        @see Encryptor::encrypt() for the corresponding operation on real plaintext/ciphertext polynomials.

</member>
        <member name="M:seal.ChooserEncryptor.#ctor">
Creates a ChooserEncryptor object.

</member>
        <member name="T:seal.ChooserEncryptor">
    Manipulates ChooserPoly objects created by ChooserEncoder by setting their operation history to that
    of a freshly encrypted ciphertext. This converts them from carriers of only information about
    the size of plaintext polynomials into carriers of also a model of inherent noise. After the
    ChooserPoly objects have been "encrypted" using ChooserEncryptor::encrypt(), they can further be
    manipulated using the many functions of ChooserEvaluator. This class is a part of the automatic
    parameter selection module.

    @see ChooserPoly for the object modeling encrypted/plaintext data for automatic parameter selection.
    @see ChooserEvaluator for manipulating instances of ChooserPoly.
    @see ChooserEncoder for modeling the behavior of encoding with ChooserPoly objects.
    @see Encryptor for the corresponding operations on real plaintext polynomials.
    @see Simulation for the class that handles the inherent noise growth estimates.

</member>
        <member name="M:seal.ChooserEncoder.base">
Returns the base used for encoding.

</member>
        <member name="M:seal.ChooserEncoder.encode(System.UInt32)">
        Encodes a number (represented by std::uint32_t) into a ChooserPoly object. This is done by first
        encoding it with IntegerEncoder and then simply reading the number of coefficients and the maximal
        absolute value of the coefficients in the polynomial. In the returned ChooserPoly the computation
        history is set to null.

        @param[in] value The non-negative integer to encode
        @see IntegerEncoder::encode() for the corresponding function returning a real polynomial.

</member>
        <member name="M:seal.ChooserEncoder.encode(System.Int32)">
        Encodes a number (represented by std::int32_t) into a ChooserPoly object. This is done by first
        encoding it with IntegerEncoder and then simply reading the number of coefficients and the maximal
        absolute value of the coefficients in the polynomial. In the returned ChooserPoly the computation
        history is set to null.

        @param[in] value The integer to encode
        @see IntegerEncoder::encode() for the corresponding function returning a real polynomial.

</member>
        <member name="M:seal.ChooserEncoder.encode(seal.BigUInt,seal.ChooserPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a number (represented by BigUInt) into a ChooserPoly object given as an argument.
        This is done by first encoding it with IntegerEncoder and then simply reading the number of
        coefficients and the maximal absolute value of the coefficients in the polynomial. In the output
        ChooserPoly the operation history is set to null.

        @param[in] value The non-negative integer to encode
        @param[out] destination Reference to a ChooserPoly where the output will be stored
        @see IntegerEncoder::encode() for the corresponding function returning a real polynomial.

</member>
        <member name="M:seal.ChooserEncoder.encode(seal.BigUInt)">
        Encodes a number (represented by BigUInt) into a ChooserPoly object. This is done by first
        encoding it with IntegerEncoder and then simply reading the number of coefficients and the maximal
        absolute value of the coefficients in the polynomial. In the returned ChooserPoly the computation
        history is set to null.

        @param[in] value The non-negative integer to encode
        @see IntegerEncoder::encode() for the corresponding function returning a real polynomial.

</member>
        <member name="M:seal.ChooserEncoder.encode(System.Int64,seal.ChooserPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a number (represented by std::int64_t) into a ChooserPoly object given as an argument.
        This is done by first encoding it with IntegerEncoder and then simply reading the number of
        coefficients and the maximal absolute value of the coefficients in the polynomial. In the output
        ChooserPoly the operation history is set to null.

        @param[in] value The integer to encode
        @param[out] destination Reference to a ChooserPoly where the output will be stored
        @see IntegerEncoder::encode() for the corresponding function returning a real polynomial.

</member>
        <member name="M:seal.ChooserEncoder.encode(System.Int64)">
        Encodes a number (represented by std::int64_t) into a ChooserPoly object. This is done by first
        encoding it with IntegerEncoder and then simply reading the number of coefficients and the maximal
        absolute value of the coefficients in the polynomial. In the returned ChooserPoly the computation
        history is set to null.

        @param[in] value The integer to encode
        @see IntegerEncoder::encode() for the corresponding function returning a real polynomial.

</member>
        <member name="M:seal.ChooserEncoder.encode(System.UInt64,seal.ChooserPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a number (represented by std::uint64_t) into a ChooserPoly object given as an argument.
        This is done by first encoding it with IntegerEncoder and then simply reading the number of
        coefficients and the maximal absolute value of the coefficients in the polynomial. In the output
        ChooserPoly the operation history is set to null.

        @param[in] value The non-negative integer to encode
        @param[out] destination Reference to a ChooserPoly where the output will be stored
        @see IntegerEncoder::encode() for the corresponding function returning a real polynomial.

</member>
        <member name="M:seal.ChooserEncoder.encode(System.UInt64)">
        Encodes a number (represented by std::uint64_t) into a ChooserPoly object. This is done by first
        encoding it with IntegerEncoder and then simply reading the number of coefficients and the maximal
        absolute value of the coefficients in the polynomial. In the returned ChooserPoly the computation
        history is set to null.

        @param[in] value The non-negative integer to encode
        @see IntegerEncoder::encode() for the corresponding function returning a real polynomial.

</member>
        <member name="M:seal.ChooserEncoder.#ctor(System.UInt64)">
        Creates a ChooserEncoder that can be used to create ChooserPoly objects modeling plaintext
        polynomials encoded with IntegerEncoder. The base will default to 2, but any integer at least 2
        can be used.

        @param[in] base The base to be used for encoding (default value is 2)
        @throws std::invalid_argument if base is not an integer and at least 2

</member>
        <member name="T:seal.ChooserEncoder">
    Constructs ChooserPoly objects representing encoded plaintexts. ChooserPoly objects constructed
    in this way have null operation history. They can be further used by ChooserEncryptor,
    or in the functions ChooserEvaluator::multiply_plain(), ChooserEvaluator::add_plain(), 
    ChooserEvaluator::sub_plain() representing plaintext operands. Only the integer encodings
    (those provided by IntegerEncoder) are supported by ChooserEncoder. This class is a part of the
    automatic parameter selection module.

    @see ChooserPoly for the object modeling encrypted/plaintext data for automatic parameter selection.
    @see ChooserEvaluator for manipulating instances of ChooserPoly.
    @see ChooserEncryptor for modeling the behavior of encryption with ChooserPoly objects.
    @see IntegerEncoder for the corresponding encoder for real data.
    @see Simulation for the class that handles the noise budget consumption estimates.

</member>
        <member name="M:seal.ChooserEvaluator.default_noise_max_deviation">
Returns the default value for the maximal deviation of the noise (error) distribution.
An expert user might want to give a modified value as an argument to select_parameters().

</member>
        <member name="M:seal.ChooserEvaluator.default_noise_standard_deviation">
Returns the default value for the standard deviation of the noise (error) distribution. 
An expert user might want to give a modified value as an argument to select_parameters().

</member>
        <member name="M:seal.ChooserEvaluator.select_parameters(std.vector&lt;seal.ChooserPoly,std.allocator&lt;seal.ChooserPoly&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,seal.EncryptionParameters*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Provides the user with optimized encryption parameters that are large enough to support the
        operations performed on all of the given ChooserPoly objects. The function returns true or
        false depending on whether a working parameter set was found or not.

        The budget_gap parameter can be used to ensure that a certain amount of noise budget remains unused.

        @param[in] operands The ChooserPolys for which the parameters are optimized
        @param[in] budget_gap The amount of noise budget (bits) that should remain unused
        @param[out] destination The encryption parameters to overwrite with the selected parameter set
        @throws std::logic_error if operation history of any of the given ChooserPolys is null
        @throws std::invalid_argument if operands is empty
        @throws std::invalid_argument if budget_gap is negative
        @see EncryptionParameters for a description of the encryption parameters.
        @see default_noise_standard_deviation() for the default noise standard deviation.
        @see default_noise_max_deviation() for the default maximal noise deviation.
        @see default_parameter_options() for the default set of parameter options.

</member>
        <member name="M:seal.ChooserEvaluator.negate(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::negate() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to negate
        @throws std::invalid_argument if operand is not correctly initialized
        @see Evaluator::negate() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::negate() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.exponentiate(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64)">
        Performs an operation modeling Evaluator::exponentiate() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to raise to a power
        @param[in] exponent The power to raise the ChooserPoly object to
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if exponent is zero
        @see Evaluator::exponentiate() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::exponentiate() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.sub_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::sub_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        This variant of the function takes the plaintext to subtract as input in the form of another ChooserPoly.
        If the plaintext to be subtracted is already known at the time of performing the automatic parameter selection,
        one can use ChooserEncoder to construct the appropriate ChooserPoly for plain_chooser_poly. This function
        completely ignores the operation history possibly carried by plain_chooser_poly.

        @param[in] operand The ChooserPoly object to subtract from
        @param[in] plain_chooser_poly The plaintext polynomial to subtract represented by a ChooserPoly
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_chooser_poly is not correctly initialized
        @throws std::invalid_argument if plain_chooser_poly has a non-positive bound on the number of non-zero coefficients
        @see Evaluator::sub_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator:sub_plain() for the corresponding operation on Simulation objects.
        @see ChooserEncoder for constructing the ChooserPoly for the plaintext to subtract.

</member>
        <member name="M:seal.ChooserEvaluator.sub_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.UInt64)">
        Performs an operation modeling Evaluator::sub_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to subtract from
        @param[in] plain_max_coeff_count Bound on the number of non-zero coefficients in the plaintext polynomial to subtract
        @param[in] plain_max_abs_value Bound on the absolute value of coefficients of the plaintext polynomial to subtract
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_max_coeff_count is not positive
        @see Evaluator::sub_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::sub_plain() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.sub_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::sub_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to subtract from
        @param[in] plain_max_coeff_count Bound on the number of non-zero coefficients in the plaintext polynomial to subtract
        @param[in] plain_max_abs_value Bound on the absolute value of coefficients of the plaintext polynomial to subtract
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_max_coeff_count is not positive
        @see Evaluator::sub_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::sub_plain() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.add_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::add_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        This variant of the function takes the plaintext to add as input in the form of another ChooserPoly.
        If the plaintext to be added is already known at the time of performing the automatic parameter selection,
        one can use ChooserEncoder to construct the appropriate ChooserPoly for plain_chooser_poly. This function
        completely ignores the operation history possibly carried by plain_chooser_poly.

        @param[in] operand The ChooserPoly object to add
        @param[in] plain_chooser_poly The plaintext polynomial to add represented by a ChooserPoly
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_chooser_poly is not correctly initialized
        @throws std::invalid_argument if plain_chooser_poly has a non-positive bound on the number of non-zero coefficients
        @see Evaluator::add_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::add_plain() for the corresponding operation on Simulation objects.
        @see ChooserEncoder for constructing the ChooserPoly for the plaintext to add.

</member>
        <member name="M:seal.ChooserEvaluator.add_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.UInt64)">
        Performs an operation modeling Evaluator::add_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to add
        @param[in] plain_max_coeff_count Bound on the number of non-zero coefficients in the plaintext polynomial to add
        @param[in] plain_max_abs_value Bound on the absolute value of coefficients of the plaintext polynomial to add
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_max_coeff_count is not positive
        @see Evaluator::add_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::add_plain() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.add_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::add_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to add
        @param[in] plain_max_coeff_count Bound on the number of non-zero coefficients in the plaintext polynomial to add
        @param[in] plain_max_abs_value Bound on the absolute value of coefficients of the plaintext polynomial to add
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_max_coeff_count is not positive
        @see Evaluator::add_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::add_plain() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.multiply_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::multiply_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        This variant of the function takes the plaintext multiplier as input in the form of another ChooserPoly.
        If the plaintext multiplier is already known at the time of performing the automatic parameter selection,
        one can use ChooserEncoder to construct the appropriate ChooserPoly for plain_chooser_poly. This function
        completely ignores the operation history possibly carried by plain_chooser_poly.

        @param[in] operand The ChooserPoly object to multiply
        @param[in] plain_chooser_poly The plaintext polynomial to multiply represented by a ChooserPoly
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_chooser_poly is not correctly initialized
        @throws std::invalid_argument if plain_chooser_poly models a zero plaintext
        @see Evaluator::multiply_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::multiply_plain() for the corresponding operation on Simulation objects.
        @see ChooserEncoder for constructing a ChooserPoly representing the plaintext multiplier.

</member>
        <member name="M:seal.ChooserEvaluator.multiply_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.UInt64)">
        Performs an operation modeling Evaluator::multiply_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to multiply
        @param[in] plain_max_coeff_count Bound on the number of non-zero coefficients in the plaintext polynomial to multiply
        @param[in] plain_max_abs_value Bound on the absolute value of coefficients of the plaintext polynomial to multiply
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_max_coeff_count is not positive
        @throws std::invalid_argument if plain_max_abs_value is zero
        @see Evaluator::multiply_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::multiply_plain() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.multiply_plain(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::multiply_plain() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to multiply
        @param[in] plain_max_coeff_count Bound on the number of non-zero coefficients in the plaintext polynomial to multiply
        @param[in] plain_max_abs_value Bound on the absolute value of coefficients of the plaintext polynomial to multiply
        @throws std::invalid_argument if operand is not correctly initialized
        @throws std::invalid_argument if plain_max_coeff_count is not positive
        @throws std::invalid_argument if plain_max_abs_value is zero
        @see Evaluator::multiply_plain() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::multiply_plain() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.relinearize(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
        Performs an operation modeling Evaluator::relinearize() on ChooserPoly objects. This operation
        creates a new ChooserPoly with the same bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients as the input, but sets the operation history
        to include the relinearization operation.

        The parameter destination_size is not verified for correctness in this function. Instead,
        if an impossible value is given, simulating the noise growth in the returned ChooserPoly
        will throw an exception.

        @param[in] operand The ChooserPoly object to relinearize
        @param[in] destination_size The size of the output ciphertext that is being modeled (defaults to 2)
        @throws std::invalid_argument if operand is not correctly initialized
        @see Evaluator::relinearize() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::relinearize() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.square(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::square() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand The ChooserPoly object to square
        @throws std::invalid_argument if operand is not correctly initialized
        @see Evaluator::square() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::square() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.multiply(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::multiply() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand1 The first ChooserPoly object to multiply
        @param[in] operand2 The second ChooserPoly object to multiply
        @throws std::invalid_argument if either operand1 or operand2 is not correctly initialized
        @see Evaluator::multiply() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::multiply() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.sub(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::sub() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand1 The ChooserPoly object to subtract from
        @param[in] operand2 The ChooserPoly object to subtract
        @throws std::invalid_argument if either operand1 or operand2 is not correctly initialized
        @see Evaluator::sub() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::sub() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.add_many(std.vector&lt;seal.ChooserPoly,std.allocator&lt;seal.ChooserPoly&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::add_many() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operands The ChooserPoly object to add
        @throws std::invalid_argument if any of the elements of operands is not correctly initialized
        @see Evaluator::add_many() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::add_many() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.add(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::add() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operand1 The first ChooserPoly object to add
        @param[in] operand2 The second ChooserPoly object to add
        @throws std::invalid_argument if either operand1 or operand2 is not correctly initialized
        @see Evaluator::add() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::add() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.multiply_many(std.vector&lt;seal.ChooserPoly,std.allocator&lt;seal.ChooserPoly&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs an operation modeling Evaluator::multiply_many() on ChooserPoly objects. This operation
        creates a new ChooserPoly with updated bounds on the degree of the corresponding plaintext polynomial
        and on the absolute values of  the coefficients based on the inputs, and sets the operation history
        accordingly.

        @param[in] operands The vector of ChooserPoly objects to multiply
        @throws std::invalid_argument if operands vector is empty
        @throws std::invalid_argument if any of the ChooserPoly objects in operands vector is not correctly initialized
        @see Evaluator::multiply_many() for the corresponding operation on ciphertexts.
        @see SimulationEvaluator::multiply_many() for the corresponding operation on Simulation objects.

</member>
        <member name="M:seal.ChooserEvaluator.#ctor(seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Creates a ChooserEvaluator.

</member>
        <member name="T:seal.ChooserEvaluator">
    Models arithmetic operations on ChooserPoly objects rather than performing them on real data.
    The class ChooserEvaluator has a public API similar to that of Evaluator,
    making it easy for the user to run existing code on ChooserPoly objects rather than on actual data.
    All of these operations take as input a varying number of ChooserPoly objects and return a new one
    with an appropriately extended operation history. This class is a part of the automatic parameter
    selection module.

    @par Invariant Noise Budget
    The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
    a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
    of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
    the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
    invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
    starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
    computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
    correctly.

    @see ChooserPoly for the object modeling encrypted/plaintext data for automatic parameter selection.
    @see ChooserEncoder for modeling the behavior of encoding with ChooserPoly objects.
    @see ChooserEncryptor for modeling the behavior of encryption with ChooserPoly objects.
    @see Simulation for the class that handles the noise budget consumption estimates.

</member>
        <member name="M:seal.ChooserPoly.set_fresh">
        Sets the operation history to that of a freshly encrypted ciphertext. This function leaves the bounds on
        the degree and the absolute value of the coefficients of the modeled plaintext polynomial unchanged.

        @see max_coeff_count() to set the bound on the degree of the modeled plaintext polynomial.
        @see max_abs_value() to set the bound on the absolute value of coefficients of the modeled plaintext polynomial.

</member>
        <member name="M:seal.ChooserPoly.reset">
        Sets the bounds on the degree and the absolute value of the coefficients of the modeled plaintext
        polynomial to zero, and sets the operation history to null.

        @warning A null operation history is not the same as that of a freshly encrypted ciphertext.
        @see set_fresh() for setting the operation history to that of a freshly encrypted ciphertext.

</member>
        <member name="M:seal.ChooserPoly.simulate(seal.EncryptionParameters*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in the operation history of the current instance of ChooserPoly.
        The return value is a Simulation object.

        @param[in] parms The encryption parameters
        @throws std::logic_error if operation history is null, i.e. the current ChooserPoly models a plaintext polynomial
        @throws std::invalid_argument if encryption parameters are not valid
        @see EncryptionParameters for more details on valid encryption parameters.
        @see Simulation for the class that handles the noise budget consumption estimates.

</member>
        <member name="M:seal.ChooserPoly.test_parameters(seal.EncryptionParameters*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
        Determines whether given encryption parameters are large enough to support operations in
        the operation history of the current ChooserPoly. A ChooserPoly produced as a result of some
        number of arithmetic operations (with ChooserEvaluator) contains information about
        bounds on the number of non-zero coefficients in a corresponding plaintext polynomial and on the
        absolute values of the coefficients. For decryption to work correctly, these bounds must be
        small enough to be supported by the encryption parameters. Additionally, the encryption parameters
        must be large enough to provide enough invariant noise budget for the performed operations.

        The budget_gap parameter can be used to ensure that a certain amount of noise budget remains unused.
        
        The return value is true or false depending on whether given encryption parameters are large enough
        to support the operations in the operation history of the current ChooserPoly.

        @param[in] parms The encryption parameters
        @param[in] budget_gap The amount of noise budget (bits) that should remain unused
        @throws std::logic_error if the current operation history is null, i.e. the current ChooserPoly models a plaintext polynomial
        @throws std::invalid_argument if encryption parameters are not valid
        @throws std::invalid_argument if budget_gap is negative
        @see EncryptionParameters for more details on valid encryption parameters.
        @see Simulation for the class that handles the noise budget consumption estimates.

</member>
        <member name="M:seal.ChooserPoly.max_abs_value">
Returns a reference to the upper bound on the absolute value of coefficients (represented by BigUInt) 
of the plaintext modeled by the current instance of ChooserPoly.


Returns a reference to the upper bound on the absolute value of coefficients (represented by BigUInt)
of the plaintext modeled by the current instance of ChooserPoly.

</member>
        <member name="M:seal.ChooserPoly.max_coeff_count">
Returns the upper bound on the number of non-zero coefficients in the plaintext modeled by the current instance
of ChooserPoly.


Returns a reference to the upper bound on the number of non-zero coefficients in the plaintext modeled
by the current instance of ChooserPoly.

</member>
        <member name="M:seal.ChooserPoly.op_Assign(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Overwrites the ChooserPoly with the value of the specified ChooserPoly. This includes creating
        a deep copy of the operation history or the original one.

        @param[in] assign The ChooserPoly whose value should be assigned to the current ChooserPoly

</member>
        <member name="M:seal.ChooserPoly.#ctor(seal.ChooserPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a deep copy of a ChooserPoly. The created ChooserPoly will model plaintext data with same
        size bounds as the original one, and contains a clone of the original operation history.

        @param[in] copy The ChooserPoly to copy from

</member>
        <member name="M:seal.ChooserPoly.Dispose">
Destroys the ChooserPoly, and deallocates all memory associated with it.

</member>
        <member name="M:seal.ChooserPoly.#ctor(System.Int32,System.UInt64)">
        Creates a ChooserPoly object. The ChooserPoly instance models plaintext data with a given bound on
        the number of non-zero coefficients, and a given bound on the size of the absolute value of the
        coefficients (represented by std::uint64_t). This constructor sets the operation history to that of
        a freshly encrypted ciphertext.

        @param[in] max_coeff_count An upper bound on the number of non-zero coefficients in the modeled plaintext data
        @param[in] max_abs_value An upper bound on the absolute value of the coefficients in the modeled plaintext data
        @throws std::invalid_argument if max_coeff_count is less than or equal to zero

</member>
        <member name="M:seal.ChooserPoly.#ctor(System.Int32,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a ChooserPoly object. The ChooserPoly instance models plaintext data with a given bound on
        the number of non-zero coefficients, and a given bound on the size of the absolute value of the
        coefficients (represented by BigUInt). This constructor sets the operation history to that of
        a freshly encrypted ciphertext.

        @param[in] max_coeff_count An upper bound on the number of non-zero coefficients in the modeled plaintext data
        @param[in] max_abs_value An upper bound on the absolute value of the coefficients in the modeled plaintext data
        @throws std::invalid_argument if max_coeff_count is less than or equal to zero

</member>
        <member name="M:seal.ChooserPoly.#ctor">
Creates a ChooserPoly object. The ChooserPoly instance models a plaintext with no non-zero coefficients.
More precisely, the number of non-zero coefficients, and the upper bound on the absolute values of the
coefficients of the modeled plaintext polynomial are both set to zero. The operation history is set to null,
which indicates that the ChooserPoly object does not represent a ciphertext but only a plaintext.

</member>
        <member name="T:seal.ChooserPoly">
    Models ciphertexts for the automatic parameter selection module. Choosing appropriate and secure
    parameters for homomorphic cryptosystems is difficult, and beyond what a non-expert user should have
    to worry about. The user programs their computations as they normally would, but replace plaintexts with
    ChooserPoly objects. When the program is executed, ChooserPoly objects store the computation as a directed
    acyclic graph, and can later be used to estimate the invariant noise budget consumption in the stored 
    computation. The estimated noise budget in the output ciphertext is given by the simulate() function. 
    This class is a part of the automatic parameter selection module.

    Each instance of ChooserPoly stores an estimate of the number of non-zero coefficients, and an estimate
    for their largest absolute value (represented by BigUInt) that a plaintext polynomial can be expected to
    contain after some number of homomorphic operations have been performed on it. In addition, each ChooserPoly
    stores a directed acyclic graph of computations that it has gone through (operation history).

    Instances of ChooserPoly can be manipulated using an instance of ChooserEvaluator, which has a public API
    similar to Evaluator, making existing code easy to run on ChooserPoly objects instead of running it on
    actual encrypted data. In other words, using ChooserEvaluator, ChooserPoly objects can be added, multiplied,
    subtracted, negated, etc., and the result is always a new ChooserPoly object whose estimated noise budget
    can be obtained using the simulate() function, which uses heuristic worst-case analysis of the noise 
    behavior in the encryption scheme. 

    @par Invariant Noise Budget
    The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
    a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
    of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
    the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
    invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
    starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
    computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
    correctly.

    @par Thread Safety
    In general, reading a ChooserPoly is thread-safe while mutating is not. Specifically, concurrent access must
    be avoided if the size bounds of the modeled plaintext data, or the operation history are expected to be changed.

    @see ChooserEvaluator for manipulating instances of ChooserPoly.
    @see ChooserEncoder for modeling the behavior of encoding with ChooserPoly objects.
    @see ChooserEncryptor for modeling the behavior of encryption with ChooserPoly objects.
    @see Simulation for the class that handles the noise budget consumption estimates.

</member>
        <member name="M:Microsoft.Research.SEAL.Encryptor.GetEncryptor">
            <summary>Returns a reference to the underlying C++ Encryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Encryptor.Finalize">
            <summary>Destroys the Encryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Encryptor.Dispose">
            <summary>Destroys the Encryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Encryptor.Encrypt(Microsoft.Research.SEAL.BigPoly)">
            <summary>Encrypts a plaintext and returns the result.</summary>
            <remarks>
                Encrypts a plaintext and returns the result. The destination parameter is
                resized if and only if its coefficient count or coefficient bit count does not match the encryption parameters. The
                plaintext polynomial must have a significant coefficient count smaller than the coefficient count specified by the
                encryption parameters, and with coefficient values less-than the plaintext modulus
                (<see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />).
                </remarks>
            <param name="plain">The plaintext to encrypt</param>
            <exception cref="T:System.ArgumentNullException">if plain is null</exception>
            <exception cref="T:System.ArgumentException">if the plaintext polynomial's significant coefficient count or coefficient
                values are too large to represent with the encryption parameters</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on plaintext limits for encryption
                parameters.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Encryptor.Encrypt(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Encrypts a plaintext and stores the result in the destination parameter.</summary>
            <remarks>
                Encrypts a plaintext and stores the result in the destination parameter. The destination parameter is
                resized if and only if its coefficient count or coefficient bit count does not match the encryption parameters. The
                plaintext polynomial must have a significant coefficient count smaller than the coefficient count specified by the
                encryption parameters, and with coefficient values less-than the plaintext modulus
                (<see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />).
                </remarks>
            <param name="plain">The plaintext to encrypt</param>
            <param name="destination">The ciphertext to overwrite with the encrypted plaintext</param>
            <exception cref="T:System.ArgumentNullException">if plain or destination is null</exception>
            <exception cref="T:System.ArgumentException">if the plaintext polynomial's significant coefficient count or coefficient
                values are too large to represent with the encryption parameters</exception>
            <exception cref="T:System.InvalidOperationException">If destination is an alias but needs to be resized</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on plain text limits for encryption
                parameters.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.Encryptor.PublicKey">
            <summary>Returns the public key used by the Encryptor.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Encryptor.#ctor(Microsoft.Research.SEAL.Encryptor)">
            <summary>Creates a copy of a Encryptor.</summary>
            <param name="copy">The Encryptor to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Encryptor.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a Encryptor instances initialized with the specified encryption parameters and public key.</summary>
            <remarks>
                Creates a Encryptor instances initialized with the specified encryption parameters and public key.
                The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool instead
                of the global memory pool (default).
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="publicKey">The public key</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if parms, publicKey, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters or public key are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
                parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Encryptor.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Creates a Encryptor instances initialized with the specified encryption parameters and public key.</summary>
            <param name="parms">The encryption parameters</param>
            <param name="publicKey">The public key</param>
            <exception cref="T:System.ArgumentNullException">if parms or publicKey is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters or public key are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
parameters.</seealso>
        </member>
        <member name="T:Microsoft.Research.SEAL.Encryptor">
            <summary>Encrypts BigPoly objects into BigPolyArray objects.</summary>
            <remarks>
                <para>
            Encrypts BigPoly objects into BigPolyArray objects. Constructing an Encryptor requires the encryption parameters 
            (set through an <see cref="T:Microsoft.Research.SEAL.EncryptionParameters" /> object) and an BigPolyArray. The secret and evaluation keys are not 
            needed for encryption.
            </para>
            </remarks>
        </member>
        <member name="M:seal.Encryptor.public_key">
Returns the public key used by the Encryptor.

</member>
        <member name="M:seal.Encryptor.encrypt(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encrypts a plaintext and returns the result. The destination parameter is resized if
        and only if its coefficient count or coefficient bit count does not match the encryption parameters. The plaintext polynomial
        must have a significant coefficient count smaller than the coefficient count specified by the encryption parameters, and with
        coefficient values less-than the plain modulus (EncryptionParameters::plain_modulus()).

        @warning encrypt() is not thread safe.
        @param[in] plain The plaintext to encrypt
        @throws std::invalid_argument if the plaintext polynomial's significant coefficient count or coefficient values are too large to
        represent with the encryption parameters
        @see EncryptionParameters for more details on plaintext limits for encryption parameters.

</member>
        <member name="M:seal.Encryptor.encrypt(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new Encryptor by moving an old one.

        @param[in] source The Encryptor to move from

        Encrypts a plaintext and stores the result in the destination parameter. The destination parameter is resized if
        and only if its coefficient count or coefficient bit count does not match the encryption parameters. The plaintext polynomial
        must have a significant coefficient count smaller than the coefficient count specified by the encryption parameters, and with
        coefficient values less-than the plain modulus (EncryptionParameters::plain_modulus()).

        @param[in] plain The plaintext to encrypt
        @param[out] destination The ciphertext to overwrite with the encrypted plaintext
        @throws std::invalid_argument if the plaintext polynomial's significant coefficient count or coefficient values are too large to
        represent with the encryption parameters
        @throws std::logic_error If destination is an alias but needs to be resized
        @see EncryptionParameters for more details on plain text limits for encryption parameters.

</member>
        <member name="M:seal.Encryptor.#ctor(seal.Encryptor!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a copy of a Encryptor.

        @param[in] copy The Encryptor to copy from

</member>
        <member name="M:seal.Encryptor.#ctor(seal.EncryptionParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates an Encryptor instances initialized with the specified encryption parameters and public key.
        Optionally, the user can give a reference to a MemoryPoolHandle object to use a custom memory pool
        instead of the global memory pool (default).

        @param[in] parms The encryption parameters
        @param[in] public_key The public key
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if encryption parameters or public key are not valid
        @see EncryptionParameters for more details on valid encryption parameters.
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.Encryptor">
Encrypts BigPoly objects into BigPolyArray objects.
Constructing an Encryptor requires the encryption parameters (set through an EncryptionParameters object) and
an BigPolyArray. The secret and evaluation keys are not needed for encryption.

</member>
        <member name="M:Microsoft.Research.SEAL.Utilities.PolyEvalUIntMod(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Evaluates a given polynomial at an unsigned integer modulo a given modulus and returns the result.</summary>
            <remarks>
                Evaluates a given polynomial at an unsigned integer modulo a given modulus and returns the result.
                The coefficients of polyToEvaluate and the value to evaluate at are expected to be already reduced modulo the
                modulus.
                </remarks>
            <param name="polyToEvaluate">The polynomial to be evaluated</param>
            <param name="value">The unsigned integer at which the polynomial is evaluated</param>
            <param name="modulus">The modulus</param>
            <exception cref="T:System.ArgumentNullException">if polyToEvaluate, value, or modulus is null</exception>
            <exception cref="T:System.ArgumentException">if the coefficients of polyToEvaluate are not reduced modulo
                modulus</exception>
            <exception cref="T:System.ArgumentException">if value is not reduced modulo modulus</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.PolyEvalUIntMod(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Evaluates a given polynomial at an unsigned integer modulo a given modulus and stores the result 
                in a given BigUInt.</summary>
            <remarks>
                Evaluates a given polynomial at an unsigned integer modulo a given modulus and stores the result in a given <see cref="T:Microsoft.Research.SEAL.BigUInt" />.
                The coefficients of polyToEvaluate and the value to evaluate at are expected to be already reduced modulo the
                modulus.
                </remarks>
            <param name="polyToEvaluate">The polynomial to be evaluated</param>
            <param name="value">The unsigned integer at which the polynomial is evaluated</param>
            <param name="modulus">The modulus</param>
            <param name="destination">The unsigned integer to overwrite with the result</param>
            <exception cref="T:System.ArgumentNullException">if polyToEvaluate, value, modulus, or destination is null</exception>
            <exception cref="T:System.ArgumentException">if the coefficients of polyToEvaluate are not reduced modulo
                modulus</exception>
            <exception cref="T:System.ArgumentException">if value is not reduced modulo modulus</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.PolyEvalPolyPolymodCoeffmod(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Evaluates a given polynomial at another given polynomial modulo a polynomial and a coefficient 
                modulus and returns the result.</summary>
            <remarks>
                Evaluates a given polynomial at another given polynomial modulo a polynomial and a coefficient modulus and
                returns the result. The inputs are expected to be already reduced both modulo the polynomial and the
                coefficient modulus.
                </remarks>
            <param name="polyToEvaluate">The polynomial to be evaluated</param>
            <param name="polyToEvaluateAt">The polynomial polyToEvaluate will be evaluated by replacing its variable with this
                polynomial</param>
            <param name="polyModulus">The polynomial modulus</param>
            <param name="coeffModulus">The coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">if polyToEvaluate, polyToEvaluateAt, polyModulus, or coeffModulus is null</exception>
            <exception cref="T:System.ArgumentException">if polyToEvaluate is not reduced modulo polyModulus and
                coeffModulus</exception>
            <exception cref="T:System.ArgumentException">if polyToEvaluateAt is not reduced modulo polyModulus and
                coeffModulus</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.PolyEvalPolyPolymodCoeffmod(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Evaluates a given polynomial at another given polynomial modulo a polynomial and a coefficient modulus and
                stores the result in a given BigPoly.</summary>
            <remarks>
                Evaluates a given polynomial at another given polynomial modulo a polynomial and a coefficient modulus and stores the
                result in a given <see cref="T:Microsoft.Research.SEAL.BigPoly" />. The inputs are expected to be already reduced both modulo the polynomial and the
                coefficient modulus.
                </remarks>
            <param name="polyToEvaluate">The polynomial to be evaluated</param>
            <param name="polyToEvaluateAt">The polynomial polyToEvaluate will be evaluated by replacing its variable with this
                polynomial</param>
            <param name="polyModulus">The polynomial modulus</param>
            <param name="coeffModulus">The coefficient modulus</param>
            <param name="destination">The polynomial to overwrite with the result</param>
            <exception cref="T:System.ArgumentNullException">if polyToEvaluate, polyToEvaluateAt, polyModulus, coeffModulus, or destination is null</exception>
            <exception cref="T:System.ArgumentException">if polyToEvaluate is not reduced modulo polyModulus and
                coeffModulus</exception>
            <exception cref="T:System.ArgumentException">if polyToEvaluateAt is not reduced modulo polyModulus and
                coeffModulus</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.PolyEvalPoly(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Evaluates a given polynomial at another given polynomial and returns the result.</summary>
            <param name="polyToEvaluate">The polynomial to be evaluated</param>
            <param name="polyToEvaluateAt">The polynomial polyToEvaluate will be evaluated by replacing its variable with this
polynomial</param>
            <exception cref="T:System.ArgumentNullException">if polyToEvaluate, or polyToEvaluateAt is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.PolyEvalPoly(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPoly)">
            <summary>Evaluates a given polynomial at another given polynomial and stores the result in a given BigPoly.</summary>
            <param name="polyToEvaluate">The polynomial to be evaluated</param>
            <param name="polyToEvaluateAt">The polynomial polyToEvaluate will be evaluated by replacing its variable with this
polynomial</param>
            <param name="destination">The polynomial to overwrite with the result</param>
            <exception cref="T:System.ArgumentNullException">if polyToEvaluate, polyToEvaluateAt, or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.ExponentiatePolyPolymodCoeffmod(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Raises a polynomial (represented by BigPoly) to an unsigned integer power (represented by BigUInt) modulo a
                polynomial and a coefficient modulus, and returns the result.</summary>
            <remarks>
                Raises a polynomial (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />) to an unsigned integer power (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)
                modulo a polynomial and a coefficient modulus, and returns the result. The input is expected to be already reduced both 
                modulo the polynomial and the coefficient modulus.
                </remarks>
            <param name="operand">The polynomial to exponentiate</param>
            <param name="exponent">The unsigned integer exponent</param>
            <param name="polyModulus">The polynomial modulus</param>
            <param name="coeffModulus">The coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">if operand, exponent, polyModulus, or coeffModulus is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not reduced modulo polyModulus and coeffModulus</exception>
            <exception cref="T:System.ArgumentException">if exponent is negative</exception>
            <exception cref="T:System.ArgumentException">if both operand and exponent are zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.ExponentiatePolyPolymodCoeffmod(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Raises a polynomial (represented by BigPoly) to an unsigned integer power (represented by BigUInt) modulo a
                polynomial and a coefficient modulus, and stores the result in a given BigPoly.</summary>
            <remarks>
                Raises a polynomial (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />) to an unsigned integer power (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) 
                modulo a polynomial and a coefficient modulus, and stores the result in a given <see cref="T:Microsoft.Research.SEAL.BigPoly" />. The input is expected 
                to be already reduced both modulo the polynomial and the coefficient modulus.
                </remarks>
            <param name="operand">The polynomial to exponentiate</param>
            <param name="exponent">The unsigned integer exponent</param>
            <param name="polyModulus">The polynomial modulus</param>
            <param name="coeffModulus">The coefficient modulus</param>
            <param name="destination">The polynomial to overwrite with the result</param>
            <exception cref="T:System.ArgumentNullException">if operand, exponent, polyModulus, coeffModulus, or destination is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not reduced modulo polyModulus and coeffModulus</exception>
            <exception cref="T:System.ArgumentException">if exponent is negative</exception>
            <exception cref="T:System.ArgumentException">if both operand and exponent are zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.ExponentiateUIntMod(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Raises an unsigned integer (represented by BigUInt) to an unsigned integer power (represented by BigUInt)
                modulo a given modulus and returns the result.</summary>
            <remarks>
                Raises an unsigned integer (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) to an unsigned integer power (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)
                modulo a given modulus and returns the result. The input is expected to be already reduced modulo
                the modulus.
                </remarks>
            <param name="operand">The unsigned integer to exponentiate</param>
            <param name="exponent">The unsigned integer exponent</param>
            <param name="modulus">The modulus</param>
            <exception cref="T:System.ArgumentNullException">if operand, exponent, or modulus is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not reduced modulo modulus</exception>
            <exception cref="T:System.ArgumentException">if both operand and exponent are zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.ExponentiateUIntMod(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Raises an unsigned integer (represented by BigUInt) to an unsigned integer power (represented by BigUInt)
                modulo a given modulus and stores the result in a given BigUInt.</summary>
            <remarks>
                Raises an unsigned integer (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) to an unsigned integer power (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)
                modulo a given modulus and stores the result in a given <see cref="T:Microsoft.Research.SEAL.BigUInt" />. The input is expected to be already reduced modulo
                the modulus.
                </remarks>
            <param name="operand">The unsigned integer to exponentiate</param>
            <param name="exponent">The unsigned integer exponent</param>
            <param name="modulus">The modulus</param>
            <param name="destination">The unsigned integer to overwrite with the result</param>
            <exception cref="T:System.ArgumentNullException">if operand, exponent, modulus, or destination is null</exception>
            <exception cref="T:System.ArgumentException">if operand is not reduced modulo modulus</exception>
            <exception cref="T:System.ArgumentException">if both operand and exponent are zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.PolyInftyNormCoeffmod(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Computes the infinity-norm of a given polynomial (represented by BigPoly).</summary>
            <remarks>
Computes the infinity-norm of a given polynomial (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />). The coefficients of the polynomial are
interpreted as integers modulo a given modulus. For each coefficient in the given polynomial, this function first
finds a representative in the symmetric interval around zero, then computes its absolute value, and finally outputs
the largest of them all.
</remarks>
            <param name="poly">The polynomial whose infinity-norm is to be computed</param>
            <param name="modulus">The modulus used in the computation</param>
            <exception cref="T:System.ArgumentException">if poly or modulus is zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Utilities.PolyInftyNorm(Microsoft.Research.SEAL.BigPoly)">
            <summary>Computes the infinity-norm of a given polynomial with non-negative coefficients (represented by
<see cref="T:Microsoft.Research.SEAL.BigPoly" />).</summary>
            <param name="poly">The polynomial whose infinity-norm is to be computed</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
        </member>
        <member name="M:seal.poly_eval_uint_mod(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Evaluates a given polynomial at an unsigned integer modulo a given modulus and returns the result.
    The coefficients of poly_to_evaluate and the value to evaluate at are expected to be already reduced modulo the modulus.

    @param[in] poly_to_evaluate The polynomial to be evaluated
    @param[in] value The unsigned integer at which the polynomial is evaluated
    @param[in] modulus The modulus
    @throws std::invalid_argument if the coefficients of poly_to_evaluate are not reduced modulo modulus
    @throws std::invalid_argument if value is not reduced modulo modulus

</member>
        <member name="M:seal.poly_eval_uint_mod(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Evaluates a given polynomial at an unsigned integer modulo a given modulus and stores the result in a given BigUInt.
    The coefficients of poly_to_evaluate and the value to evaluate at are expected to be already reduced modulo the modulus.

    @param[in] poly_to_evaluate The polynomial to be evaluated
    @param[in] value The unsigned integer at which the polynomial is evaluated
    @param[in] modulus The modulus
    @param[out] destination The unsigned integer to overwrite with the result
    @throws std::invalid_argument if the coefficients of poly_to_evaluate are not reduced modulo modulus
    @throws std::invalid_argument if value is not reduced modulo modulus

</member>
        <member name="M:seal.poly_eval_poly_polymod_coeffmod(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Evaluates a given polynomial at another given polynomial modulo a polynomial and a coefficient modulus
    and returns the result. The inputs are expected to be already reduced both modulo the polynomial and the coefficient modulus.

    @param[in] poly_to_evaluate The polynomial to be evaluated
    @param[in] poly_to_evaluate_at The polynomial poly_to_evaluate will be evaluated by replacing its variable with this polynomial
    @param[in] poly_modulus The polynomial modulus
    @param[in] coeff_modulus The coefficient modulus
    @throws std::invalid_argument if poly_to_evaluate is not reduced modulo poly_modulus and coeff_modulus
    @throws std::invalid_argument if poly_to_evaluate_at is not reduced modulo poly_modulus and coeff_modulus

</member>
        <member name="M:seal.poly_eval_poly_polymod_coeffmod(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Evaluates a given polynomial at another given polynomial modulo a polynomial and a coefficient modulus
    and stores the result in a given BigPoly. The inputs are expected to be already reduced both modulo 
    the polynomial and the coefficient modulus.

    @param[in] poly_to_evaluate The polynomial to be evaluated
    @param[in] poly_to_evaluate_at The polynomial poly_to_evaluate will be evaluated by replacing its variable with this polynomial
    @param[in] poly_modulus The polynomial modulus
    @param[in] coeff_modulus The coefficient modulus
    @param[out] destination The polynomial to overwrite with the result
    @throws std::invalid_argument if poly_to_evaluate is not reduced modulo poly_modulus and coeff_modulus
    @throws std::invalid_argument if poly_to_evaluate_at is not reduced modulo poly_modulus and coeff_modulus

</member>
        <member name="M:seal.poly_eval_poly(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Evaluates a given polynomial at another given polynomial and returns the result.

    @param[in] poly_to_evaluate The polynomial to be evaluated
    @param[in] poly_to_evaluate_at The polynomial poly_to_evaluate will be evaluated by replacing its variable with this polynomial

</member>
        <member name="M:seal.poly_eval_poly(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Evaluates a given polynomial at another given polynomial and stores the result in a given BigPoly.

    @param[in] poly_to_evaluate The polynomial to be evaluated
    @param[in] poly_to_evaluate_at The polynomial poly_to_evaluate will be evaluated by replacing its variable with this polynomial
    @param[out] destination The polynomial to overwrite with the result

</member>
        <member name="M:seal.exponentiate_poly_polymod_coeffmod(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Raises a polynomial (represented by BigPoly) to an unsigned integer power (represented by BigUInt) 
    modulo a polynomial and a coefficient modulus, and returns the result. The input is expected to be 
    already reduced both modulo the polynomial and the coefficient modulus.

    @param[in] operand The polynomial to exponentiate
    @param[in] exponent The unsigned integer exponent
    @param[in] poly_modulus The polynomial modulus
    @param[in] coeff_modulus The coefficient modulus
    @throws std::invalid_argument if operand is not reduced modulo poly_modulus and coeff_modulus
    @throws std::invalid_argument if exponent is negative
    @throws std::invalid_argument if both operand and exponent are zero

</member>
        <member name="M:seal.exponentiate_poly_polymod_coeffmod(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Raises a polynomial (represented by BigPoly) to an unsigned integer power (represented by BigUInt) modulo 
    a polynomial and a coefficient modulus, and stores the result in a given BigPoly. The input is expected 
    to be already reduced both modulo the polynomial and the coefficient modulus.

    @param[in] operand The polynomial to exponentiate
    @param[in] exponent The unsigned integer exponent
    @param[in] poly_modulus The polynomial modulus
    @param[in] coeff_modulus The coefficient modulus
    @param[out] destination The polynomial to overwrite with the result
    @throws std::invalid_argument if operand is not reduced modulo poly_modulus and coeff_modulus
    @throws std::invalid_argument if exponent is negative
    @throws std::invalid_argument if both operand and exponent are zero

</member>
        <member name="M:seal.exponentiate_uint_mod(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Raises an unsigned integer (represented by BigUInt) to an unsigned integer power
    (represented by BigUInt) modulo a given modulus and returns the result.
    The input is expected to be already reduced modulo the modulus.

    @param[in] operand The unsigned integer to exponentiate
    @param[in] exponent The unsigned integer exponent
    @param[in] modulus The modulus
    @throws std::invalid_argument if operand is not reduced modulo modulus
    @throws std::invalid_argument if both operand and exponent are zero

</member>
        <member name="M:seal.exponentiate_uint_mod(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Raises an unsigned integer (represented by BigUInt) to an unsigned integer power
    (represented by BigUInt) modulo a given modulus and stores the result in a given BigUInt.
    The input is expected to be already reduced modulo the modulus.

    @param[in] operand The unsigned integer to exponentiate
    @param[in] exponent The unsigned integer exponent
    @param[in] modulus The modulus
    @param[out] destination The unsigned integer to overwrite with the result
    @throws std::invalid_argument if operand is not reduced modulo modulus
    @throws std::invalid_argument if both operand and exponent are zero

</member>
        <member name="M:seal.poly_infty_norm_coeffmod(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Computes the infinity-norm of a given polynomial (represented by BigPoly). The coefficients of
    the polynomial are interpreted as integers modulo a given modulus. For each coefficient in the given
    polynomial, this function first finds a representative in the symmetric interval around zero,
    then computes its absolute value, and finally outputs the largest of them all.

    @param[in] poly The polynomial whose infinity-norm is to be computed
    @param[in] modulus The modulus used in the computation
    @throws std::invalid_argument if modulus is zero

</member>
        <member name="M:seal.poly_infty_norm(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
    Computes the infinity-norm of a given polynomial with non-negative coefficients (represented by BigPoly).

    @param[in] poly The polynomial whose infinity-norm is to be computed

</member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.GetGenerator">
            <summary>Returns a reference to the underlying C++ KeyGenerator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.Finalize">
            <summary>Destroys the KeyGenerator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.Dispose">
            <summary>Destroys the KeyGenerator.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.KeyGenerator.EvaluationKeys">
            <summary>Returns the generated evaluation keys after a <see cref="M:Microsoft.Research.SEAL.KeyGenerator.Generate" /> invocation.</summary>
            <exception cref="T:System.InvalidOperationException">if encryption keys have not been generated</exception>
            <exception cref="T:System.InvalidOperationException">if evaluation keys have not been generated</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.KeyGenerator.SecretKey">
            <summary>Returns the generated secret key after a <see cref="M:Microsoft.Research.SEAL.KeyGenerator.Generate" /> invocation.</summary>
            <exception cref="T:System.InvalidOperationException">if encryption keys have not been generated</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.KeyGenerator.PublicKey">
            <summary>Returns the generated public key after a <see cref="M:Microsoft.Research.SEAL.KeyGenerator.Generate" /> invocation.</summary>
            <exception cref="T:System.InvalidOperationException">if encryption keys have not been generated</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.KeyGenerator.Generated">
            <summary>Returns true or false depending on whether secret key and public key have been generated.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.GenerateEvaluationKeys(System.Int32)">
            <summary>Generates evaluation keys so that there are count many in total.</summary>
            <remarks>
                Generates evaluation keys so that there are count many in total. Each key is added as a new entry to the System::List of
                evaluation keys. This function is automatically called by <see cref="M:Microsoft.Research.SEAL.KeyGenerator.Generate" /> to generate evaluation keys, but can
                be later called by the user to increase the number of evaluation keys on top of what has already been generated. 
                An error is thrown if the user tries to generate evaluation keys before a secret key and public key have been generated.
                </remarks>
            <param name="count">The total number of evaluation keys to have been generated.</param>
            <exception cref="T:System.ArgumentException">if count is less than 0</exception>
            <exception cref="T:System.ArgumentException">if evaluation keys cannot be generated for specified encryption
                parameters</exception>
            <exception cref="T:System.InvalidOperationException">if called before the secret key and public key have been generated</exception>
            <seealso cref="P:Microsoft.Research.SEAL.KeyGenerator.EvaluationKeys">See EvaluationKeys to read generated evaluation keys.</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.KeyGenerator.Generated">See Generated to see if the secret and public keys have already been generated.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.Generate(System.Int32)">
            <summary>Generates new matching set of secret key, public key, and any number of evaluation keys.</summary>
            <remarks>
                Generates new matching set of secret key, public key, and any number of evaluation keys. The number of evaluation keys
                that will be generated can be specified by the input parameter evaluationKeysCount.
                </remarks>
            <param name="evaluationKeysCount">The number of evaluation keys to generate</param>
            <exception cref="T:System.ArgumentException">if evaluation keys cannot be generated for specified encryption
                parameters</exception>
            <seealso cref="P:Microsoft.Research.SEAL.KeyGenerator.SecretKey">See SecretKey to read generated secret key</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.KeyGenerator.PublicKey">See PublicKey to read generated public key</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.KeyGenerator.EvaluationKeys">See EvaluationKeys to read generated evaluation keys</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.Generate">
            <summary>Generates new matching set of secret key and public key.</summary>
            <remarks>
Generates new matching set of secret key and public key. This function does not generate any evaluation keys.
</remarks>
            <seealso cref="P:Microsoft.Research.SEAL.KeyGenerator.SecretKey">See SecretKey to read generated secret key</seealso>
            <seealso cref="P:Microsoft.Research.SEAL.KeyGenerator.PublicKey">See PublicKey to read generated public key</seealso>
            <seealso cref="M:Microsoft.Research.SEAL.KeyGenerator.Generate(System.Int32)">See Generate(int) to also create evaluation keys</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.EvaluationKeys,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates an KeyGenerator instance initialized with the specified encryption parameters and specified
                previously generated keys.</summary>
            <remarks>
                <para>
                Creates an KeyGenerator instance initialized with the specified encryption parameters and specified
                previously generated keys. This can be used to increase the number of evaluation keys (using
                <see cref="M:Microsoft.Research.SEAL.KeyGenerator.GenerateEvaluationKeys(System.Int32)" />) from what had earlier been generated. If no evaluation keys
                had been generated earlier, one can simply pass a newly created empty instance of <see cref="P:Microsoft.Research.SEAL.KeyGenerator.EvaluationKeys" />
                to the function. The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool 
                instead of the global memory pool (default).
                </para>
            </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="secretKey">A previously generated secret key</param>
            <param name="publicKey">A previously generated public key</param>
            <param name="evaluationKeys">A previously generated set of evaluation keys</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if parms, secretKey, publicKey, evaluationKeys, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <exception cref="T:System.ArgumentException">if secret, public or evaluation keys are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.EvaluationKeys)">
            <summary>Creates an KeyGenerator instance initialized with the specified encryption parameters and specified
                previously generated keys.</summary>
            <remarks>
                <para>
                Creates an KeyGenerator instance initialized with the specified encryption parameters and specified
                previously generated keys. This can be used to increase the number of evaluation keys (using
                <see cref="M:Microsoft.Research.SEAL.KeyGenerator.GenerateEvaluationKeys(System.Int32)" />) from what had earlier been generated. If no evaluation keys
                had been generated earlier, one can simply pass a newly created empty instance of <see cref="P:Microsoft.Research.SEAL.KeyGenerator.EvaluationKeys" />
                to the function.
                </para>
            </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="secretKey">A previously generated secret key</param>
            <param name="publicKey">A previously generated public key</param>
            <param name="evaluationKeys">A previously generated set of evaluation keys</param>
            <exception cref="T:System.ArgumentNullException">if parms, secretKey, publicKey or evaluationKeys is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <exception cref="T:System.ArgumentException">if secret, public or evaluation keys are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
                parameters.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a KeyGenerator instance initialized with the specified encryption parameters.</summary>
            <remarks>
                Creates a KeyGenerator instance initialized with the specified encryption parameters. The user can 
                give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool instead of the global 
                memory pool (default).
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if parms or pool is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.KeyGenerator.#ctor(Microsoft.Research.SEAL.EncryptionParameters)">
            <summary>Creates a KeyGenerator instance initialized with the specified encryption parameters.</summary>
            <param name="parms">The encryption parameters</param>
            <exception cref="T:System.ArgumentNullException">if parms is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
                parameters.</seealso>
        </member>
        <member name="T:Microsoft.Research.SEAL.KeyGenerator">
            <summary>Generates matching secret key, public key, and evaluation keys for encryption, decryption, and evaluation
            functions.</summary>
            <remarks>
                <para>
            Generates matching secret key, public key, and evaluation keys for encryption, decryption, and evaluation functions.
            Constructing a KeyGenerator requires the encryption parameters (set through an <see cref="T:Microsoft.Research.SEAL.EncryptionParameters" />
            object). Invoking the <see cref="M:Microsoft.Research.SEAL.KeyGenerator.Generate" /> function will generate a new secret key (which can be read from
            <see cref="P:Microsoft.Research.SEAL.KeyGenerator.SecretKey" />), public key (which can be read from <see cref="P:Microsoft.Research.SEAL.KeyGenerator.PublicKey" />), and evaluation keys (which
            can be read from <see cref="P:Microsoft.Research.SEAL.KeyGenerator.EvaluationKeys" />).
            </para>
                <para>
            KeyGenerator is not thread-safe and a separate instance is needed for each potentially concurrent usage.
            </para>
            </remarks>
        </member>
        <member name="M:seal.KeyGenerator.evaluation_keys">
Returns evaluation keys after a generate_evaluation_keys() or generate() invocation.
@throws std::logic_error if encryption keys have not been generated
@throws std::logic_error if evaluation keys have not been generated

</member>
        <member name="M:seal.KeyGenerator.public_key">
Returns the generated public key after a generate() invocation.
@throws std::logic_error if encryption keys have not been generated

</member>
        <member name="M:seal.KeyGenerator.secret_key">
Returns the generated secret key after a generate() invocation.
@throws std::logic_error if encryption keys have not been generated

</member>
        <member name="M:seal.KeyGenerator.is_generated">
Returns true or false depending on whether secret key and public key have been generated.

</member>
        <member name="M:seal.KeyGenerator.generate_evaluation_keys(System.Int32)">
Generates evaluation keys so that there are count many in total. Each key is added as a new entry to the std::vector of evaluation keys. 
This function is automatically called by generate() to generate evaluation keys, but can be later called by the user to increase
the number of evaluation keys on top of what has already been generated. An error is thrown if the user tries to generate evaluation 
keys before a secret key and public key have been generated.

@param[in] count The total number of evaluation keys to have been generated.
@throws std::invalid_argument if count is less than 0
@throws std::invalid_argument if evaluation keys cannot be generated for specified encryption parameters
@throws std::logic_error if called before the secret key and public key have been generated
@see evaluation_keys() to read generated evaluation keys.
@see generated() to see if the secret and public keys have already been generated.

</member>
        <member name="M:seal.KeyGenerator.generate(System.Int32)">
        Generates new matching set of secret key, public key, and any number of evaluation keys.
        The number of evaluation keys that will be generated can be specified by the input
        parameter evaluation_keys_count, which defaults to 0.

        @param[in] count The number of evaluation keys to generate
        @see secret_key() to read generated secret key
        @see public_key() to read generated public key
        @see evaluation_keys() to read generated evaluation keys
        @throws std::invalid_argument if evaluation keys cannot be generated for specified encryption parameters

</member>
        <member name="M:seal.KeyGenerator.#ctor(seal.EncryptionParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.EvaluationKeys*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates an KeyGenerator instance initialized with the specified encryption parameters and specified
        previously generated keys. This can be used to increase the number of evaluation keys (using GenerateEvaluationKeys()) 
        from what had earlier been generated. If no evaluation keys had been generated earlier, one can simply pass a newly 
        created empty instance of EvaluationKeys to the function. Optionally, the user can give a reference to a MemoryPoolHandle 
        object to use a custom memory pool instead of the global memory pool (default).

        @param[in] parms The encryption parameters
        @param[in] secret_key A previously generated secret key
        @param[in] public_key A previously generated public key
        @param[in] evaluation_keys A previously generated set of evaluation keys
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if encryption parameters are not valid
        @throws std::invalid_argument if secret, public or evaluation keys are not valid
        @see EncryptionParameters for more details on valid encryption parameters.
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="M:seal.KeyGenerator.#ctor(seal.EncryptionParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates an KeyGenerator instance initialized with the specified encryption parameters. Optionally, 
        the user can give a reference to a MemoryPoolHandle object to use a custom memory pool instead of 
        the global memory pool (default).

        @param[in] parms The encryption parameters
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if encryption parameters are not valid
        @see EncryptionParameters for more details on valid encryption parameters.
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.KeyGenerator">
Generates matching secret key, public key, and evaluation keys for encryption, decryption, and evaluation functions.

Constructing an KeyGenerator requires the encryption parameters (set through an EncryptionParameters object). Invoking
the generate() function will generate a new secret key (which can be read from secret_key()), public key (which can
be read from public_key()), and evaluation keys (which can be read from evaluation_keys()). 

@warning KeyGenerator is not thread-safe and a separate instance is needed for each potentially concurrent usage.

</member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.GetPlaintext">
            <summary>Returns a reference to the underlying C++ Plaintext.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.#ctor(seal.Plaintext!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of a C++ Plaintext instance.</summary>
            <param name="value">The Plaintext instance to copy from</param>
            <exception cref="T:System.ArgumentNullException">If copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.Finalize">
            <summary>Destroys the Plaintext.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.Dispose">
            <summary>Destroys the Plaintext.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.Load(System.IO.Stream)">
            <summary>Loads a Plaintext from an input stream overwriting the current Plaintext.</summary>
            <param name="stream">The stream to load the Plaintext from</param>
            <exception cref="T:System.ArgumentNullException">if stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Plaintext.Save(System.IO.Stream)">See Save() to save a Plaintext.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.Save(System.IO.Stream)">
            <summary>Saves the Plaintext to an output stream.</summary>
            <remarks>
                Saves the Plaintext to an output stream. The output is in binary format and not human-readable. 
                The output stream must have the "binary" flag set.
                </remarks>
            <param name="stream">The stream to save the Plaintext to</param>
            <exception cref="T:System.ArgumentNullException">if stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Plaintext.Load(System.IO.Stream)">See Load() to load a saved Plaintext.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.op_Implicit(Microsoft.Research.SEAL.Plaintext)~Microsoft.Research.SEAL.BigPoly">
            <summary>Returns a copy of the underlying plaintext polynomial.</summary>
            <param name="plaintext">The plaintext object</param>
            <exception cref="T:System.ArgumentNullException">if plaintext is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.Set(System.String)">
            <summary>Sets the underlying plaintext polynomial from a given hexadecimal string.</summary>
            <remarks>
                <para>
                Sets the underlying plaintext polynomial from a given hexadecimal string.
                </para>
                <para>
                The string description of the polynomial must adhere to the format returned by <see cref="M:System.Object.ToString" />,
                which is of the form "7FFx^3 + 1x^1 + 3" and summarized by the following rules:
                <list type="number"><item><description>Terms are listed in order of strictly decreasing exponent</description></item><item><description>Coefficient values are non-negative and in hexadecimal format (upper and lower case letters are both supported)</description></item><item><description>Exponents are positive and in decimal format</description></item><item><description>Zero coefficient terms (including the constant term) may be (but do not have to be) omitted</description></item><item><description>Term with the exponent value of one is written as x^1</description></item><item><description>Term with the exponent value of zero (the constant term) is written as just a hexadecimal number without x or exponent</description></item><item><description>Terms are separated exactly by &lt;space&gt;+&lt;space&gt;</description></item><item><description>Other than the +, no other terms have whitespace</description></item></list></para>
            </remarks>
            <param name="hexPoly">The formatted polynomial string specifying the plaintext polynomial</param>
            <exception cref="T:System.ArgumentNullException">if hexPoly is null</exception>
            <exception cref="T:System.ArgumentException">if hexPoly does not adhere to the expected format</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.Set(Microsoft.Research.SEAL.BigPoly)">
            <summary>Sets the current Plaintext to wrap a given <see cref="T:Microsoft.Research.SEAL.BigPoly" /> by creating a copy of it.</summary>
            <param name="poly">The polynomial to copy from</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.Set(Microsoft.Research.SEAL.Plaintext)">
            <summary>Copies an old Plaintext to the current one.</summary>
            <param name="assign">The Plaintext to copy from</param>
            <exception cref="T:System.ArgumentNullException">if assign is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.#ctor(Microsoft.Research.SEAL.Plaintext)">
            <summary>Creates a copy of a Plaintext.</summary>
            <param name="copy">The Plaintext to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.#ctor(System.String)">
            <summary>Creates a Plaintext from a given hexadecimal string describing the plaintext polynomial.</summary>
            <remarks>
                <para>
                Creates a Plaintext from a given hexadecimal string describing the plaintext polynomial.
                </para>
                <para>
                The string description of the polynomial must adhere to the format returned by <see cref="M:System.Object.ToString" />, 
                which is of the form "7FFx^3 + 1x^1 + 3" and summarized by the following rules:
                <list type="number"><item><description>Terms are listed in order of strictly decreasing exponent</description></item><item><description>Coefficient values are non-negative and in hexadecimal format (upper and lower case letters are both supported)</description></item><item><description>Exponents are positive and in decimal format</description></item><item><description>Zero coefficient terms (including the constant term) may be (but do not have to be) omitted</description></item><item><description>Term with the exponent value of one is written as x^1</description></item><item><description>Term with the exponent value of zero (the constant term) is written as just a hexadecimal number without x or exponent</description></item><item><description>Terms are separated exactly by &lt;space&gt;+&lt;space&gt;</description></item><item><description>Other than the +, no other terms have whitespace</description></item></list></para>
            </remarks>
            <param name="hexPoly">The formatted polynomial string specifying the plaintext polynomial</param>
            <exception cref="T:System.ArgumentNullException">if hexPoly is null</exception>
            <exception cref="T:System.ArgumentException">if hexPoly does not adhere to the expected format</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.op_Implicit(Microsoft.Research.SEAL.BigPoly)~Microsoft.Research.SEAL.Plaintext">
            <summary>Creates a Plaintext by copying a given BigPoly instance.</summary>
            <remarks>
Creates a Plaintext by copying a given <see cref="T:Microsoft.Research.SEAL.BigPoly" /> instance. The created 
Plaintext will wrap a duplicate of the given <see cref="T:Microsoft.Research.SEAL.BigPoly" />.
</remarks>
            <param name="poly">The plaintext polynomial</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Plaintext.#ctor">
            <summary>Creates a Plaintext wrapping a constant polynomial 0.</summary>
        </member>
        <member name="M:seal.Plaintext.load(std.basic_istream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Loads a Plaintext from an input stream overwriting the current Plaintext.

        @param[in] stream The stream to load the Plaintext from
        @see save() to save a Plaintext.

</member>
        <member name="M:seal.Plaintext.save(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Saves the Plaintext to an output stream. The output is in binary format and not human-readable. 
        The output stream must have the "binary" flag set.

        @param[in] stream The stream to save the Plaintext to
        @see load() to load a saved Plaintext.

</member>
        <member name="M:seal.Plaintext.op_Implicit~seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced">
Returns a constant reference to the underlying plaintext polynomial.

</member>
        <member name="M:seal.Plaintext.op_Implicit~seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced">
Returns a reference to the underlying plaintext polynomial.

</member>
        <member name="M:seal.Plaintext.op_Assign(seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Sets the current Plaintext to wrap a given BigPoly by moving it.

        @param[in] poly The polynomial to move from

</member>
        <member name="M:seal.Plaintext.op_Assign(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Moves an old Plaintext to the current one.

        @param[in] assign The Plaintext to move from

        Sets the current Plaintext to wrap a given BigPoly by creating a copy of it.

        @param[in] poly The polynomial to copy from

</member>
        <member name="M:seal.Plaintext.op_Assign(seal.Plaintext!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new Plaintext by copying an old one.

        @param[in] copy The Plaintext to copy from

        Creates a new Plaintext by moving an old one.

        @param[in] source The Plaintext to move from

        Copies an old Plaintext to the current one.

        @param[in] assign The Plaintext to copy from

</member>
        <member name="M:seal.Plaintext.#ctor(seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a Plaintext by moving a given BigPoly instance.

        @param[in] poly The plaintext polynomial

</member>
        <member name="M:seal.Plaintext.#ctor(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a Plaintext by copying a given BigPoly instance. The created Plaintext 
        will wrap a duplicate of the given BigPoly.

        @param[in] poly The plaintext polynomial

</member>
        <member name="M:seal.Plaintext.#ctor">
Creates a Plaintext wrapping a constant polynomial 0.

</member>
        <member name="T:seal.Plaintext">
Represents a plaintext element. Currently the Plaintext class simply wraps an instance of 
the BigPoly class. In particular, it does not perform any sanity checking on the BigPoly 
that it wraps.

</member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.GetEncoder">
            <summary>Returns a reference to the underlying C++ FractionalEncoder.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.FractionalEncoder.Base">
            <summary>Returns the base used for encoding.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.FractionalEncoder.IntegerCoeffCount">
            <summary>Returns the number of coefficients reserved for the integral part.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.FractionalEncoder.FractionCoeffCount">
            <summary>Returns the number of coefficients reserved for the fractional part.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.FractionalEncoder.PolyModulus">
            <summary>Returns a reference to the polynomial modulus.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.FractionalEncoder.PlainModulus">
            <summary>Returns a reference to the plaintext modulus.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.Decode(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as a double-precision floating-point number.</summary>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if either the integral part does not fit in System::Int64</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.Encode(System.Double)">
            <summary>Encodes a double precision floating point number into a plaintext polynomial.</summary>
            <param name="value">The double-precision floating-point number to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.Finalize">
            <summary>Destroys the FractionalEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.Dispose">
            <summary>Destroys the FractionalEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.#ctor(Microsoft.Research.SEAL.FractionalEncoder)">
            <summary>Creates a copy of a FractionalEncoder.</summary>
            <param name="copy">The FractionalEncoder to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32,System.UInt64,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a new FractionalEncoder object.</summary>
            <remarks>
Creates a new FractionalEncoder object. The constructor takes as input a reference
to the plaintext modulus, a reference to the polynomial modulus,
and the numbers of coefficients that are reserved for the integral and fractional parts,
and an integer, at least 2, that is used as the base in the encoding. The coefficients
for the integral part are counted starting from the low-degree end of the polynomial,
and the coefficients for the fractional part are counted from the high-degree end.
The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool 
instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <param name="base">The base to be used for encoding</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus, polyModulus, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least base</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional
parts</exception>
            <exception cref="T:System.ArgumentException">if base is not an integer and at least 2</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32,System.UInt64)">
            <summary>Creates a new FractionalEncoder object.</summary>
            <remarks>
Creates a new FractionalEncoder object. The constructor takes as input a reference
to the plaintext modulus, a reference to the polynomial modulus,
and the numbers of coefficients that are reserved for the integral and fractional parts,
and an integer, at least 2, that is used as the base in the encoding. The coefficients 
for the integral part are counted starting from the low-degree end of the polynomial, 
and the coefficients for the fractional part are counted from the high-degree end.
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <param name="base">The base to be used for encoding</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or polyModulus is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least base</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional
parts</exception>
            <exception cref="T:System.ArgumentException">if base is not an integer and at least 2</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a new FractionalEncoder object.</summary>
            <remarks>
Creates a new FractionalEncoder object. The constructor takes as input a reference
to the plaintext modulus, a reference to the polynomial modulus,
and the numbers of coefficients that are reserved for the integral and fractional parts.
The base used for encoding is taken to be 2. The coefficients for the integral part are
counted starting from the low-degree end of the polynomial, and the coefficients for the
fractional part are counted from the high-degree end. The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" />
object to use a custom memory pool instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus, polyModulus, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional parts</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.FractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32)">
            <summary>Creates a new FractionalEncoder object.</summary>
            <remarks>
Creates a new FractionalEncoder object. The constructor takes as input a reference
to the plaintext modulus, a reference to the polynomial modulus,
and the numbers of coefficients that are reserved for the integral and fractional parts.
The base used for encoding is taken to be 2. The coefficients for the integral part are 
counted starting from the low-degree end of the polynomial, and the coefficients for the 
fractional part are counted from the high-degree end.
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or polyModulus is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional parts</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.GetEncoder">
            <summary>Returns a reference to the underlying C++ IntegerEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(System.UInt32,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by System::UInt32) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(System.Int32,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.
</para>
                <para>
Negative integers in the base-b encoding are represented the same way as positive integers,
namely, both positive and negative integers can have both positive and negative digits in their
base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(System.UInt32)">
            <summary>Encodes an unsigned integer (represented by System::UInt32) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(System.Int32)">
            <summary>Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.
</para>
                <para>
Negative integers in the base-b encoding are represented the same way as positive integers,
namely, both positive and negative integers can have both positive and negative digits in their
base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.DecodeBigUInt(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Decodes a plaintext polynomial and stores the result in a given BigUInt.</summary>
            <remarks>
Decodes a plaintext polynomial and stores the result in a given <see cref="T:Microsoft.Research.SEAL.BigUInt" />. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <param name="destination">The BigUInt to overwrite with the decoding</param>
            <exception cref="T:System.ArgumentNullException">if poly or destination is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in destination</exception>
            <exception cref="T:System.ArgumentException">if the output is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.DecodeBigUInt(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as BigUInt.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as <see cref="T:Microsoft.Research.SEAL.BigUInt" />. Mathematically this amounts to evaluating the input
polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.DecodeInt32(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::Int32.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::Int32. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::Int32</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.DecodeInt64(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::Int64.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::Int64. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::Int32</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.DecodeUInt32(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::UInt32.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::UInt32. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::UInt32</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.DecodeUInt64(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::UInt64.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::UInt64. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::UInt64</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(System.Int64,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.
</para>
                <para>
Negative integers in the base-b encoding are represented the same way as positive integers,
namely, both positive and negative integers can have both positive and negative digits in their
base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(System.Int64)">
            <summary>Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.
</para>
                <para>
Negative integers in the base-b encoding are represented the same way as positive integers,
namely, both positive and negative integers can have both positive and negative digits in their
base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if value or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(Microsoft.Research.SEAL.BigUInt)">
            <summary>Encodes an unsigned integer (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <exception cref="T:System.ArgumentNullException">if value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(System.UInt64,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by System::UInt64) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Encode(System.UInt64)">
            <summary>Encodes an unsigned integer (represented by System::UInt64) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
        </member>
        <member name="P:Microsoft.Research.SEAL.IntegerEncoder.Base">
            <summary>Returns the base used for encoding.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.IntegerEncoder.PlainModulus">
            <summary>Returns a reference to the plaintext modulus.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Finalize">
            <summary>Destroys the IntegerEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.Dispose">
            <summary>Destroys the IntegerEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.#ctor(Microsoft.Research.SEAL.IntegerEncoder)">
            <summary>Creates a copy of a IntegerEncoder.</summary>
            <param name="copy">The IntegerEncoder to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,System.UInt64,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates an IntegerEncoder object.</summary>
            <remarks>
Creates an IntegerEncoder object. The constructor takes as input a reference to the plaintext modulus 
(represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />), and an integer, at least 2, that is used as a base 
in the encoding. The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory 
pool instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <param name="base">The base to be used for encoding (default value is 2)</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or pool is null</exception>
            <exception cref="T:System.ArgumentException">if base is not an integer and at least 2</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least base</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Creates an IntegerEncoder object.</summary>
            <remarks>
Creates an IntegerEncoder object. The constructor takes as input a reference to the plaintext modulus 
(represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />), and an integer, at least 2, that is used as a base in the encoding.
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <param name="base">The base to be used for encoding (default value is 2)</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus is null</exception>
            <exception cref="T:System.ArgumentException">if base is not an integer and at least 2</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least base</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates an IntegerEncoder object.</summary>
            <remarks>
Creates an IntegerEncoder object with base set to 2. The constructor takes as input a reference to the
plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />). The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> 
object to use a custom memory pool instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or pool is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.IntegerEncoder.#ctor(Microsoft.Research.SEAL.BigUInt)">
            <summary>Creates an IntegerEncoder object.</summary>
            <remarks>
Creates an IntegerEncoder object with base set to 2. The constructor takes as input a reference to the 
plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.GetEncoder">
            <summary>Returns a reference to the underlying C++ BalancedFractionalEncoder.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BalancedFractionalEncoder.Base">
            <summary>Returns the base used for encoding.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BalancedFractionalEncoder.IntegerCoeffCount">
            <summary>Returns the number of coefficients reserved for the integral part.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BalancedFractionalEncoder.FractionCoeffCount">
            <summary>Returns the number of coefficients reserved for the fractional part.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BalancedFractionalEncoder.PolyModulus">
            <summary>Returns a reference to the polynomial modulus.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BalancedFractionalEncoder.PlainModulus">
            <summary>Returns a reference to the plaintext modulus.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.Decode(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as a double-precision floating-point number.</summary>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if either the integral part does not fit in System::Int64 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.Encode(System.Double)">
            <summary>Encodes a double precision floating point number into a plaintext polynomial.</summary>
            <param name="value">The double-precision floating-point number to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.Finalize">
            <summary>Destroys the BalancedFractionalEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.Dispose">
            <summary>Destroys the BalancedFractionalEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.#ctor(Microsoft.Research.SEAL.BalancedFractionalEncoder)">
            <summary>Creates a copy of a BalancedFractionalEncoder.</summary>
            <param name="copy">The BalancedFractionalEncoder to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32,System.UInt64,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a new BalancedFractionalEncoder object.</summary>
            <remarks>
Creates a new BalancedFractionalEncoder object. The constructor takes as input a reference to the plaintext modulus,
a reference to the polynomial modulus, and the numbers of coefficients that are reserved for
the integral and fractional parts, and an odd integer, at least 3, that is used as the base in the encoding.
The coefficients for the integral part are counted starting from the low-degree end of the polynomial, and the
coefficients for the fractional part are counted from the high-degree end. The user can give a 
<see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <param name="base">The base to be used for encoding</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus, polyModulus, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least (base + 1) / 2</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional
parts</exception>
            <exception cref="T:System.ArgumentException">if base is not an odd integer and at least 3</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32,System.UInt64)">
            <summary>Creates a new BalancedFractionalEncoder object.</summary>
            <remarks>
Creates a new BalancedFractionalEncoder object. The constructor takes as input a reference to the plaintext modulus,
a reference to the polynomial modulus, and the numbers of coefficients that are reserved for
the integral and fractional parts, and an odd integer, at least 3, that is used as the base in the encoding.
The coefficients for the integral part are counted starting from the low-degree end of the polynomial, and the
coefficients for the fractional part are counted from the high-degree end.
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <param name="base">The base to be used for encoding</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or polyModulus is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least (base + 1) / 2</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional
parts</exception>
            <exception cref="T:System.ArgumentException">if base is not an odd integer and at least 3</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a new BalancedFractionalEncoder object.</summary>
            <remarks>
Creates a new BalancedFractionalEncoder object. The constructor takes as input a reference to the plaintext modulus,
a reference to the polynomial modulus, and the numbers of coefficients that are reserved for
the integral and fractional parts. The base used for encoding is taken to be 3.
The coefficients for the integral part are counted starting from the low-degree end of the polynomial, and the
coefficients for the fractional part are counted from the high-degree end. The user can give a 
<see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus, polyModulus, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional
parts</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedFractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32)">
            <summary>Creates a new BalancedFractionalEncoder object.</summary>
            <remarks>
Creates a new BalancedFractionalEncoder object. The constructor takes as input a reference to the plaintext modulus,
a reference to the polynomial modulus, and the numbers of coefficients that are reserved for
the integral and fractional parts. The base used for encoding is taken to be 3.
The coefficients for the integral part are counted starting from the low-degree end of the polynomial, and the
coefficients for the fractional part are counted from the high-degree end.
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or polyModulus is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional
parts</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryFractionalEncoder.GetEncoder">
            <summary>Returns a reference to the underlying C++ BinaryFractionalEncoder.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BinaryFractionalEncoder.Base">
            <summary>Returns the base used for encoding (2).</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BinaryFractionalEncoder.IntegerCoeffCount">
            <summary>Returns the number of coefficients reserved for the integral part.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BinaryFractionalEncoder.FractionCoeffCount">
            <summary>Returns the number of coefficients reserved for the fractional part.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BinaryFractionalEncoder.PolyModulus">
            <summary>Returns a reference to the polynomial modulus.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BinaryFractionalEncoder.PlainModulus">
            <summary>Returns a reference to the plaintext modulus.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryFractionalEncoder.Decode(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as a double-precision floating-point number.</summary>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the integral part does not fit in System::Int64 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryFractionalEncoder.Encode(System.Double)">
            <summary>Encodes a double precision floating point number into a plaintext polynomial.</summary>
            <param name="value">The double-precision floating-point number to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryFractionalEncoder.#ctor(Microsoft.Research.SEAL.BinaryFractionalEncoder)">
            <summary>Creates a copy of a BinaryFractionalEncoder.</summary>
            <param name="copy">The BinaryFractionalEncoder to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryFractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a new BinaryFractionalEncoder object.</summary>
            <remarks>
Creates a new BinaryFractionalEncoder object. The constructor takes as input a reference to the plaintext modulus,
a reference to the polynomial modulus, and the numbers of coefficients that are reserved for
the integral and fractional parts. The coefficients for the integral part are counted starting from the low-degree 
end of the polynomial, and the coefficients for the fractional part are counted from the high-degree end. 
The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool instead of the 
global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus, polyModulus, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional
parts</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryFractionalEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly,System.Int32,System.Int32)">
            <summary>Creates a new BinaryFractionalEncoder object.</summary>
            <remarks>
Creates a new BinaryFractionalEncoder object. The constructor takes as input a reference to the plaintext modulus,
a reference to the polynomial modulus, and the numbers of coefficients that are reserved for
the integral and fractional parts. The coefficients for the integral part are counted starting from the low-degree end
of the polynomial, and the coefficients for the fractional part are counted from the high-degree end.
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />)</param>
            <param name="polyModulus">The polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />)</param>
            <param name="integerCoeffCount">The number of polynomial coefficients reserved for the integral part</param>
            <param name="fractionCoeffCount">The number of polynomial coefficients reserved for the fractional part</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or polyModulus is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <exception cref="T:System.ArgumentException">if integerCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if fractionCoeffCount is not strictly positive</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is zero</exception>
            <exception cref="T:System.ArgumentException">if polyModulus is too small for the integral and fractional
parts</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.GetEncoder">
            <summary>Returns a reference to the underlying C++ BalancedEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(System.UInt32,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by System::UInt32) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(System.Int32,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.
</para>
                <para>
Negative integers in the balanced base-b encoding are represented the same way as positive integers, namely, both
positive and negative integers can have both positive and negative digits in their balanced base-b representation.
Negative coefficients are stored in the plaintext polynomials as unsigned integers that represent them modulo the
plaintext modulus. Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(System.UInt32)">
            <summary>Encodes an unsigned integer (represented by System::UInt32) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(System.Int32)">
            <summary>Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.
</para>
                <para>
Negative integers in the balanced base-b encoding are represented the same way as positive integers, namely, both
positive and negative integers can have both positive and negative digits in their balanced base-b representation.
Negative coefficients are stored in the plaintext polynomials as unsigned integers that represent them modulo the
plaintext modulus. Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.DecodeBigUInt(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Decodes a plaintext polynomial and stores the result in a given BigUInt.</summary>
            <remarks>
Decodes a plaintext polynomial and stores the result in a given <see cref="T:Microsoft.Research.SEAL.BigUInt" />. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <param name="destination">The BigUInt to overwrite with the decoding</param>
            <exception cref="T:System.ArgumentNullException">if poly or destination is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in destination</exception>
            <exception cref="T:System.ArgumentException">if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.DecodeBigUInt(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as BigUInt.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as <see cref="T:Microsoft.Research.SEAL.BigUInt" />. Mathematically this amounts to evaluating the input
polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.DecodeInt32(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::Int32.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::Int32. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::Int32 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.DecodeInt64(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::Int64.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::Int64. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::Int64 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.DecodeUInt32(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::UInt32.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::UInt32. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::UInt32 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.DecodeUInt64(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::UInt64.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::UInt64. Mathematically this amounts to evaluating the
input polynomial at X=base.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::UInt64 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(System.Int64,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.
</para>
                <para>
Negative integers in the balanced base-b encoding are represented the same way as positive integers, namely, both
positive and negative integers can have both positive and negative digits in their balanced base-b representation.
Negative coefficients are stored in the plaintext polynomials as unsigned integers that represent them modulo the
plaintext modulus. Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(System.Int64)">
            <summary>Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.
</para>
                <para>
Negative integers in the balanced base-b encoding are represented the same way as positive integers, namely, both
positive and negative integers can have both positive and negative digits in their balanced base-b representation.
Negative coefficients are stored in the plaintext polynomials as unsigned integers that represent them modulo the
plaintext modulus. Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if value or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(Microsoft.Research.SEAL.BigUInt)">
            <summary>Encodes an unsigned integer (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <exception cref="T:System.ArgumentNullException">if value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(System.UInt64,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by System::UInt64) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Encode(System.UInt64)">
            <summary>Encodes an unsigned integer (represented by System::UInt64) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
        </member>
        <member name="P:Microsoft.Research.SEAL.BalancedEncoder.Base">
            <summary>Returns the base used for encoding.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BalancedEncoder.PlainModulus">
            <summary>Returns a reference to the plaintext modulus.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Finalize">
            <summary>Destroys the BalancedEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.Dispose">
            <summary>Destroys the BalancedEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.#ctor(Microsoft.Research.SEAL.BalancedEncoder)">
            <summary>Creates a copy of a BalancedEncoder.</summary>
            <param name="copy">The BalancedEncoder to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,System.UInt64,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a BalancedEncoder object.</summary>
            <remarks>
Creates a BalancedEncoder object. The constructor takes as input a reference to the plaintext modulus
(represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />), and an integer, at least 3, that is used as a base
in the encoding. The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom
memory pool instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <param name="base">The base to be used for encoding</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or pool is null</exception>
            <exception cref="T:System.ArgumentException">if base is not an integer and at least 3</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least base</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Creates a BalancedEncoder object.</summary>
            <remarks>
Creates a BalancedEncoder object. The constructor takes as input a reference to the plaintext modulus 
(represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />), and an integer, at least 3, that is used as a base 
in the encoding.
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <param name="base">The base to be used for encoding</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus is null</exception>
            <exception cref="T:System.ArgumentException">if base is not an integer and at least 3</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least base</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a BalancedEncoder object.</summary>
            <remarks>
Creates a BalancedEncoder object with base set to 3. The constructor takes as input a reference to the 
plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />). The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" />
object to use a custom memory pool instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or pool is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BalancedEncoder.#ctor(Microsoft.Research.SEAL.BigUInt)">
            <summary>Creates a BalancedEncoder object.</summary>
            <remarks>
Creates a BalancedEncoder object with base set to 3. The constructor takes as input a reference to the 
plaintext modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.GetEncoder">
            <summary>Returns a reference to the underlying C++ BinaryEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(System.UInt32,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by System::UInt32) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(System.Int32,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.
</para>
                <para>
Negative integers are represented by using -1 instead of 1 in the binary representation, and the negative coefficients
are stored in the plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus. Thus,
for example, a coefficient of -1 would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(System.UInt32)">
            <summary>Encodes an unsigned integer (represented by System::UInt32) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(System.Int32)">
            <summary>Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int32) into a plaintext polynomial.
</para>
                <para>
Negative integers are represented by using -1 instead of 1 in the binary representation, and the negative coefficients
are stored in the plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus. Thus,
for example, a coefficient of -1 would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.DecodeBigUInt(Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigUInt)">
            <summary>Decodes a plaintext polynomial and stores the result in a given BigUInt.</summary>
            <remarks>
Decodes a plaintext polynomial and stores the result in a given <see cref="T:Microsoft.Research.SEAL.BigUInt" />. Mathematically this amounts to evaluating the
input polynomial at X=2.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <param name="destination">The BigUInt to overwrite with the decoding</param>
            <exception cref="T:System.ArgumentNullException">if poly or destination is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in destination</exception>
            <exception cref="T:System.ArgumentException">if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.DecodeBigUInt(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as BigUInt.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as <see cref="T:Microsoft.Research.SEAL.BigUInt" />. Mathematically this amounts to evaluating the input
polynomial at X=2.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.DecodeInt32(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::Int32.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::Int32. Mathematically this amounts to evaluating the
input polynomial at X=2.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::Int32 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.DecodeInt64(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::Int64.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::Int64. Mathematically this amounts to evaluating the
input polynomial at X=2.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if poly is not a valid plaintext polynomial</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::Int64 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.DecodeUInt32(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::UInt32.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::UInt32. Mathematically this amounts to evaluating the
input polynomial at X=2.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::UInt32 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.DecodeUInt64(Microsoft.Research.SEAL.BigPoly)">
            <summary>Decodes a plaintext polynomial and returns the result as System::UInt64.</summary>
            <remarks>
Decodes a plaintext polynomial and returns the result as System::UInt64. Mathematically this amounts to evaluating the
input polynomial at X=2.
</remarks>
            <param name="poly">The polynomial to be decoded</param>
            <exception cref="T:System.ArgumentNullException">if poly is null</exception>
            <exception cref="T:System.ArgumentException">if the output does not fit in System::UInt64 (#ifdef THROW_ON_DECODER_OVERFLOW)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(System.Int64,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.
</para>
                <para>
Negative integers are represented by using -1 instead of 1 in the binary representation, and the negative coefficients
are stored in the plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus. Thus,
for example, a coefficient of -1 would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(System.Int64)">
            <summary>Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.</summary>
            <remarks>
                <para>
Encodes a signed integer (represented by System::Int64) into a plaintext polynomial.
</para>
                <para>
Negative integers are represented by using -1 instead of 1 in the binary representation, and the negative coefficients
are stored in the plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus. Thus,
for example, a coefficient of -1 would be stored as a polynomial coefficient plainModulus-1.
</para>
            </remarks>
            <param name="value">The signed integer to encode</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if value or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(Microsoft.Research.SEAL.BigUInt)">
            <summary>Encodes an unsigned integer (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <exception cref="T:System.ArgumentNullException">if value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(System.UInt64,Microsoft.Research.SEAL.BigPoly)">
            <summary>Encodes an unsigned integer (represented by System::UInt64) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
            <param name="destination">The polynomial to overwrite with the encoding</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Encode(System.UInt64)">
            <summary>Encodes an unsigned integer (represented by System::UInt64) into a plaintext polynomial.</summary>
            <param name="value">The unsigned integer to encode</param>
        </member>
        <member name="P:Microsoft.Research.SEAL.BinaryEncoder.Base">
            <summary>Returns the base used for encoding (2).</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BinaryEncoder.PlainModulus">
            <summary>Returns a reference to the plaintext modulus.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Finalize">
            <summary>Destroys the BinaryEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.Dispose">
            <summary>Destroys the BinaryEncoder.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.#ctor(Microsoft.Research.SEAL.BinaryEncoder)">
            <summary>Creates a copy of a BinaryEncoder.</summary>
            <param name="copy">The BinaryEncoder to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.#ctor(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a BinaryEncoder object.</summary>
            <remarks>
Creates a BinaryEncoder object. The constructor takes as input a reference to the plaintext modulus 
(represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />). The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object 
to use a custom memory pool instead of the global memory pool (default).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus or pool is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BinaryEncoder.#ctor(Microsoft.Research.SEAL.BigUInt)">
            <summary>Creates a BinaryEncoder object.</summary>
            <remarks>
Creates a BinaryEncoder object. The constructor takes as input a reference to the plaintext modulus (represented by
<see cref="T:Microsoft.Research.SEAL.BigUInt" />).
</remarks>
            <param name="plainModulus">The plaintext modulus (represented by BigUInt)</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus is null</exception>
            <exception cref="T:System.ArgumentException">if plainModulus is not at least 2</exception>
        </member>
        <member name="M:seal.FractionalEncoder.integer_coeff_count">
Returns the number of coefficients reserved for the integral part.

</member>
        <member name="M:seal.FractionalEncoder.fraction_coeff_count">
Returns the number of coefficients reserved for the fractional part.

</member>
        <member name="M:seal.FractionalEncoder.base">
Returns the base used for encoding.

</member>
        <member name="M:seal.FractionalEncoder.poly_modulus">
Returns a reference to the polynomial modulus.

</member>
        <member name="M:seal.FractionalEncoder.plain_modulus">
Returns a reference to the plaintext modulus.

</member>
        <member name="M:seal.FractionalEncoder.decode(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as a double-precision
        floating-point number.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the integral part does not fit in std::int64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.FractionalEncoder.encode(System.Double)">
        Encodes a double precision floating point number into a plaintext polynomial.

        @param[in] value The double-precision floating-point number to encode

</member>
        <member name="M:seal.FractionalEncoder.Dispose">
        Creates a new FractionalEncoder by moving an old one.

        @param[in] source The FractionalEncoder to move from

Destroys the FractionalEncoder.

</member>
        <member name="M:seal.FractionalEncoder.#ctor(seal.FractionalEncoder!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a copy of a FractionalEncoder.

        @param[in] copy The FractionalEncoder to copy from

</member>
        <member name="M:seal.FractionalEncoder.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.UInt64,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new FractionalEncoder object. The constructor takes as input a reference
        to the plaintext modulus, a reference to the polynomial modulus,
        and the numbers of coefficients that are reserved for the integral and fractional parts,
        and optionally an integer, at least 2, that is used as the base in the encoding.
        The coefficients for the integral part are counted starting from the low-degree end
        of the polynomial, and the coefficients for the fractional part are counted from the
        high-degree end. Optionally, the user can give a reference to a MemoryPoolHandle object 
        to use a custom memory pool instead of the global memory pool (default).

        @param[in] plain_modulus The plaintext modulus (represented by BigUInt)
        @param[in] poly_modulus The polynomial modulus (represented by BigPoly)
        @param[in] integer_coeff_count The number of polynomial coefficients reserved for the integral part
        @param[in] fraction_coeff_count The number of polynomial coefficients reserved for the fractional part
        @param[in] base The base to be used for encoding (default value is 2)
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if plain_modulus is not at least base
        @throws std::invalid_argument if integer_coeff_count is not strictly positive
        @throws std::invalid_argument if fraction_coeff_count is not strictly positive
        @throws std::invalid_argument if poly_modulus is zero
        @throws std::invalid_argument if poly_modulus is too small for the integral and fractional parts
        @throws std::invalid_argument if base is not an integer and at least 2
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.FractionalEncoder">
    Encodes floating point numbers into plaintext polynomials that Encryptor can encrypt.
    An instance of the FractionalEncoder class converts a double-precision floating-point
    number into a plaintext polynomial by computing its balanced base-b representation, 
    encoding the integral part as in IntegerEncoder, and the fractional part as the highest 
    degree terms of the plaintext polynomial, with signs inverted. For an even base b, the
    coefficients of the polynomial are in the range -b/2,...,b/2-1. When b is 2, the
    coefficients are either all non-negative (0 and 1), or all non-positive (0 and -1).
    Decoding the polynomial back into a double amounts to evaluating the low degree part 
    at X=b, negating the coefficients of the high degree part and evaluating it at X=1/b.

    Addition and multiplication on the double side translate into addition and multiplication
    on the encoded plaintext polynomial side, provided that the integral part never mixes
    with the fractional part in the plaintext polynomials, and that the
    coefficients of the plaintext polynomials appearing throughout the computations never
    experience coefficients larger than the plaintext modulus (plain_modulus).

    @par Integral and Fractional Parts
    When homomorphic multiplications are performed, the integral part "grows up" to higher
    degree coefficients of the plaintext polynomial space, and the fractional part "grows down"
    from the top degree coefficients towards the lower degree coefficients. For decoding to work,
    these parts must not interfere with each other. When setting up the BalancedFractionalEncoder,
    one must specify how many coefficients of a plaintext polynomial are reserved for the integral
    part and how many for the fractional. The sum of these numbers can be at most equal to the
    degree of the polynomial modulus minus one. If homomorphic multiplications are performed, it is
    also necessary to leave enough room for the fractional part to "grow down".

    @par Negative Integers
    Negative integers in the base-b encoding are represented the same way as positive integers,
    namely, both positive and negative integers can have both positive and negative digits in their
    base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
    integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    would be stored as a polynomial coefficient plain_modulus-1.

    @par Decoding Overflow
    In many cases it is a bad idea to throw an exception when decoding fails due to an overflow
    condition, e.g. decode is given a polynomial whose integer part decodes into a value larger than 64 bits.
    If such an exception is not handled silently, a malicious observer might notice
    this happening, and be able to extract one bit of information about the secret key.
    Thus, by default, the decoder functions do not throw exceptions in cases of overflow.
    However, the throws are automatically enabled in debug mode in Visual Studio, and more
    generally they can be directly controlled by the preprocessor define THROW_ON_DECODER_OVERFLOW
    in the file util/defines.h.

    @par BinaryFractionalEncoder and BalancedFractionalEncoder
    Under the hood FractionalEncoder uses either the BinaryFractionalEncoder or the 
    BalancedFractionalEncoder classes to do the encoding. The first one is used when the base is 2, 
    and the second one when the base is at least 3. Currently the BinaryFractionalEncoder and 
    BalancedFractionalEncoder classes can also be used directly, but this might change in future releases.

    @see BinaryFractionalEncoder for encoding using the binary representation.
    @see BalancedFractionalEncoder for encoding using base-b representation for b greater than 2.
    @see IntegerEncoder for encoding integers.

</member>
        <member name="M:seal.IntegerEncoder.base">
Returns the base used for encoding.

</member>
        <member name="M:seal.IntegerEncoder.plain_modulus">
Returns a reference to the plaintext modulus.

</member>
        <member name="M:seal.IntegerEncoder.encode(System.UInt32,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.IntegerEncoder.encode(System.Int32,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers in the base-b encoding are represented the same way as positive integers,
        namely, both positive and negative integers can have both positive and negative digits in their
        base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
        integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
        would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.IntegerEncoder.encode(System.UInt32)">
        Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.IntegerEncoder.encode(System.Int32)">
        Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers in the base-b encoding are represented the same way as positive integers,
        namely, both positive and negative integers can have both positive and negative digits in their
        base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
        integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
        would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode

</member>
        <member name="M:seal.IntegerEncoder.decode_biguint(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and stores the result in a given BigUInt.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @param[out] destination The BigUInt to overwrite with the decoding
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in destination
        @throws std::invalid_argument if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.IntegerEncoder.decode_biguint(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as BigUInt.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.IntegerEncoder.decode_int64(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::int64_t.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::int64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.IntegerEncoder.decode_int32(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::int32_t.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::int32_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.IntegerEncoder.encode(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.IntegerEncoder.encode(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.IntegerEncoder.encode(System.Int64,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers in the base-b encoding are represented the same way as positive integers,
        namely, both positive and negative integers can have both positive and negative digits in their
        base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
        integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
        would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.IntegerEncoder.encode(System.Int64)">
        Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers in the base-b encoding are represented the same way as positive integers,
        namely, both positive and negative integers can have both positive and negative digits in their
        base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned
        integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
        would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode

</member>
        <member name="M:seal.IntegerEncoder.decode_uint64(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::uint64_t.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::uint64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.IntegerEncoder.decode_uint32(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::uint32_t.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::uint32_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.IntegerEncoder.encode(System.UInt64,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.IntegerEncoder.encode(System.UInt64)">
        Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.IntegerEncoder.Dispose">
        Creates a new IntegerEncoder by moving an old one.

        @param[in] source The IntegerEncoder to move from

Destroys the IntegerEncoder.

</member>
        <member name="M:seal.IntegerEncoder.#ctor(seal.IntegerEncoder!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a copy of a IntegerEncoder.

        @param[in] copy The IntegerEncoder to copy from

</member>
        <member name="M:seal.IntegerEncoder.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates an IntegerEncoder object. The constructor takes as input a reference
        to the plaintext modulus (represented by BigUInt), and optionally an integer,
        at least 2, that is used as a base in the encoding. Optionally, the user can
        give a reference to a MemoryPoolHandle object to use a custom memory pool
        instead of the global memory pool (default).

        @param[in] plain_modulus The plaintext modulus (represented by BigUInt)
        @param[in] base The base to be used for encoding (default value is 2)
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if base is not an integer and at least 2
        @throws std::invalid_argument if plain_modulus is not at least base
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.IntegerEncoder">
    Encodes integers into plaintext polynomials that Encryptor can encrypt. An instance of
    the IntegerEncoder class converts an integer into a plaintext polynomial by placing its
    digits in balanced base-b representation as the coefficients of the polynomial. The base
    b must be a positive integer at least 2 (which is the default value). When b is odd,
    digits in such a balanced representation are integers in the range -(b-1)/2,...,(b-1)/2.
    When b is even, digits are integers in the range -b/2,...,b/2-1. When b is 2, the 
    coefficients are either all non-negative (0 and 1), or all non-positive (0 and -1). A larger 
    base allows for more compact representation at the cost of having larger coefficients in 
    freshly encoded plaintext polynomials. Decoding the integer amounts to evaluating the 
    plaintext polynomial at X=b.

    Addition and multiplication on the integer side translate into addition and multiplication
    on the encoded plaintext polynomial side, provided that the length of the polynomial
    never grows to be of the size of the polynomial modulus (poly_modulus), and that the
    coefficients of the plaintext polynomials appearing throughout the computations never
    experience coefficients larger than the plaintext modulus (plain_modulus).

    @par Negative Integers
    Negative integers in the base-b encoding are represented the same way as positive integers, 
    namely, both positive and negative integers can have both positive and negative digits in their 
    base-b representation. Negative coefficients are stored in the plaintext polynomials as unsigned 
    integers that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1 
    would be stored as a polynomial coefficient plain_modulus-1.

    @par Decoding Overflow
    In many cases it is a bad idea to throw an exception when decoding fails due to an overflow
    condition, e.g. decode_uint32 is given a polynomial that decodes into a value larger than
    32 bits. If such an exception is not handled silently, a malicious observer might notice
    this happening, and be able to extract one bit of information about the secret key.
    Thus, by default, the decoder functions do not throw exceptions in cases of overflow.
    However, the throws are automatically enabled in debug mode in Visual Studio, and more
    generally they can be directly controlled by the preprocessor define THROW_ON_DECODER_OVERFLOW
    in the file util/defines.h.

    @par BinaryEncoder and BalancedEncoder
    Under the hood IntegerEncoder uses either the BinaryEncoder or the BalancedEncoder classes
    to do the encoding. The first one is used when the base is 2, and the second one when the
    base is at least 3. Currently the BinaryEncoder and BalancedEncoder classes can also be used 
    directly, but this might change in future releases.

    @see BinaryEncoder for encoding using the binary representation.
    @see BalancedEncoder for encoding using base-b representation for b greater than 2.
    @see FractionalEncoder for encoding real numbers.

</member>
        <member name="M:seal.BalancedFractionalEncoder.integer_coeff_count">
Returns the number of coefficients reserved for the integral part.

</member>
        <member name="M:seal.BalancedFractionalEncoder.fraction_coeff_count">
Returns the number of coefficients reserved for the fractional part.

</member>
        <member name="M:seal.BalancedFractionalEncoder.base">
Returns the base used for encoding.

</member>
        <member name="M:seal.BalancedFractionalEncoder.poly_modulus">
Returns a reference to the polynomial modulus.

</member>
        <member name="M:seal.BalancedFractionalEncoder.plain_modulus">
Returns a reference to the plaintext modulus.

</member>
        <member name="M:seal.BalancedFractionalEncoder.decode(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as a double-precision
        floating-point number.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the integral part does not fit in std::int64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BalancedFractionalEncoder.encode(System.Double)">
        Encodes a double precision floating point number into a plaintext polynomial.

        @param[in] value The double-precision floating-point number to encode

</member>
        <member name="M:seal.BalancedFractionalEncoder.Dispose">
        Creates a copy of a BalancedFractionalEncoder.

        @param[in] copy The BalancedFractionalEncoder to copy from

        Creates a new BalancedFractionalEncoder by moving an old one.

        @param[in] source The BalancedFractionalEncoder to move from

Destroys the BalancedFractionalEncoder.

</member>
        <member name="M:seal.BalancedFractionalEncoder.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,System.UInt64,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new BalancedFractionalEncoder object. The constructor takes as input a reference
        to the plaintext modulus, a reference to the polynomial modulus,
        and the numbers of coefficients that are reserved for the integral and fractional parts,
        and optionally an integer, at least 3, that is used as the base in the encoding.
        The coefficients for the integral part are counted starting from the low-degree end
        of the polynomial, and the coefficients for the fractional part are counted from the
        high-degree end. Optionally, the user can give a reference to a MemoryPoolHandle object 
        to use a custom memory pool instead of the global memory pool (default).

        @param[in] plain_modulus The plaintext modulus (represented by BigUInt)
        @param[in] poly_modulus The polynomial modulus (represented by BigPoly)
        @param[in] integer_coeff_count The number of polynomial coefficients reserved for the integral part
        @param[in] fraction_coeff_count The number of polynomial coefficients reserved for the fractional part
        @param[in] base The base to be used for encoding (default value is 3)
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if plain_modulus is not at least base
        @throws std::invalid_argument if integer_coeff_count is not strictly positive
        @throws std::invalid_argument if fraction_coeff_count is not strictly positive
        @throws std::invalid_argument if poly_modulus is zero
        @throws std::invalid_argument if poly_modulus is too small for the integral and fractional parts
        @throws std::invalid_argument if base is not an integer and at least 3
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.BalancedFractionalEncoder">
    Encodes floating point numbers into plaintext polynomials that Encryptor can encrypt.
    An instance of the BalancedFractionalEncoder class converts a double-precision floating-point
    number into a plaintext polynomial by computing its balanced base-b representation, encoding the
    integral part as in BalancedEncoder, and the fractional part as the highest degree
    terms of the plaintext polynomial, with signs inverted. For an even base b, the
    coefficients of the polynomial are in the range -b/2,...,b/2-1. Decoding the polynomial back
    into a double amounts to evaluating the low degree part at X=b, negating the coefficients
    of the high degree part and evaluating it at X=1/b.

    Addition and multiplication on the double side translate into addition and multiplication
    on the encoded plaintext polynomial side, provided that the integral part never mixes
    with the fractional part in the plaintext polynomials, and that the
    coefficients of the plaintext polynomials appearing throughout the computations never
    experience coefficients larger than the plaintext modulus (plain_modulus).

    @par Integral and Fractional Parts
    When homomorphic multiplications are performed, the integral part "grows up" to higher
    degree coefficients of the plaintext polynomial space, and the fractional part "grows down"
    from the top degree coefficients towards the lower degree coefficients. For decoding to work,
    these parts must not interfere with each other. When setting up the BalancedFractionalEncoder,
    one must specify how many coefficients of a plaintext polynomial are reserved for the integral
    part and how many for the fractional. The sum of these numbers can be at most equal to the
    degree of the polynomial modulus minus one. If homomorphic multiplications are performed, it is
    also necessary to leave enough room for the fractional part to "grow down".

    @par Negative Integers
    Negative integers in the balanced base-b encoding are represented the same way as
    positive integers, namely, both positive and negative integers can have both positive and negative
    digits in their balanced base-b representation. Negative coefficients are stored in the
    plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
    Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.

    @par Decoding Overflow
    In many cases it is a bad idea to throw an exception when decoding fails due to an overflow
    condition, e.g. decode is given a polynomial whose integer part decodes into a value larger than 64 bits.
    If such an exception is not handled silently, a malicious observer might notice
    this happening, and be able to extract one bit of information about the secret key.
    Thus, by default, the decoder functions do not throw exceptions in cases of overflow.
    However, the throws are automatically enabled in debug mode in Visual Studio, and more
    generally they can be directly controlled by the preprocessor define THROW_ON_DECODER_OVERFLOW
    in the file util/defines.h.

    @see BalancedEncoder for encoding integers.
    @see BinaryFractionalEncoder for encoding using the binary representation.
    @see FractionalEncoder for a common interface to all fractional encoders.

</member>
        <member name="M:seal.BinaryFractionalEncoder.integer_coeff_count">
Returns the number of coefficients reserved for the integral part.

</member>
        <member name="M:seal.BinaryFractionalEncoder.fraction_coeff_count">
Returns the number of coefficients reserved for the fractional part.

</member>
        <member name="M:seal.BinaryFractionalEncoder.base">
Returns the base used for encoding (2).

</member>
        <member name="M:seal.BinaryFractionalEncoder.poly_modulus">
Returns a reference to the polynomial modulus.

</member>
        <member name="M:seal.BinaryFractionalEncoder.plain_modulus">
Returns a reference to the plaintext modulus.

</member>
        <member name="M:seal.BinaryFractionalEncoder.decode(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as a double-precision
        floating-point number.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the integral part does not fit in std::int64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BinaryFractionalEncoder.encode(System.Double)">
        Encodes a double precision floating point number into a plaintext polynomial.

        @param[in] value The double-precision floating-point number to encode

</member>
        <member name="M:seal.BinaryFractionalEncoder.Dispose">
        Creates a copy of a BinaryFractionalEncoder.

        @param[in] copy The BinaryFractionalEncoder to copy from

        Creates a new BinaryFractionalEncoder by moving an old one.

        @param[in] source The BinaryFractionalEncoder to move from

Destroys the BinaryFractionalEncoder.

</member>
        <member name="M:seal.BinaryFractionalEncoder.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new BinaryFractionalEncoder object. The constructor takes as input a reference
        to the plaintext modulus, a reference to the polynomial modulus,
        and the numbers of coefficients that are reserved for the integral and fractional parts.
        The coefficients for the integral part are counted starting from the low-degree end
        of the polynomial, and the coefficients for the fractional part are counted from the
        high-degree end. Optionally, the user can give a reference to a MemoryPoolHandle object 
        to use a custom memory pool instead of the global memory pool (default).

        @param[in] plain_modulus The plaintext modulus (represented by BigUInt)
        @param[in] poly_modulus The polynomial modulus (represented by BigPoly)
        @param[in] integer_coeff_count The number of polynomial coefficients reserved for the integral part
        @param[in] fraction_coeff_count The number of polynomial coefficients reserved for the fractional part
        @param[in] The memory pool handle
        @throws std::invalid_argument if plain_modulus is not at least 2
        @throws std::invalid_argument if integer_coeff_count is not strictly positive
        @throws std::invalid_argument if fraction_coeff_count is not strictly positive
        @throws std::invalid_argument if poly_modulus is zero
        @throws std::invalid_argument if poly_modulus is too small for the integral and fractional parts
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.BinaryFractionalEncoder">
    Encodes floating point numbers into plaintext polynomials that Encryptor can encrypt.
    An instance of the BinaryFractionalEncoder class converts a double-precision floating-point
    number into a plaintext polynomial by computing its binary representation, encoding the
    integral part as in BinaryEncoder, and the fractional part as the highest degree
    terms of the plaintext polynomial, with signs inverted. Decoding the polynomial
    back into a double amounts to evaluating the low degree part at X=2, negating the
    coefficients of the high degree part and evaluating it at X=1/2.

    Addition and multiplication on the double side translate into addition and multiplication
    on the encoded plaintext polynomial side, provided that the integral part never mixes
    with the fractional part in the plaintext polynomials, and that the
    coefficients of the plaintext polynomials appearing throughout the computations never
    experience coefficients larger than the plaintext modulus (plain_modulus).

    @par Integral and Fractional Parts
    When homomorphic multiplications are performed, the integral part "grows up" to higher
    degree coefficients of the plaintext polynomial space, and the fractional part "grows down"
    from the top degree coefficients towards the lower degree coefficients. For decoding to work,
    these parts must not interfere with each other. When setting up the BinaryFractionalEncoder,
    one must specify how many coefficients of a plaintext polynomial are reserved for the integral
    part and how many for the fractional. The sum of these numbers can be at most equal to the
    degree of the polynomial modulus minus one. If homomorphic multiplications are performed, it is
    also necessary to leave enough room for the fractional part to "grow down".

    @par Negative Integers
    Negative integers are represented by using -1 instead of 1 in the binary representation,
    and the negative coefficients are stored in the plaintext polynomials as unsigned integers
    that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    would be stored as a polynomial coefficient plain_modulus-1.

    @par Decoding Overflow
    In many cases it is a bad idea to throw an exception when decoding fails due to an overflow
    condition, e.g. decode is given a polynomial whose integer part decodes into a value larger than 64 bits. 
    If such an exception is not handled silently, a malicious observer might notice
    this happening, and be able to extract one bit of information about the secret key.
    Thus, by default, the decoder functions do not throw exceptions in cases of overflow.
    However, the throws are automatically enabled in debug mode in Visual Studio, and more
    generally they can be directly controlled by the preprocessor define THROW_ON_DECODER_OVERFLOW
    in the file util/defines.h.

    @see BinaryEncoder for encoding integers.
    @see BalancedFractionalEncoder for encoding using base-b representation for b greater than 2.
    @see FractionalEncoder for a common interface to all fractional encoders.

</member>
        <member name="M:seal.BalancedEncoder.base">
Returns the base used for encoding.

</member>
        <member name="M:seal.BalancedEncoder.plain_modulus">
Returns a reference to the plaintext modulus.

</member>
        <member name="M:seal.BalancedEncoder.encode(System.UInt32,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BalancedEncoder.encode(System.Int32,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers in the balanced base-b encoding are represented the same way as
        positive integers, namely, both positive and negative integers can have both positive and negative
        digits in their balanced base-b representation. Negative coefficients are stored in the
        plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
        Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BalancedEncoder.encode(System.UInt32)">
        Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.BalancedEncoder.encode(System.Int32)">
        Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers in the balanced base-b encoding are represented the same way as
        positive integers, namely, both positive and negative integers can have both positive and negative
        digits in their balanced base-b representation. Negative coefficients are stored in the
        plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
        Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode

</member>
        <member name="M:seal.BalancedEncoder.decode_biguint(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and stores the result in a given BigUInt.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @param[out] destination The BigUInt to overwrite with the decoding
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in destination
        @throws std::invalid_argument if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BalancedEncoder.decode_biguint(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as BigUInt.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BalancedEncoder.decode_int64(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::int64_t.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::int64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BalancedEncoder.decode_int32(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::int32_t.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::int32_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BalancedEncoder.encode(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BalancedEncoder.encode(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.BalancedEncoder.encode(System.Int64,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers in the balanced base-b encoding are represented the same way as
        positive integers, namely, both positive and negative integers can have both positive and negative
        digits in their balanced base-b representation. Negative coefficients are stored in the
        plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
        Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BalancedEncoder.encode(System.Int64)">
        Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers in the balanced base-b encoding are represented the same way as
        positive integers, namely, both positive and negative integers can have both positive and negative
        digits in their balanced base-b representation. Negative coefficients are stored in the
        plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
        Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode

</member>
        <member name="M:seal.BalancedEncoder.decode_uint64(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::uint64_t.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::uint64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BalancedEncoder.decode_uint32(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::uint32_t.
        Mathematically this amounts to evaluating the input polynomial at X=base.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::uint32_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BalancedEncoder.encode(System.UInt64,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BalancedEncoder.encode(System.UInt64)">
        Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.BalancedEncoder.Dispose">
        Creates a copy of a BalancedEncoder.

        @param[in] copy The BalancedEncoder to copy from

        Creates a new BalancedEncoder by moving an old one.

        @param[in] source The BalancedEncoder to move from

Destroys the BalancedEncoder.

</member>
        <member name="M:seal.BalancedEncoder.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a BalancedEncoder object. The constructor takes as input a reference
        to the plaintext modulus (represented by BigUInt), and optionally an integer,
        at least 3, that is used as a base in the encoding. Optionally, the user can 
        give a reference to a MemoryPoolHandle object to use a custom memory pool
        instead of the global memory pool (default).

        @param[in] plain_modulus The plaintext modulus (represented by BigUInt)
        @param[in] base The base to be used for encoding (default value is 3)
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if base is not an integer and at least 3
        @throws std::invalid_argument if plain_modulus is not at least base
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.BalancedEncoder">
    Encodes integers into plaintext polynomials that Encryptor can encrypt. An instance of
    the BalancedEncoder class converts an integer into a plaintext polynomial by placing its
    digits in balanced base-b representation as the coefficients of the polynomial. The base
    b must be a positive integer at least 3 (which is the default value). When b is odd,
    digits in such a balanced representation are integers in the range
    -(b-1)/2,...,(b-1)/2. When b is even, digits are integers in the range -b/2,..., b/2-1.
    Note that the default value 3 for the base b allows for more compact representation than
    BinaryEncoder without increasing the sizes of the coefficients of freshly encoded plaintext
    polynomials. A larger base allows for an even more compact representation at the cost of
    having larger coefficients in freshly encoded plaintext polynomials. Decoding the integer
    amounts to evaluating the plaintext polynomial at X=b.

    Addition and multiplication on the integer side translate into addition and multiplication
    on the encoded plaintext polynomial side, provided that the length of the polynomial
    never grows to be of the size of the polynomial modulus (poly_modulus), and that the
    coefficients of the plaintext polynomials appearing throughout the computations never
    experience coefficients larger than the plaintext modulus (plain_modulus).

    @par Negative Integers
    Negative integers in the balanced base-b encoding are represented the same way as
    positive integers, namely, both positive and negative integers can have both positive and negative
    digits in their balanced base-b representation. Negative coefficients are stored in the
    plaintext polynomials as unsigned integers that represent them modulo the plaintext modulus.
    Thus, for example, a coefficient of -1 would be stored as a polynomial coefficient plain_modulus-1.

    @par Decoding Overflow
    In many cases it is a bad idea to throw an exception when decoding fails due to an overflow
    condition, e.g. decode_uint32 is given a polynomial that decodes into a value larger than
    32 bits. If such an exception is not handled silently, a malicious observer might notice
    this happening, and be able to extract one bit of information about the secret key.
    Thus, by default, the decoder functions do not throw exceptions in cases of overflow.
    However, the throws are automatically enabled in debug mode in Visual Studio, and more
    generally they can be directly controlled by the preprocessor define THROW_ON_DECODER_OVERFLOW
    in the file util/defines.h.

    @see BalancedFractionalEncoder for encoding real numbers.
    @see BinaryEncoder for encoding using the binary representation.
    @see IntegerEncoder for a common interface to all integer encoders.

</member>
        <member name="M:seal.BinaryEncoder.base">
            <summary>Returns the base used for encoding (2).</summary>
        </member>
        <member name="M:seal.BinaryEncoder.plain_modulus">
Returns a reference to the plaintext modulus.

</member>
        <member name="M:seal.BinaryEncoder.encode(System.UInt32,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BinaryEncoder.encode(System.Int32,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers are represented by using -1 instead of 1 in the binary representation,
        and the negative coefficients are stored in the plaintext polynomials as unsigned integers
        that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
        would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BinaryEncoder.encode(System.UInt32)">
        Encodes an unsigned integer (represented by std::uint32_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.BinaryEncoder.encode(System.Int32)">
        Encodes a signed integer (represented by std::int32_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers are represented by using -1 instead of 1 in the binary representation,
        and the negative coefficients are stored in the plaintext polynomials as unsigned integers
        that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
        would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode

</member>
        <member name="M:seal.BinaryEncoder.decode_biguint(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and stores the result in a given BigUInt.
        Mathematically this amounts to evaluating the input polynomial at X=2.

        @param[in] poly The polynomial to be decoded
        @param[out] destination The BigUInt to overwrite with the decoding
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in destination
        @throws std::invalid_argument if the output is negative (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BinaryEncoder.decode_biguint(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as BigUInt.
        Mathematically this amounts to evaluating the input polynomial at X=2.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output is negative

</member>
        <member name="M:seal.BinaryEncoder.decode_int64(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::int64_t.
        Mathematically this amounts to evaluating the input polynomial at X=2.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::int64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BinaryEncoder.decode_int32(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::int32_t.
        Mathematically this amounts to evaluating the input polynomial at X=2.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if poly is not a valid plaintext polynomial
        @throws std::invalid_argument if the output does not fit in std::int32_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BinaryEncoder.encode(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BinaryEncoder.encode(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by BigUInt) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.BinaryEncoder.encode(System.Int64,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes a signed integer (represented by std::int64_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers are represented by using -1 instead of 1 in the binary representation,
        and the negative coefficients are stored in the plaintext polynomials as unsigned integers
        that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
        would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BinaryEncoder.encode(System.Int64)">
        Encodes a signed integer (represented by std::uint64_t) into a plaintext polynomial.

        @par Negative Integers
        Negative integers are represented by using -1 instead of 1 in the binary representation,
        and the negative coefficients are stored in the plaintext polynomials as unsigned integers
        that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
        would be stored as a polynomial coefficient plain_modulus-1.

        @param[in] value The signed integer to encode

</member>
        <member name="M:seal.BinaryEncoder.decode_uint64(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::uint64_t.
        Mathematically this amounts to evaluating the input polynomial at X=2.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if the output does not fit in std::uint64_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BinaryEncoder.decode_uint32(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Decodes a plaintext polynomial and returns the result as std::uint32_t.
        Mathematically this amounts to evaluating the input polynomial at X=2.

        @param[in] poly The polynomial to be decoded
        @throws std::invalid_argument if the output does not fit in std::uint32_t (#ifdef THROW_ON_DECODER_OVERFLOW)

</member>
        <member name="M:seal.BinaryEncoder.encode(System.UInt64,seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode
        @param[out] destination The polynomial to overwrite with the encoding

</member>
        <member name="M:seal.BinaryEncoder.encode(System.UInt64)">
        Encodes an unsigned integer (represented by std::uint64_t) into a plaintext polynomial.

        @param[in] value The unsigned integer to encode

</member>
        <member name="M:seal.BinaryEncoder.Dispose">
        Creates a copy of a BinaryEncoder.

        @param[in] copy The BinaryEncoder to copy from

        Creates a new BinaryEncoder by moving an old one.

        @param[in] source The BinaryEncoder to move from

Destroys the BinaryEncoder.

</member>
        <member name="M:seal.BinaryEncoder.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a BinaryEncoder object. The constructor takes as input a reference
        to the plaintext modulus (represented by BigUInt). Optionally, the user can 
        give a reference to a MemoryPoolHandle object to use a custom memory pool
        instead of the global memory pool (default).

        @param[in] plain_modulus The plaintext modulus (represented by BigUInt)
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if plain_modulus is not at least 2
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.BinaryEncoder">
    Encodes integers into plaintext polynomials that Encryptor can encrypt. An instance of
    the BinaryEncoder class converts an integer into a plaintext polynomial by placing its
    binary digits as the coefficients of the polynomial. Decoding the integer amounts to
    evaluating the plaintext polynomial at X=2.

    Addition and multiplication on the integer side translate into addition and multiplication
    on the encoded plaintext polynomial side, provided that the length of the polynomial
    never grows to be of the size of the polynomial modulus (poly_modulus), and that the
    coefficients of the plaintext polynomials appearing throughout the computations never
    experience coefficients larger than the plaintext modulus (plain_modulus).

    @par Negative Integers
    Negative integers are represented by using -1 instead of 1 in the binary representation,
    and the negative coefficients are stored in the plaintext polynomials as unsigned integers
    that represent them modulo the plaintext modulus. Thus, for example, a coefficient of -1
    would be stored as a polynomial coefficient plain_modulus-1.

    @par Decoding Overflow
    In many cases it is a bad idea to throw an exception when decoding fails due to an overflow
    condition, e.g. decode_uint32 is given a polynomial that decodes into a value larger than
    32 bits. If such an exception is not handled silently, a malicious observer might notice
    this happening, and be able to extract one bit of information about the secret key.
    Thus, by default, the decoder functions do not throw exceptions in cases of overflow.
    However, the throws are automatically enabled in debug mode in Visual Studio, and more
    generally they can be directly controlled by the preprocessor define THROW_ON_DECODER_OVERFLOW
    in the file util/defines.h.

    @see BinaryFractionalEncoder for encoding real numbers.
    @see BalancedEncoder for encoding using base-b representation for b greater than 2.
    @see IntegerEncoder for a common interface to all integer encoders.

</member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Negate(Microsoft.Research.SEAL.Simulation)">
            <summary>Simulates noise budget consumption in Evaluator::Negate() and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to negate</param>
            <exception cref="T:System.ArgumentNullException">if simulation is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.Negate(Microsoft.Research.SEAL.BigPolyArray)">See Evaluator::Negate() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Exponentiate(Microsoft.Research.SEAL.Simulation,System.UInt64)">
            <summary>Simulates noise budget consumption in Evaluator::Exponentiate() and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to raise to a power</param>
            <param name="exponent">The power to raise the <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to</param>
            <exception cref="T:System.ArgumentNullException">if simulation is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <exception cref="T:System.ArgumentException">if exponent is zero</exception>
            <seealso>See Evaluator::Exponentiate() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.SubPlain(Microsoft.Research.SEAL.Simulation,System.Int32,System.UInt64)">
            <summary>Simulates noise budget consumption in Evaluator::SubPlain() and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to subtract from</param>
            <param name="plainMaxCoeffCount">An upper bound on the number of non-zero coefficients in the plain polynomial to multiply</param>
            <param name="plainMaxAbsValue">An upper bound (represented by System::UInt64) on the absolute value of coefficients 
                in the plain polynomial to subtract</param>
            <exception cref="T:System.ArgumentNullException">if simulation is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is out of range</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.SubPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">See Evaluator::SubPlain() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.SubPlain(Microsoft.Research.SEAL.Simulation,System.Int32,Microsoft.Research.SEAL.BigUInt)">
            <summary>Simulates noise budget consumption in Evaluator::SubPlain() and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to subtract from</param>
            <param name="plainMaxCoeffCount">An upper bound on the number of non-zero coefficients in the plain polynomial to multiply</param>
            <param name="plainMaxAbsValue">An upper bound (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) on the absolute value of coefficients in the
plain polynomial to subtract</param>
            <exception cref="T:System.ArgumentNullException">if simulation or plainMaxAbsValue is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is out of range</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.SubPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">See Evaluator::SubPlain() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.AddPlain(Microsoft.Research.SEAL.Simulation,System.Int32,System.UInt64)">
            <summary>Simulates noise budget consumption in Evaluator::AddPlain() and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to add to</param>
            <param name="plainMaxCoeffCount">An upper bound on the number of non-zero coefficients in the plain polynomial to multiply</param>
            <param name="plainMaxAbsValue">An upper bound (represented by System::UInt64) on the absolute value of coefficients 
                in the plain polynomial to add</param>
            <exception cref="T:System.ArgumentNullException">if simulation is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is out of range</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.AddPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">See Evaluator::AddPlain() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.AddPlain(Microsoft.Research.SEAL.Simulation,System.Int32,Microsoft.Research.SEAL.BigUInt)">
            <summary>Simulates noise budget consumption in Evaluator::AddPlain() and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to add to</param>
            <param name="plainMaxCoeffCount">An upper bound on the number of non-zero coefficients in the plain polynomial to multiply</param>
            <param name="plainMaxAbsValue">An upper bound (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) on the absolute value of coefficients in the
plain polynomial to add</param>
            <exception cref="T:System.ArgumentNullException">if simulation or plainMaxAbsValue is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is out of range</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.AddPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">See Evaluator::AddPlain() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.MultiplyPlain(Microsoft.Research.SEAL.Simulation,System.Int32,System.UInt64)">
            <summary>Simulates noise budget consumption in Evaluator::MultiplyPlain() given an upper bound for the maximum number of
                non-zero coefficients and an upper bound for their absolute value (represented by System::UInt64) in the encoding of the
                plaintext multiplier and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to multiply</param>
            <param name="plainMaxCoeffCount">An upper bound on the number of non-zero coefficients in the plain polynomial to multiply</param>
            <param name="plainMaxAbsValue">An upper bound (represented by System::UInt64) on the absolute value of coefficients in the
                plain polynomial to multiply</param>
            <exception cref="T:System.ArgumentNullException">if simulation is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is out of range</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount or plainMaxAbsValue is zero</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.MultiplyPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">See Evaluator::MultiplyPlain() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.MultiplyPlain(Microsoft.Research.SEAL.Simulation,System.Int32,Microsoft.Research.SEAL.BigUInt)">
            <summary>Simulates noise budget consumption in Evaluator::MultiplyPlain() given an upper bound for the maximum number of
                non-zero coefficients and an upper bound for their absolute value (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) in the encoding of the
                plaintext multiplier and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to multiply</param>
            <param name="plainMaxCoeffCount">An upper bound on the number of non-zero coefficients in the plain polynomial to multiply</param>
            <param name="plainMaxAbsValue">An upper bound (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) on the absolute value of coefficients in the
                plain polynomial to multiply</param>
            <exception cref="T:System.ArgumentNullException">if simulation or plainMaxAbsValue is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is out of range</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount or plainMaxAbsValue is zero</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.MultiplyPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">See Evaluator::MultiplyPlain() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Sub(Microsoft.Research.SEAL.Simulation,Microsoft.Research.SEAL.Simulation)">
            <summary>Simulates noise budget consumption in Evaluator::Sub() and returns the result.</summary>
            <param name="simulation1">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to subtract from</param>
            <param name="simulation2">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to subtract</param>
            <exception cref="T:System.ArgumentNullException">if simulation1 or simulation2 is null</exception>
            <exception cref="T:System.ArgumentException">if simulation1 and simulation2 were constructed with different encryption
parameters</exception>
            <exception cref="T:System.ArgumentException">if simulation1 or simulation2 has Size less than 2</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.Sub(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">See Evaluator::Sub() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Add(Microsoft.Research.SEAL.Simulation,Microsoft.Research.SEAL.Simulation)">
            <summary>Simulates noise budget consumption in Evaluator::Add() and returns the result.</summary>
            <param name="simulation1">The first <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to add</param>
            <param name="simulation2">The second <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to add</param>
            <exception cref="T:System.ArgumentNullException">if simulation1 or simulation2 is null</exception>
            <exception cref="T:System.ArgumentException">if simulation1 and simulation2 were constructed with different encryption
parameters</exception>
            <exception cref="T:System.ArgumentException">if simulation1 or simulation2 has Size less than 2</exception>
            <seealso cref="M:Microsoft.Research.SEAL.SimulationEvaluator.Add(Microsoft.Research.SEAL.Simulation,Microsoft.Research.SEAL.Simulation)">See Evaluator::Add() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Square(Microsoft.Research.SEAL.Simulation)">
            <summary>Simulates noise budget consumption in Evaluator::Square() and returns the result.</summary>
            <param name="simulation">The Simulation object to square</param>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.Square(Microsoft.Research.SEAL.BigPolyArray)">See Evaluator::Square() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Multiply(Microsoft.Research.SEAL.Simulation,Microsoft.Research.SEAL.Simulation)">
            <summary>Simulates noise budget consumption in Evaluator::Multiply() and returns the result.</summary>
            <param name="simulation1">The first <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to multiply</param>
            <param name="simulation2">The second <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to multiply</param>
            <exception cref="T:System.ArgumentNullException">if simulation1 or simulation2 is null</exception>
            <exception cref="T:System.ArgumentException">if simulation1 and simulation2 were constructed with different encryption
parameters</exception>
            <exception cref="T:System.ArgumentException">if simulation1 or simulation2 has Size less than 2</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.Multiply(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">See Evaluator::Multiply() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Relinearize(Microsoft.Research.SEAL.Simulation)">
            <summary>Simulates noise budget consumption in Evaluator::Relinearize() and returns the result.</summary>
            <param name="simulation">The <see cref="T:Microsoft.Research.SEAL.Simulation" /> object to relinearize</param>
            <exception cref="T:System.ArgumentNullException">if simulation is null</exception>
            <exception cref="T:System.ArgumentException">if simulation has Size less than 2</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Evaluator.Relinearize(Microsoft.Research.SEAL.BigPolyArray)">See Evaluator::Relinearize() for the corresponding operation on ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.GetFresh(Microsoft.Research.SEAL.EncryptionParameters,System.Int32,System.UInt64)">
            <summary>Creates a Simulation object corresponding to a freshly encrypted ciphertext.</summary>
            <remarks>
                Creates a Simulation object corresponding to a freshly encrypted ciphertext. The noise is estimated
                based on the given encryption parameters, and size parameters of a virtual input plaintext polynomial,
                namely an upper bound plainMaxCoeffCount on the number of non-zero coefficients in the polynomial,
                and an upper bound plainMaxAbsValue (represented by System::UInt64) on the absolute value (modulo the 
                plaintext modulus) of the polynomial coefficients.
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="plainMaxCoeffCount">An upper bound on the number of non-zero coefficients in the underlying plaintext</param>
            <param name="plainMaxAbsValue">An upper bound on the absolute value of the coefficients in the underlying plaintext</param>
            <exception cref="T:System.ArgumentNullException">if parms is null</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is negative or bigger than the degree of the polynomial modulus</exception>
            <exception cref="T:System.ArgumentException">if plainMaxAbsValue is bigger than the plaintext modulus divided by 2</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.GetFresh(Microsoft.Research.SEAL.EncryptionParameters,System.Int32,Microsoft.Research.SEAL.BigUInt)">
            <summary>Creates a Simulation object corresponding to a freshly encrypted ciphertext.</summary>
            <remarks>
Creates a Simulation object corresponding to a freshly encrypted ciphertext. The noise is estimated
based on the given encryption parameters, and size parameters of a virtual input plaintext polynomial, 
namely an upper bound plainMaxCoeffCount on the number of non-zero coefficients in the polynomial, 
and an upper bound plainMaxAbsValue (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />) on the absolute value 
(modulo the plaintext modulus) of the polynomial coefficients.
</remarks>
            <param name="parms">The encryption parameters</param>
            <param name="plainMaxCoeffCount">An upper bound on the number of non-zero coefficients in the underlying plaintext</param>
            <param name="plainMaxAbsValue">An upper bound on the absolute value of the coefficients in the underlying plaintext</param>
            <exception cref="T:System.ArgumentNullException">if parms or plainMaxAbsValue is null</exception>
            <exception cref="T:System.ArgumentException">if plainMaxCoeffCount is negative or bigger than the degree of the polynomial modulus</exception>
            <exception cref="T:System.ArgumentException">if plainMaxAbsValue is bigger than the plaintext modulus divided by 2</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Finalize">
            <summary>Destroys the SimulationEvaluator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.Dispose">
            <summary>Destroys the SimulationEvaluator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.#ctor(Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a new SimulationEvaluator.</summary>
            <remarks>
                Creates a new SimulationEvaluator. The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use
                a custom memory pool instead of the global memory pool (default).
                </remarks>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if pool is null</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.SimulationEvaluator.#ctor">
            <summary>Creates a new SimulationEvaluator.</summary>
        </member>
        <member name="T:Microsoft.Research.SEAL.SimulationEvaluator">
            <summary>Manipulates instances of Simulation with a public API similar to how Evaluator manipulates ciphertexts.</summary>
            <remarks>
                <para>
Manipulates instances of <see cref="T:Microsoft.Research.SEAL.Simulation" /> with a public API similar to how <see cref="T:Microsoft.Research.SEAL.Evaluator" /> 
manipulates ciphertexts. This makes existing code easy to run on Simulation objects instead of running it 
on actual encrypted data.
</para>
                <para>
Simulation objects model the invariant noise budget in a ciphertext based on given encryption parameters.
When performing homomorphic operations on encrypted data, the quality of the ciphertexts will degrade,
i.e. the invariant noise budget will be consumed, until at a certain point the budget will reach 0, and
decryption will fail to work. The Simulation object together with SimulationEvaluator can help the user
understand how the noise budget is consumed in different homomorphic operations, and to adjust the
encryption parameters accordingly.
</para>
                <para>
                    <see cref="T:Microsoft.Research.SEAL.SimulationEvaluator" /> allows the user to simulate the effect of homomorphic operations on 
the inherent noise in encrypted data. These homomorphic operations include addition, multiplication, 
subtraction, negation, etc., and the result is always a new Simulation object whose inherent noise is 
obtained using average-case analysis of the encryption scheme.
</para>
                <para>
The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
correctly.
</para>
                <para>
The SimulationEvaluator class is not thread-safe and a separate SimulationEvaluator instance is needed for each
potentially concurrent usage.
</para>
            </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.Simulation">See Simulation for the object modeling the noise in ciphertexts.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Simulation.#ctor(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a copy of a C++ Simulation.</summary>
            <remarks>
Creates a copy of a C++ Simulation. The created Simulation will have the same inherent noise as the original.
</remarks>
            <param name="copy">The Simulation to copy from</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.Simulation.GetSimulation">
            <summary>Returns a reference to the underlying C++ Simulation.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Simulation.Finalize">
            <summary>Destroys the Simulation.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Simulation.Dispose">
            <summary>Destroys the Simulation.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.Simulation.Size">
            <summary>Returns the size of the ciphertext whose noise is modeled by the simulation.</summary>
            <seealso>See BigPolyArray::Size for the corresponding property on BigPolyArray objects.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Simulation.Decrypts(System.Int32)">
            <summary>Returns true or false depending on whether the encryption parameters were large enough to support 
                the performed homomorphic operations.</summary>
            <remarks>
                Returns true or false depending on whether the encryption parameters were large enough to support the performed
                homomorphic operations. The budgetGap parameter parameter can be used to ensure that a certain
                amount of noise budget remains unused.
                </remarks>
            <param name="budgetGap">The amount of noise budget (bits) that should remain unused</param>
            <exception cref="T:System.ArgumentException">if budgetGap is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Simulation.Decrypts">
            <summary>Returns true or false depending on whether the encryption parameters were large enough to support 
the performed homomorphic operations.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.Simulation.InvariantNoiseBudget">
            <summary>Returns the invariant noise budget that is being simulated.</summary>
            <remarks>
                Returns the invariant noise budget that is being simulated. If the returned value is less than or 
                equal to 0, the encryption parameters used are possibly not large enough to support the performed 
                homomorphic operations.
                </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.Simulation.Set(Microsoft.Research.SEAL.Simulation)">
            <summary>Overwrites the Simulation with the value of the specified Simulation.</summary>
            <param name="assign">The Simulation whose value should be assigned to the current Simulation</param>
            <exception cref="T:System.ArgumentNullException">If assign is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Simulation.#ctor(Microsoft.Research.SEAL.EncryptionParameters,System.Int32,System.Int32)">
            <summary>Creates a simulation of a ciphertext encrypted with the specified encryption parameters and 
                given invariant noise budget.</summary>
            <remarks>
                Creates a simulation of a ciphertext encrypted with the specified encryption parameters and
                given invariant noise budget. The given noise budget must be at least zero, and at most the 
                significant bit count of the coefficient modulus minus two.
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="noiseBudget">The invariant noise budget of the created ciphertext</param>
            <param name="ciphertextSize">The size of the created ciphertext</param>
            <exception cref="T:System.ArgumentNullException">if parms is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <exception cref="T:System.ArgumentException">if noiseBudget is not in the valid range</exception>
            <exception cref="T:System.ArgumentException">if ciphertextSize is less than 2</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
                parameters.</seealso>
        </member>
        <member name="T:Microsoft.Research.SEAL.Simulation">
            <summary>Models the invariant noise budget in a ciphertext based on given EncryptionParameters object.</summary>
            <remarks>
                <para>
            Models the invariant noise budget in a ciphertext based on given <see cref="T:Microsoft.Research.SEAL.EncryptionParameters" /> object.
            When performing arithmetic operations on encrypted data, the quality of the ciphertexts will degrade,
            i.e. the invariant noise budget will be consumed, until at a certain point the budget will reach 0, and
            decryption will fail to work. The Simulation object together with <see cref="T:Microsoft.Research.SEAL.SimulationEvaluator" /> can 
            help the user understand how the invariant noise budget is consumed in different homomorphic operations, 
            and to adjust the encryption parameters accordingly.
            </para>
                <para>
            Instances of Simulation can be manipulated using <see cref="T:Microsoft.Research.SEAL.SimulationEvaluator" />, which has a public API similar 
            to Evaluator, making existing code easy to run on simulations instead of running it on actual encrypted data. In 
            other words, using <see cref="T:Microsoft.Research.SEAL.SimulationEvaluator" />, simulations can be added, multiplied, subtracted, negated, etc., 
            and the result is always a new Simulation object whose noise budget is obtained using  heuristic worst-case analysis 
            of the noise behavior in the encryption scheme.
            </para>
                <para>
            The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
            a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
            of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
            the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
            invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
            starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
            computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
            correctly.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.SimulationEvaluator">See SimulationEvaluator for manipulating instances of Simulation.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.GetEvaluator">
            <summary>Returns a reference to the underlying C++ Evaluator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Finalize">
            <summary>Destroys the Evaluator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Dispose">
            <summary>Destroys the Evaluator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.TransformFromNTT(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Transform a ciphertext from NTT domain to coefficient domain, with respect to the coefficient
                modulus.</summary>
            <remarks>
                Transform a ciphertext from NTT domain to coefficient domain, with respect to the coefficient
                modulus. This function performs David Harvey's inverse NTT separately on each of the polynomials
                in the given <see cref="T:Microsoft.Research.SEAL.BigPolyArray" />.
                </remarks>
            <param name="encryptedNTT">The ciphertext to transform</param>
            <exception cref="T:System.InvalidOperationException">if the encryption parameters do not support NTT</exception>
            <exception cref="T:System.ArgumentException">if encryptedNTT is not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.TransformToNTT(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Transform a ciphertext from coefficient domain to NTT domain, with respect to the coefficient
                modulus.</summary>
            <remarks>
                Transform a ciphertext from coefficient domain to NTT domain, with respect to the coefficient
                modulus. This function performs David Harvey's NTT separately on each of the polynomials
                in the given <see cref="T:Microsoft.Research.SEAL.BigPolyArray" />.
                </remarks>
            <param name="encrypted">The ciphertext to transform</param>
            <exception cref="T:System.InvalidOperationException">if the encryption parameters do not support NTT</exception>
            <exception cref="T:System.ArgumentException">if encrypted is not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.TransformFromNTT(Microsoft.Research.SEAL.BigPoly)">
            <summary>Transform a plaintext from NTT domain to coefficient domain, with respect to the coefficient
                modulus.</summary>
            <remarks>
                Transform a plaintext from NTT domain to coefficient domain, with respect to the coefficient
                modulus. This function first performs David Harvey's inverse NTT, and follows it by an inverse
                of the coefficient embedding performed by <see cref="M:Microsoft.Research.SEAL.Evaluator.TransformToNTT(Microsoft.Research.SEAL.BigPoly)" />. 
                </remarks>
            <param name="plainNTT">The plaintext to transform</param>
            <exception cref="T:System.InvalidOperationException">if the encryption parameters do not support NTT</exception>
            <exception cref="T:System.ArgumentException">if plainNTT is not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.TransformToNTT(Microsoft.Research.SEAL.BigPoly)">
            <summary>Transform a plaintext from coefficient domain to NTT domain, with respect to the coefficient 
modulus.</summary>
            <remarks>
Transform a plaintext from coefficient domain to NTT domain, with respect to the coefficient 
modulus. This function first embeds integers modulo the plaintext modulus to integers modulo 
the coefficient modulus, and then performs David Harvey's NTT on the resulting polynomial.
</remarks>
            <param name="plain">The plaintext to transform</param>
            <exception cref="T:System.InvalidOperationException">if the encryption parameters do not support NTT</exception>
            <exception cref="T:System.ArgumentException">if plain is not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Exponentiate(Microsoft.Research.SEAL.BigPolyArray,System.UInt64)">
            <summary>Raises a ciphertext to the specified power and returns the result.</summary>
            <remarks>
                <para>
Raises a ciphertext to the specified power and returns the result. Relinearization is performed 
after every multiplication, so enough encryption keys must have been given to the constructor 
of the Evaluator.
</para>
                <para>
Exponentiation to power 0 is not allowed and will result in the library throwing an invalid argument
exception. The reason behind this design choice is that the result should be a fresh encryption
of 1, but creating fresh encryptions should not be something this class does. Instead the user
should separately handle the cases where the exponent is 0.
</para>
            </remarks>
            <param name="encrypted">The ciphertext to raise to a power</param>
            <param name="exponent">The power to raise the ciphertext to</param>
            <exception cref="T:System.ArgumentException">if the ciphertext is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if exponent is zero</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Exponentiate(Microsoft.Research.SEAL.BigPolyArray,System.UInt64,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Raises a ciphertext to the specified power and stores the result in the destination parameter.</summary>
            <remarks>
                <para>
Raises a ciphertext to the specified power and stores the result in the destination parameter. 
Relinearization is performed after every multiplication, so enough encryption keys must have 
been given to the constructor of the Evaluator.
</para>
                <para>
Exponentiation to power 0 is not allowed and will result in the library throwing an invalid argument
exception. The reason behind this design choice is that the result should be a fresh encryption
of 1, but creating fresh encryptions should not be something this class does. Instead the user
should separately handle the cases where the exponent is 0.
</para>
            </remarks>
            <param name="encrypted">The ciphertext to raise to a power</param>
            <param name="exponent">The power to raise the ciphertext to</param>
            <param name="destination">The ciphertext to overwrite with the exponentiation result</param>
            <exception cref="T:System.ArgumentException">if the ciphertext is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if exponent is zero</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.MultiplyMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.Ciphertext})">
            <summary>Multiplies a list of ciphertexts together and returns the result.</summary>
            <remarks>
                <para>
                Multiplies a list of ciphertexts together and returns the result. Relinearization is performed after
                every multiplication, so enough encryption keys must have been given to the constructor of the Evaluator.
                </para>
            </remarks>
            <param name="encrypteds">The list of ciphertexts to multiply</param>
            <exception cref="T:System.ArgumentException">if the encrypteds list is empty</exception>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid ciphertexts for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypteds or any of its elements is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.MultiplyMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.Ciphertext},Microsoft.Research.SEAL.Ciphertext)">
            <summary>Multiplies a list of ciphertexts together and stores the result in the destination parameter.</summary>
            <remarks>
                <para>
                Multiplies a list of ciphertexts together and stores the result in the destination parameter. Relinearization
                is performed after every multiplication, so enough encryption keys must have been given to the constructor
                of the Evaluator.
                </para>
            </remarks>
            <param name="encrypteds">The list of ciphertexts to multiply</param>
            <param name="destination">The ciphertext to overwrite with the multiplication result</param>
            <exception cref="T:System.ArgumentException">if the encrypteds list is empty</exception>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid ciphertexts for the encryption parameters</exception>.
                <exception cref="T:System.ArgumentNullException">if encrypteds or any of its elements is null</exception><exception cref="T:System.ArgumentNullException">if destination is null</exception></member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.MultiplyMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.BigPolyArray})">
            <summary>Multiplies a list of ciphertexts together and returns the result.</summary>
            <remarks>
                <para>
                Multiplies a list of ciphertexts together and returns the result. Relinearization is performed after 
                every multiplication, so enough encryption keys must have been given to the constructor of the Evaluator.
                </para>
            </remarks>
            <param name="encrypteds">The list of ciphertexts to multiply</param>
            <exception cref="T:System.ArgumentException">if the encrypteds list is empty</exception>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid ciphertexts for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypteds or any of its elements is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.MultiplyMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.BigPolyArray},Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Multiplies a list of ciphertexts together and stores the result in the destination parameter.</summary>
            <remarks>
                <para>
                Multiplies a list of ciphertexts together and stores the result in the destination parameter. Relinearization 
                is performed after every multiplication, so enough encryption keys must have been given to the constructor 
                of the Evaluator.
                </para>
            </remarks>
            <param name="encrypteds">The list of ciphertexts to multiply</param>
            <param name="destination">The ciphertext to overwrite with the multiplication result</param>
            <exception cref="T:System.ArgumentException">if the encrypteds list is empty</exception>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid ciphertexts for the encryption parameters</exception>.
                <exception cref="T:System.ArgumentNullException">if encrypteds or any of its elements is null</exception><exception cref="T:System.ArgumentNullException">if destination is null</exception></member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.MultiplyPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">
            <summary>Multiplies a ciphertext with a plaintext, and returns the result.</summary>
            <remarks>
                <para>
                Multiplies a ciphertext with a plaintext, and returns the result. The plaintext must have a
                significant coefficient count smaller than the coefficient count specified by the encryption parameters, and with
                coefficient values less-than the plain modulus (<see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />).
                </para>
                <para>
                Multiplying by a plaintext 0 is not allowed and will result in the library throwing an invalid
                argument exception. The reason behind this design choice is that the result should
                be a fresh encryption of 0, but creating fresh encryptions should not be something
                this class does. Instead the user should separately handle the cases where the
                plain multiplier is 0.
                </para>
            </remarks>
            <param name="encrypted">The ciphertext to multiply</param>
            <param name="plain">The plaintext to multiply</param>
            <exception cref="T:System.ArgumentException">if encrypted is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if the plain polynomial's significant coefficient count or coefficient
                values are too large to represent with the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if the plaintext multiplier is zero</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted or plain is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.MultiplyPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Multiplies a ciphertext with a plaintext, and stores the result in the destination
                parameter.</summary>
            <remarks>
                <para>
                Multiplies a ciphertext with a plaintext, and stores the result in the destination parameter. 
                The plaintext must have a significant coefficient count smaller than the coefficient
                count specified by the encryption parameters, and with coefficient values less-than the plain modulus
                (<see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />).
                </para>
                <para>
                Multiplying by a plaintext 0 is not allowed and will result in the library throwing an invalid
                argument exception. The reason behind this design choice is that the result should
                be a fresh encryption of 0, but creating fresh encryptions should not be something
                this class does. Instead the user should separately handle the cases where the
                plain multiplier is 0.
                </para>
            </remarks>
            <param name="encrypted">The ciphertext to multiply</param>
            <param name="plain">The plaintext to multiply</param>
            <param name="destination">The ciphertext to overwrite with the multiplication result</param>
            <exception cref="T:System.ArgumentException">if encrypted is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if the plain polynomial's significant coefficient count or coefficient
                values are too large to represent with the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if the plaintext multiplier is zero</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted, plain, or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.SubPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">
            <summary>Subtracts a ciphertext with a plaintext, and returns the result.</summary>
            <remarks>
                Subtracts a ciphertext with a plaintext, and returns the result. The plaintext must have a
                significant coefficient count smaller than the coefficient count specified by the encryption parameters, and with
                coefficient values less-than the plain modulus (<see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />).
                </remarks>
            <param name="encrypted">The ciphertext to subtract</param>
            <param name="plain">The plaintext to subtract</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if the plain polynomial's significant coefficient count or coefficient
                values are too large to represent with the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted or plain is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.SubPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Subtracts a ciphertext with a plaintext, and stores the result in the destination
                parameter.</summary>
            <remarks>
                Subtracts a ciphertext with a plaintext, and stores the result in the destination parameter.
                The plaintext must have a significant coefficient count smaller than the coefficient
                count specified by the encryption parameters, and with coefficient values less-than the plain modulus
                (<see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />).
                </remarks>
            <param name="encrypted">The ciphertext to subtract</param>
            <param name="plain">The plaintext to subtract</param>
            <param name="destination">The ciphertext to overwrite with the subtraction result</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if the plain polynomial's significant coefficient count or coefficient
                values are too large to represent with the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted, plain, or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.AddPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly)">
            <summary>Adds a ciphertext with a plaintext, and returns the result.</summary>
            <remarks>
                Adds a ciphertext with a plaintext, and returns the result. The plaintext must have a
                significant coefficient count smaller than the coefficient count specified by the encryption parameters, and with
                coefficient values less-than the plain modulus (<see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />).
                </remarks>
            <param name="encrypted">The ciphertext to add</param>
            <param name="plain">The plaintext to add</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if the plain polynomial's significant coefficient count or coefficient
                values are too large to represent with the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted or plain is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.AddPlain(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPoly,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Adds a ciphertext with a plaintext, and stores the result in the destination parameter.</summary>
            <remarks>
                Adds a ciphertext with a plaintext, and stores the result in the destination parameter. The plaintext must 
                have a significant coefficient count smaller than the coefficient count specified by the encryption parameters, 
                and with coefficient values less-than the plain modulus (<see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />).
                </remarks>
            <param name="encrypted">The ciphertext to add</param>
            <param name="plain">The plaintext to add</param>
            <param name="destination">The ciphertext to overwrite with the addition result</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if the plain polynomial's significant coefficient count or coefficient
                values are too large to represent with the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted, plain, or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Relinearize(Microsoft.Research.SEAL.BigPolyArray,System.Int32)">
            <summary>Relinearizes a ciphertext and returns the result.</summary>
            <param name="encrypted">The ciphertext to relinearize</param>
            <exception cref="T:System.ArgumentException">if the ciphertext is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if destinationSize is less than 2 or too large</exception>
            <exception cref="T:System.ArgumentException">if not enough evaluation keys have been generated</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Relinearize(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Relinearizes a ciphertext and returns the result.</summary>
            <param name="encrypted">The ciphertext to relinearize</param>
            <exception cref="T:System.ArgumentException">if the ciphertext is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if not enough evaluation keys have been generated</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Relinearize(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray,System.Int32)">
            <summary>Relinearizes a ciphertext and stores the result in the destination parameter.</summary>
            <param name="encrypted">The ciphertext to relinearize</param>
            <param name="destination">The ciphertext to overwrite with the relinearized result</param>
            <param name="destinationSize">The size of the output ciphertext</param>
            <exception cref="T:System.ArgumentException">if the ciphertext is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if destinationSize is less than 2 or too large</exception>
            <exception cref="T:System.ArgumentException">if not enough evaluation keys have been generated</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Relinearize(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Relinearizes a ciphertext and stores the result in the destination parameter.</summary>
            <param name="encrypted">The ciphertext to relinearize</param>
            <param name="destination">The ciphertext to overwrite with the relinearized result</param>
            <exception cref="T:System.ArgumentException">if the ciphertext is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentException">if not enough evaluation keys have been generated</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Square(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Squares a ciphertext and returns the result.</summary>
            <param name="encrypted">The ciphertext to square</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Square(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Squares a ciphertext and stores the result in the destination parameter.</summary>
            <param name="encrypted">The ciphertext to square</param>
            <param name="destination">The ciphertext to overwrite with the result</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Multiply(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Multiplies two ciphertexts and returns the result.</summary>
            <param name="encrypted1">The first ciphertext to multiply</param>
            <param name="encrypted2">The second ciphertext to multiply</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted1 or encrypted2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Multiply(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Multiplies two ciphertexts and stores the result in the destination parameter.</summary>
            <param name="encrypted1">The first ciphertext to multiply</param>
            <param name="encrypted2">The second ciphertext to multiply</param>
            <param name="destination">The ciphertext to overwrite with the multiplication result</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted1, encrypted2, or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Sub(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Subtracts two ciphertexts and returns the result.</summary>
            <param name="encrypted1">The ciphertext to subtract from</param>
            <param name="encrypted2">The ciphertext to subtract</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted1 or encrypted2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Sub(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Subtracts two ciphertexts and stores the result in the destination parameter.</summary>
            <param name="encrypted1">The ciphertext to subtract from</param>
            <param name="encrypted2">The ciphertext to subtract</param>
            <param name="destination">The ciphertext to overwrite with the subtraction result</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted1, encrypted2, or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.AddMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.Ciphertext})">
            <summary>Adds together an number of ciphertexts stored as elements of a list and returns the result.</summary>
            <param name="encrypteds">The ciphertexts to add</param>
            <exception cref="T:System.ArgumentNullException">if encrypteds or any of its elements is null</exception>
            <exception cref="T:System.ArgumentException">if encrypteds is empty</exception>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.AddMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.Ciphertext},Microsoft.Research.SEAL.Ciphertext)">
            <summary>Adds together an number of ciphertexts stored as elements of a list and stores the result
in the destination parameter.</summary>
            <param name="encrypteds">The ciphertexts to add</param>
            <param name="destination">The ciphertext to overwrite with the addition result</param>
            <exception cref="T:System.ArgumentNullException">if encrypteds or any of its elements is null</exception>
            <exception cref="T:System.ArgumentException">if encrypteds is empty</exception>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.AddMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.BigPolyArray})">
            <summary>Adds together an number of ciphertexts stored as elements of a list and returns the result.</summary>
            <param name="encrypteds">The ciphertexts to add</param>
            <exception cref="T:System.ArgumentNullException">if encrypteds or any of its elements is null</exception>
            <exception cref="T:System.ArgumentException">if encrypteds is empty</exception>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.AddMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.BigPolyArray},Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Adds together an number of ciphertexts stored as elements of a list and stores the result
in the destination parameter.</summary>
            <param name="encrypteds">The ciphertexts to add</param>
            <param name="destination">The ciphertext to overwrite with the addition result</param>
            <exception cref="T:System.ArgumentNullException">if encrypteds or any of its elements is null</exception>
            <exception cref="T:System.ArgumentException">if encrypteds is empty</exception>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Add(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Adds two ciphertexts and returns the result.</summary>
            <param name="encrypted1">The first ciphertext to add</param>
            <param name="encrypted2">The second ciphertexct to add</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted1 or encrypted2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Add(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Adds two ciphertexts and stores the result in the destination parameter.</summary>
            <param name="encrypted1">The first ciphertext to add</param>
            <param name="encrypted2">The second ciphertexct to add</param>
            <param name="destination">The ciphertext to overwrite with the addition result</param>
            <exception cref="T:System.ArgumentException">if the ciphertexts are not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted1, encrypted2, or destination is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Negate(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Negates a ciphertext and returns the result.</summary>
            <param name="encrypted">The ciphertext to negate</param>
            <exception cref="T:System.ArgumentException">if the ciphertext is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.Negate(Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Negates a ciphertext and stores the result in the destination parameter.</summary>
            <param name="encrypted">The ciphertext to negate</param>
            <param name="destination">The ciphertext to overwrite with the negated result</param>
            <exception cref="T:System.ArgumentException">if the ciphertext is not valid for the encryption parameters</exception>
            <exception cref="T:System.ArgumentNullException">if encrypted or destination is null</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.Evaluator.EvaluationKeys">
            <summary>Returns the evaluation keys used by the Evaluator.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.#ctor(Microsoft.Research.SEAL.Evaluator)">
            <summary>Creates a copy of a Evaluator.</summary>
            <param name="copy">The Evaluator to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates an Evaluator instance initialized with the specified encryption parameters.</summary>
            <remarks>
                Creates an Evaluator instance initialized with the specified encryption parameters. The user can give 
                a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool instead of the global memory pool (default).
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if parms or pool is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.#ctor(Microsoft.Research.SEAL.EncryptionParameters)">
            <summary>Creates an Evaluator instance initialized with the specified encryption parameters.</summary>
            <param name="parms">The encryption parameters</param>
            <exception cref="T:System.ArgumentNullException">if parms is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
parameters.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.EvaluationKeys,Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates an Evaluator instance initialized with the specified encryption parameters and evaluation
                keys.</summary>
            <remarks>
                Creates an Evaluator instance initialized with the specified encryption parameters and evaluation
                keys. If no evaluation keys will be needed, one can simply pass a newly created empty instance of EvaluationKeys
                to the function. The user can give a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> object to use a custom memory pool instead
                of the global memory pool (default).
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="evaluationKeys">The evaluation keys</param>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if parms, evaluationKeys, or pool is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters or evaluation keys are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption parameters.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Evaluator.#ctor(Microsoft.Research.SEAL.EncryptionParameters,Microsoft.Research.SEAL.EvaluationKeys)">
            <summary>Creates an Evaluator instance initialized with the specified encryption parameters and evaluation
                keys.</summary>
            <remarks>
                Creates an Evaluator instance initialized with the specified encryption parameters and evaluation
                keys. If no evaluation keys will be needed, one can simply pass a newly created empty instance of EvaluationKeys 
                to the function.
                </remarks>
            <param name="parms">The encryption parameters</param>
            <param name="evaluationKeys">The evaluation keys</param>
            <exception cref="T:System.ArgumentNullException">if parms or evaluationKeys is null</exception>
            <exception cref="T:System.ArgumentException">if encryption parameters or evaluation keys are not valid</exception>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for more details on valid encryption
                parameters.</seealso>
        </member>
        <member name="T:Microsoft.Research.SEAL.Evaluator">
            <summary>Provides arithmetic functions for operating on ciphertexts.</summary>
            <remarks>
                <para>
            Provides arithmetic functions for operating on ciphertexts. The Add, Subtract, and Multiply function 
            variants allow both operands to be encrypted. The "Plain" variants allow one of the inputs to be 
            encrypted and the other unencrypted.
            </para>
                <para>
            Every valid ciphertext consists of at least two polynomials. Homomorphic multiplication increases
            the size of the ciphertext in such a way that if the input ciphertexts have size M and N, then the
            output ciphertext will have size M+N-1. The multiplication operation will require M*N polynomial
            multiplications to be performed. To read the current size of a ciphertext the user can use 
            <see cref="P:Microsoft.Research.SEAL.BigPolyArray.Size" />.
            </para>
                <para>
            A relinearization operation can be used to reduce the size of a ciphertext to any smaller size
            (but at least 2), potentially improving the performance of a subsequent multiplication using it.
            However, relinearization consumes the invariant noise budget in a ciphertext by an additive factor
            proportional to 2^DBC, and relinearizing from size K to L will require 2*(K-L)*[floor(log_2(CoeffModulus)/DBC)+1]
            polynomial multiplications, where DBC denotes the decomposition bit count set in the encryption parameters.
            Note that the larger the decomposition bit count is, the faster relinearization will be, but also the
            more invariant noise budget will be consumed.
            </para>
                <para>
            Relinearization requires the key generator to generate evaluation keys. More specifically, to relinearize
            a ciphertext of size K down to any size smaller than K (but at least 2), at least K-2 evaluation keys will
            be needed. These have to be given as an input parameter to the constructor of Evaluator.
            </para>
                <para>
            The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
            a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
            of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
            the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
            invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
            starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
            computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
            correctly.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.GetCiphertext">
            <summary>Returns a reference to the underlying C++ Ciphertext.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.#ctor(seal.Ciphertext!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of a C++ Ciphertext instance.</summary>
            <param name="value">The Ciphertext instance to copy from</param>
            <exception cref="T:System.ArgumentNullException">If copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.Finalize">
            <summary>Destroys the Ciphertext.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.Dispose">
            <summary>Destroys the Ciphertext.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.Load(System.IO.Stream)">
            <summary>Loads a Ciphertext from an input stream overwriting the current Ciphertext.</summary>
            <param name="stream">The stream to load the Ciphertext from</param>
            <exception cref="T:System.ArgumentNullException">if stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Ciphertext.Save(System.IO.Stream)">See Save() to save a Ciphertext.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.Save(System.IO.Stream)">
            <summary>Saves the Ciphertext to an output stream.</summary>
            <remarks>
                Saves the Ciphertext to an output stream. The output is in binary format and not human-readable.
                The output stream must have the "binary" flag set.
                </remarks>
            <param name="stream">The stream to save the Ciphertext to</param>
            <exception cref="T:System.ArgumentNullException">if stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.Ciphertext.Load(System.IO.Stream)">See Load() to load a saved Ciphertext.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.Ciphertext.Size">
            <summary>Returns the size of the ciphertext.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.op_Implicit(Microsoft.Research.SEAL.Ciphertext)~Microsoft.Research.SEAL.BigPolyArray">
            <summary>Returns a copy of the underlying polynomial array.</summary>
            <param name="ciphertext">The ciphertext object</param>
            <exception cref="T:System.ArgumentNullException">if ciphertext is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.Set(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Sets the current Ciphertext to wrap a given <see cref="T:Microsoft.Research.SEAL.BigPolyArray" /> by creating a copy of it.</summary>
            <param name="polyArray">The polynomial array to copy from</param>
            <exception cref="T:System.ArgumentNullException">if polyArray is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.Set(Microsoft.Research.SEAL.Ciphertext)">
            <summary>Copies an old Ciphertext to the current one.</summary>
            <param name="assign">The Ciphertext to copy from</param>
            <exception cref="T:System.ArgumentNullException">if assign is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.#ctor(Microsoft.Research.SEAL.Ciphertext)">
            <summary>Creates a copy of a Ciphertext.</summary>
            <param name="copy">The Ciphertext to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.Ciphertext.op_Implicit(Microsoft.Research.SEAL.BigPolyArray)~Microsoft.Research.SEAL.Ciphertext">
            <summary>Creates a Ciphertext by copying a given <see cref="T:Microsoft.Research.SEAL.BigPolyArray" /> instance.</summary>
            <remarks>
                Creates a Ciphertext by copying a given <see cref="T:Microsoft.Research.SEAL.BigPolyArray" /> instance. The created Ciphertext
                will wrap a duplicate of the given <see cref="T:Microsoft.Research.SEAL.BigPolyArray" />.
                </remarks>
            <param name="polyArray">The polynomial array</param>
            <exception cref="T:System.ArgumentNullException">if polyArray is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.EvaluationKeys.#ctor(seal.EvaluationKeys!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of a C++ EvaluationKeys instance.</summary>
            <param name="value">The EvaluationKeys instance to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.EvaluationKeys.Finalize">
            <summary>Destroys the EvaluationKeys instance.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EvaluationKeys.Dispose">
            <summary>Destroys the EvaluationKeys instance.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EvaluationKeys.Load(System.IO.Stream)">
            <summary>Loads an EvaluationKeys instance from an input stream overwriting the current EvaluationKeys
instance.</summary>
            <param name="stream">The stream to load the EvaluationKeys instance from</param>
            <exception cref="T:System.ArgumentNullException">if stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.EvaluationKeys.Save(System.IO.Stream)">See Save() to save an EvaluationKeys instance.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.EvaluationKeys.Save(System.IO.Stream)">
            <summary>Saves the EvaluationKeys instance to an output stream.</summary>
            <remarks>
                Saves the EvaluationKeys instance to an output stream. The output is in binary format and not human-readable. The
                output stream must have the "binary" flag set.
                </remarks>
            <param name="stream">The stream to save the EvaluationKeys to</param>
            <exception cref="T:System.ArgumentNullException">if stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.EvaluationKeys.Load(System.IO.Stream)">See <see cref="M:Microsoft.Research.SEAL.EvaluationKeys.Load(System.IO.Stream)" /> to load a saved EvaluationKeys instance.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.EvaluationKeys.Keys">
            <summary>Returns a reference to the list of evaluation keys.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.EvaluationKeys.default(System.Int32)">
            <summary>Returns a reference to the evaluation key stored at the given index.</summary>
            <exception cref="T:System.ArgumentOutOfRangeException">if the given index is not within [0, Size)</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.EvaluationKeys.Size">
            <summary>Returns the current number of evaluation keys.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EvaluationKeys.#ctor(System.Collections.Generic.List`1{System.Tuple`2{Microsoft.Research.SEAL.BigPolyArray,Microsoft.Research.SEAL.BigPolyArray}})">
            <summary>Creates an EvaluationKeys instance initialized with a given list of evaluation keys.</summary>
            <param name="keys">The keys</param>
            <exception cref="T:System.ArgumentNullException">if keys or any of its elements is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.EvaluationKeys.#ctor">
            <summary>Creates an empty set of evaluation keys.</summary>
        </member>
        <member name="M:seal.Evaluator.evaluation_keys">
Returns the evaluation keys used by the Evaluator.

</member>
        <member name="M:seal.Evaluator.multiply_plain(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies a ciphertext with a plaintext, and returns the result. The plaintext
        must have a significant coefficient count smaller than the coefficient count specified by the
        encryption parameters, and with coefficient values less than the plain modulus
        (EncryptionParameters::plain_modulus()).

        Multiplying by a plaintext 0 is not allowed and will result in the library throwing an invalid
        argument exception. The reason behind this design choice is that the result should
        be a fresh encryption of 0, but creating fresh encryptions should not be something
        this class does. Instead the user should separately handle the cases where the
        plain multiplier is 0.
        
        @param[in] encrypted The ciphertext to multiply
        @param[in] plain The plaintext to multiply
        @throws std::invalid_argument if the encrypted is not valid for the encryption parameters
        @throws std::invalid_argument if the plaintext's significant coefficient count or coefficient
        values are too large to represent with the encryption parameters
        @throws std::invalid_argument if the plaintext multiplier is zero

</member>
        <member name="M:seal.Evaluator.multiply_plain(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies a ciphertext with a plaintext, and stores the result in the destination
        parameter. The plaintext must have a significant coefficient count smaller than the 
        coefficient count specified by the encryption parameters, and with coefficient values 
        less than the plain modulus (EncryptionParameters::plain_modulus()). 
        
        Multiplying by a plaintext 0 is not allowed and will result in the library throwing an invalid 
        argument exception. The reason behind this design choice is that the result should 
        be a fresh encryption of 0, but creating fresh encryptions should not be something 
        this class does. Instead the user should separately handle the cases where the 
        plain multiplier is 0.

        @param[in] encrypted The ciphertext to multiply
        @param[in] plain The plaintext to multiply
        @param[out] destination The ciphertext to overwrite with the multiplication result
        @throws std::invalid_argument if the encrypted is not valid for the encryption parameters
        @throws std::invalid_argument if the plaintext's significant coefficient count or coefficient
        values are too large to represent with the encryption parameters
        @throws std::invalid_argument if the plaintext multiplier is zero

</member>
        <member name="M:seal.Evaluator.sub_plain(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts a ciphertext with a plaintext, and returns the result. The plaintext
        must have a significant coefficient count smaller than the coefficient count specified by the
        encryption parameters, and with coefficient values less than the plain modulus
        (EncryptionParameters::plain_modulus()).

        @param[in] encrypted The ciphertext to subtract from
        @param[in] plain The plaintext to subtract
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters
        @throws std::invalid_argument if the plaintext's significant coefficient count or coefficient
        values are too large to represent with the encryption parameters

</member>
        <member name="M:seal.Evaluator.sub_plain(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts a ciphertext with a plaintext, and stores the result in the destination
        parameter. The plaintext must have a significant coefficient count smaller than 
        the coefficient count specified by the encryption parameters, and with
        coefficient values less than the plain modulus (EncryptionParameters::plain_modulus()).

        @param[in] encrypted The ciphertext to subtract from
        @param[in] plain The plaintext to subtract
        @param[out] destination The ciphertext to overwrite with the subtraction result
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters
        @throws std::invalid_argument if the plaintext's significant coefficient count or coefficient
        values are too large to represent with the encryption parameters

</member>
        <member name="M:seal.Evaluator.add_plain(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds a ciphertext with a plaintext, and returns the result. The plaintext
        must have a significant coefficient count smaller than the coefficient count specified by the
        encryption parameters, and with coefficient values less than the plain modulus
        (EncryptionParameters::plain_modulus()).

        @param[in] encrypted The ciphertext to add
        @param[in] plain The plaintext to add
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters
        @throws std::invalid_argument if the plaintext's significant coefficient count or coefficient
        values are too large to represent with the encryption parameters

</member>
        <member name="M:seal.Evaluator.add_plain(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds a ciphertext with a plaintext, and stores the result in the destination
        parameter. The plaintext must have a significant coefficient count smaller than 
        the coefficient count specified by the encryption parameters, and with
        coefficient values less than the plain modulus (EncryptionParameters::plain_modulus()).

        @param[in] encrypted The ciphertext to add
        @param[in] plain The plaintext to add
        @param[out] destination The ciphertext to overwrite with the addition result
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters
        @throws std::invalid_argument if the plaintext's significant coefficient count or coefficient
        values are too large to represent with the encryption parameters

</member>
        <member name="M:seal.Evaluator.exponentiate(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64)">
        Raises a ciphertext to the specified power and returns the result. 
        
        Exponentiation to power 0 is not allowed and will result in the library throwing 
        an invalid argument exception. The reason behind this design choice is that the 
        result should be a fresh encryption of 1, but creating fresh encryptions should 
        not be something this class does. Instead the user has to separately handle 
        the cases where the exponent is 0. Relinearization is performed after every multiplication, 
        so enough encryption keys must have been given to the constructor of the Evaluator.

        @param[in] encrypted The ciphertext to raise to a power
        @param[in] exponent The power to raise the ciphertext to
        @throws std::invalid_argument if the ciphertext is not valid for the encryption parameters
        @throws std::invalid_argument if the exponent is zero

</member>
        <member name="M:seal.Evaluator.exponentiate(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Raises a ciphertext to the specified power and stores the result in the destination parameter. 
        
        Exponentiation to power 0 is not allowed and will result in the library throwing an invalid argument
        exception. The reason behind this design choice is that the result should be a fresh encryption
        of 1, but creating fresh encryptions should not be something this class does. Instead the user
        should separately handle the cases where the exponent is 0. Relinearization is performed after 
        every multiplication, so enough encryption keys must have been given to the constructor of the Evaluator.

        @param[in] encrypted The ciphertext to raise to a power
        @param[in] exponent The power to raise the ciphertext to
        @param[out] destination The ciphertext to overwrite with the exponentiation result
        @throws std::invalid_argument if the ciphertext is not valid for the encryption parameters
        @throws std::invalid_argument if the exponent is zero

</member>
        <member name="M:seal.Evaluator.multiply_many(std.vector&lt;seal.Ciphertext,std.allocator&lt;seal.Ciphertext&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.Ciphertext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies a vector of ciphertexts together and stores the result in the destination parameter.
        Relinearization is performed after every multiplication, so enough encryption keys must have been given
        to the constructor of the Evaluator.

        @param[in] encrypteds The vector of ciphertexts to multiply
        @param[out] destination The ciphertext to overwrite with the multiplication result
        @throws std::invalid_argument if the encrypteds vector is empty
        @throws std::invalid_argument if the ciphertexts are not valid ciphertexts for the encryption parameters

</member>
        <member name="M:seal.Evaluator.multiply_many(std.vector&lt;seal.Ciphertext,std.allocator&lt;seal.Ciphertext&gt;&gt;)">
        Multiplies a vector of ciphertexts together and returns the result. Relinearization is performed after
        every multiplication, so enough encryption keys must have been given to the constructor of the Evaluator.

        @param[in] encrypteds The vector of ciphertexts to multiply
        @throws std::invalid_argument if the encrypteds vector is empty
        @throws std::invalid_argument if the ciphertexts are not valid ciphertexts for the encryption parameters

</member>
        <member name="M:seal.Evaluator.multiply_many(std.vector&lt;seal.BigPolyArray,std.allocator&lt;seal.BigPolyArray&gt;&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies a vector of ciphertexts together and stores the result in the destination parameter. 
        Relinearization is performed after every multiplication, so enough encryption keys must have been given
        to the constructor of the Evaluator.

        @param[in] encrypteds The vector of ciphertexts to multiply
        @param[out] destination The ciphertext to overwrite with the multiplication result
        @throws std::invalid_argument if the encrypteds vector is empty
        @throws std::invalid_argument if the ciphertexts are not valid ciphertexts for the encryption parameters

</member>
        <member name="M:seal.Evaluator.multiply_many(std.vector&lt;seal.BigPolyArray,std.allocator&lt;seal.BigPolyArray&gt;&gt;)">
        Multiplies a vector of ciphertexts together and returns the result. Relinearization is performed after 
        every multiplication, so enough encryption keys must have been given to the constructor of the Evaluator.

        @param[in] encrypteds The vector of ciphertexts to multiply
        @throws std::invalid_argument if the encrypteds vector is empty
        @throws std::invalid_argument if the ciphertexts are not valid ciphertexts for the encryption parameters

</member>
        <member name="M:seal.Evaluator.relinearize(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
        Relinearizes a ciphertext and returns the result.

        @param[in] encrypted The ciphertext to relinearize
        @param[in] destination_size The size of the output ciphertext (defaults to 2)
        @throws std::invalid_argument if the ciphertext is not valid for the encryption parameters
        @throws std::invalid_argument if destination_size is less than 2 or greater than number of elements currently in ciphertext
        @throws std::invalid_argument if not enough evaluation keys have been generated

</member>
        <member name="M:seal.Evaluator.relinearize(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
        Relinearizes a ciphertext and stores the result in the destination parameter.

        @param[in] encrypted The ciphertext to relinearize
        @param[in] destination_size The size of the output ciphertext (defaults to 2)
        @param[out] destination The ciphertext to overwrite with the relinearized result
        @throws std::invalid_argument if the ciphertext is not valid for the encryption parameters
        @throws std::invalid_argument if destination_size is less than 2 or greater than number of elements currently in ciphertext
        @throws std::invalid_argument if not enough evaluation keys have been generated

</member>
        <member name="M:seal.Evaluator.square(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Squares a ciphertext and stores the result in the destination parameter.

        @param[in] encrypted The ciphertext to square
        @param[out] destination The ciphertext to overwrite with the result
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.square(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Squares a ciphertext and returns the result.

        @param[in] encrypted The ciphertext to square
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.multiply(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies two ciphertexts without performing relinearization, and returns the result.

        @param[in] encrypted1 The first ciphertext to multiply
        @param[in] encrypted2 The second ciphertext to multiply
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.multiply(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies two ciphertexts and stores the result in the destination parameter. 

        @param[in] encrypted1 The first ciphertext to multiply
        @param[in] encrypted2 The second ciphertext to multiply
        @param[out] destination The ciphertext to overwrite with the multiplication result
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.sub(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts two ciphertexts and returns the result.

        @param[in] encrypted1 The ciphertext to subtract from
        @param[in] encrypted2 The ciphertext to subtract
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.sub(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts two ciphertexts and stores the result in the destination parameter. 

        @param[in] encrypted1 The ciphertext to subtract from
        @param[in] encrypted2 The ciphertext to subtract
        @param[out] destination The ciphertext to overwrite with the subtraction result
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.add(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds two ciphertexts and returns the result.

        @param[in] encrypted1 The first ciphertext to add
        @param[in] encrypted2 The second ciphertext to add
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.add(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds two ciphertexts and stores the result in the destination parameter.

        @param[in] encrypted1 The first ciphertext to add
        @param[in] encrypted2 The second ciphertext to add
        @param[out] destination The ciphertext to overwrite with the addition result
        @throws std::invalid_argument if the ciphertexts are not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.negate(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Negates a ciphertext and returns the result.

        @param[in] encrypted The ciphertext to negate
        @throws std::invalid_argument if the ciphertext is not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.negate(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new Evaluator by moving an old one.

        @param[in] source The Evaluator to move from

        Negates a ciphertext and stores the result in the destination parameter.

        @param[in] encrypted The ciphertext to negate
        @param[out] destination The ciphertext to overwrite with the negated result
        @throws std::invalid_argument if the ciphertext is not valid for the encryption parameters

</member>
        <member name="M:seal.Evaluator.#ctor(seal.Evaluator!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a copy of a Evaluator.

        @param[in] copy The Evaluator to copy from

</member>
        <member name="M:seal.Evaluator.#ctor(seal.EncryptionParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates an Evaluator instance initialized with the specified encryption parameters.
        Optionally, the user can give a reference to a MemoryPoolHandle object to use a custom 
        memory pool instead of the global memory pool (default).

        @param[in] parms The encryption parameters
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if encryption parameters are not valid
        @see EncryptionParameters for more details on valid encryption parameters.
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="M:seal.Evaluator.#ctor(seal.EncryptionParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.EvaluationKeys!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates an Evaluator instance initialized with the specified encryption parameters and
        evaluation keys. If no evaluation keys will be needed, one can simply pass a newly 
        created empty instance of EvaluationKeys to the function. Optionally, the user can 
        give a reference to a MemoryPoolHandle object to use a custom memory pool instead of 
        the global memory pool (default).

        @param[in] parms The encryption parameters
        @param[in] evaluation_keys The evaluation keys
        @param[in] pool The memory pool handle
        @throws std::invalid_argument if encryption parameters or evaluation keys are not valid
        @see EncryptionParameters for more details on valid encryption parameters.
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.Evaluator">
    Provides arithmetic functions for operating on ciphertexts. The add, subtract, and multiply function
    variants allow both operands to be encrypted. The "_plain" variants allow one of the inputs to be 
    encrypted and the other unencrypted.

    Every valid ciphertext consists of at least two polynomials. Homomorphic multiplication increases 
    the size of the ciphertext in such a way that if the input ciphertexts have size M and N, then the
    output ciphertext will have size M+N-1. The multiplication operation will require M*N polynomial
    multiplications to be performed. To read the current size of a ciphertext the user can use
    BigPolyArray::size(). 
    
    A relinearization operation can be used to reduce the size of a ciphertext to any smaller size
    (but at least 2), potentially improving the performance of a subsequent multiplication using it.
    However, relinearization consumes the invariant noise budget in a ciphertext by an additive factor 
    proportional to 2^DBC, and relinearizing from size K to L will require 2*(K-L)*[floor(log_2(coeff_modulus)/DBC)+1]
    polynomial multiplications, where DBC denotes the decomposition bit count set in the encryption parameters. 
    Note that the larger the decomposition bit count is, the faster relinearization will be, but also the
    more invariant noise budget will be consumed.

    Relinearization requires the key generator to generate evaluation keys. More specifically, to relinearize
    a ciphertext of size K down to any size smaller than K (but at least 2), at least K-2 evaluation keys will
    be needed. These have to be given as an input parameter to the constructor of Evaluator.

    @par Invariant Noise Budget
    The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
    a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
    of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
    the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
    invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
    starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
    computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
    correctly.

</member>
        <member name="M:seal.Ciphertext.load(std.basic_istream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Loads a Ciphertext from an input stream overwriting the current Ciphertext.

        @param[in] stream The stream to load the Ciphertext from
        @see save() to save a Ciphertext.

</member>
        <member name="M:seal.Ciphertext.save(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Saves the Ciphertext to an output stream. The output is in binary format and not human-readable.
        The output stream must have the "binary" flag set.

        @param[in] stream The stream to save the Ciphertext to
        @see load() to load a saved Ciphertext.

</member>
        <member name="M:seal.Ciphertext.size">
Returns the size of the ciphertext.

</member>
        <member name="M:seal.Ciphertext.op_Implicit~seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced">
Returns a constant reference to the underlying BigPolyArray.

</member>
        <member name="M:seal.Ciphertext.op_Implicit~seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced">
Returns a reference to the underlying BigPolyArray.

</member>
        <member name="M:seal.Ciphertext.op_Assign(seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Sets the current Ciphertext to wrap a given BigPolyArray by moving it.

        @param[in] poly_array The polynomial array to move from

</member>
        <member name="M:seal.Ciphertext.op_Assign(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new Ciphertext by copying an old one.

        @param[in] copy The Ciphertext to copy from

        Creates a new Ciphertext by movin an old one.

        @param[in] source The Ciphertext to move from

        Copies an old Ciphertext to the current one.

        @param[in] assign The Ciphertext to copy from

        Moves an old Ciphertext to the current one.

        @param[in] assign The Ciphertext to move from

        Sets the current Ciphertext to wrap a given BigPolyArray by creating a copy of it.

        @param[in] poly_array The polynomial array to copy from

</member>
        <member name="M:seal.Ciphertext.#ctor(seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a Ciphertext by moving a given BigPolyArray instance.

        @param[in] poly_array The polynomial array

</member>
        <member name="M:seal.Ciphertext.#ctor(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a Ciphertext by copying a given BigPolyArray instance. The created Ciphertext
        will wrap a duplicate of the given BigPolyArray.

        @param[in] poly_array The polynomial array

</member>
        <member name="T:seal.Ciphertext">
Represents a ciphertext element. Currently the Ciphertext class simply wraps an instance of
the BigPolyArray class. In particular, it does not perform any sanity checking on the BigPolyArray
that it wraps.

</member>
        <member name="M:seal.EvaluationKeys.clear">
Sets the vector of evaluation keys to be empty.

</member>
        <member name="M:seal.EvaluationKeys.keys">
Returns a const reference to the vector of evaluation keys.


Returns a reference to the vector of evaluation keys.

</member>
        <member name="M:seal.EvaluationKeys.load(std.basic_istream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Loads an EvaluationKeys instance from an input stream overwriting the current EvaluationKeys instance.

        @param[in] stream The stream to load the EvaluationKeys instance from
        @see save() to save an EvaluationKeys instance.

</member>
        <member name="M:seal.EvaluationKeys.save(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Saves the EvaluationKeys instance to an output stream. The output is in binary format and not human-readable. The output
        stream must have the "binary" flag set.

        @param[in] stream The stream to save the EvaluationKeys to
        @see load() to load a saved EvaluationKeys instance.

</member>
        <member name="M:seal.EvaluationKeys.size">
Returns the current number of evaluation keys.

</member>
        <member name="M:seal.EvaluationKeys.op_Subscript(System.Int32)">
        Returns a const reference to the evaluation key stored at the given index.

        @throws std::out_of_range If the given index is not within [0, size())


        Returns a reference to the evaluation key stored at the given index.

        @throws std::out_of_range If the given index is not within [0, size())

</member>
        <member name="M:seal.EvaluationKeys.#ctor(std.vector&lt;std.pair&lt;seal.BigPolyArray,seal.BigPolyArray&gt;,std.allocator&lt;std.pair&lt;seal.BigPolyArray,seal.BigPolyArray&gt;&gt;&gt;)">
        Creates an EvaluationKeys instance initialized with a given vector of evaluation keys.

        @param[in] keys The keys

</member>
        <member name="M:seal.EvaluationKeys.#ctor">
Creates an empty set of evaluation keys.

</member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.#ctor(seal.EncryptionParameters!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of the C++ EncryptionParameters.</summary>
            <remarks>
                Creates a deep copy of a EncryptionParameters. The created EncryptionParameters will have the same settings as the
                original.
                </remarks>
            <param name="parms">The EncryptionParameters to copy from</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.GetParameters">
            <summary>Returns a reference to the underlying C++ EncryptionParameters.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.Finalize">
            <summary>Destroys the EncryptionParameters.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.Dispose">
            <summary>Destroys the EncryptionParameters.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.Invalidate">
            <summary>Invalidates the current encryption parameters.</summary>
            <remarks>
Invalidates the current encryption parameters. Calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary before the 
parameters can be used again.
</remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.InherentNoiseMax(Microsoft.Research.SEAL.BigUInt)">
            <summary>Computes the maximum amount of inherent noise supported by the current encryption parameters and stores 
                it in the given BigUInt.</summary>
            <remarks>
                Computes the maximum amount of inherent noise supported by the current encryption parameters and stores it in 
                the given BigUInt. Any ciphertext with larger inherent noise is impossible to decrypt, even with the correct 
                secret key. The function Decryptor::InherentNoiseBits() can be used to compute the number of bits of inherent 
                noise in a given ciphertext.
                </remarks>
            <param name="destination">The BigUInt to overwrite with the maximum inherent noise</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
            <exception cref="T:System.InvalidOperationException">if the encryption parameters are not valid</exception>
            <seealso cref="M:Microsoft.Research.SEAL.EncryptionParameters.InherentNoiseBitsMax">See InherentNoiseBitsMax for returning instead the significant bit count of the
                maximum size of inherent noise.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.InherentNoiseBitsMax">
            <summary>Computes and returns the maximum number of bits of inherent noise supported by the 
                current encryption parameters.</summary>
            <remarks>
                Computes and returns the maximum number of bits of inherent noise supported by the current encryption parameters. Any
                ciphertext with larger inherent noise is impossible to decrypt, even with the correct secret key. The function
                Decryptor::InherentNoiseBits() can be used to compute the number of bits of inherent noise in a given ciphertext.
                </remarks>
            <exception cref="T:System.InvalidOperationException">if the encryption parameters are not valid</exception>
            <seealso cref="M:Microsoft.Research.SEAL.EncryptionParameters.InherentNoiseMax(Microsoft.Research.SEAL.BigUInt)">See InherentNoiseMax for computing the exact maximum size of inherent noise.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameters.Qualifiers">
            <summary>Returns the set of qualifiers (as an instance of <see cref="T:Microsoft.Research.SEAL.EncryptionParameterQualifiers" />) 
                for the current encryption parameters.</summary>
            <remarks>Returns the set of qualifiers (as an instance of <see cref="T:Microsoft.Research.SEAL.EncryptionParameterQualifiers" />)
                for the current encryption parameters. Note that to get an updated set of qualifiers it is necessary to call
                <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> after any change to the encryption parameters.
                </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameterQualifiers">See EncryptionParameterQualifiers for more details.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.Load(System.IO.Stream)">
            <summary>Loads the EncryptionParameters from an input stream overwriting the current EncryptionParameters.</summary>
            <remarks>
Loads the EncryptionParameters from an input stream overwriting the current EncryptionParameters.
This function automatically invalidates the EncryptionParameters instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" />
is necessary before the parameters can be used.
</remarks>
            <param name="stream">The stream to load the EncryptionParameters from</param>
            <exception cref="T:System.ArgumentNullException">If stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.EncryptionParameters.Save(System.IO.Stream)">See Save() to save an EncryptionParameters instance.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.Save(System.IO.Stream)">
            <summary>Saves the EncryptionParameters to an output stream.</summary>
            <remarks>
                Saves the EncryptionParameters to an output stream. The output is in binary format and is not human-readable. The
                output stream must have the "Binary" flag set.
                </remarks>
            <param name="stream">The stream to save the EncryptionParameters to</param>
            <exception cref="T:System.ArgumentNullException">If stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.EncryptionParameters.Load(System.IO.Stream)">See Load() to load a saved EncryptionParameters instance.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetDecompositionBitCount(System.Int32)">
            <summary>Sets the decomposition bit count parameter to the specified value.</summary>
            <remarks>
                Sets the decomposition bit count parameter to the specified value. The decomposition bit count directly
                determines the number of evaluation keys required by the scheme. Smaller decomposition bit count reduces
                the accumulation of noise during multiplication operations, but can also significantly increase the time
                required to perform multiplication. This function automatically invalidates the EncryptionParameters
                instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary before the parameters can be used.
                </remarks>
            <param name="value">The new decomposition bit count</param>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameters.DecompositionBitCount">
            <summary> Returns the decomposition bit count which directly determines the number of evaluation keys required by
                the scheme.</summary>
            <remarks>
                Returns the decomposition bit count which directly determines the number of evaluation keys required by
                the scheme. Smaller decomposition bit count reduces the accumulation of noise during multiplication
                operations, but can also significantly increase the time required to perform multiplication.
                </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetNoiseMaxDeviation(System.Double)">
            <summary>Sets the maximum deviation of normalized noise used during key generation and encryption.</summary>
            <remarks>
                Sets the maximum deviation of normalized noise used during key generation and encryption. This function
                automatically invalidates the EncryptionParameters instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary 
                before the parameters can be used.
                </remarks>
            <param name="value">The new maximum deviation</param>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameters.NoiseMaxDeviation">
            <summary>Returns the maximum deviation of normalized noise used during key generation and encryption.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetNoiseStandardDeviation(System.Double)">
            <summary>Sets the standard deviation of normalized noise used during key generation and encryption.</summary>
            <remarks>
Sets the standard deviation of normalized noise used during key generation and encryption. This function
automatically invalidates the EncryptionParameters instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary 
before the parameters can be used.
</remarks>
            <param name="value">The new standard deviation</param>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameters.NoiseStandardDeviation">
            <summary>Returns the standard deviation of normalized noise used during key generation and encryption.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetPlainModulus(System.String)">
            <summary>Sets the plaintext modulus parameter to the specified value (represented by System::String).</summary>
            <remarks>
                Sets the plaintext modulus parameter to the specified value (represented by System::String).
                Note that the plaintext modulus is one greater than the maximum value allowed for any plaintext
                coefficient that the library can encrypt or represent. This function automatically invalidates
                the EncryptionParameters instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary before the
                parameters can be used.
                </remarks>
            <param name="plainModulus">The new plaintext modulus</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetPlainModulus(System.UInt64)">
            <summary>Sets the plaintext modulus parameter to the specified value (represented by System::UInt64).</summary>
            <remarks>
                Sets the plaintext modulus parameter to the specified value (represented by System::UInt64).
                Note that the plaintext modulus is one greater than the maximum value allowed for any plaintext
                coefficient that the library can encrypt or represent. This function automatically invalidates
                the EncryptionParameters instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary before the
                parameters can be used.
                </remarks>
            <param name="plainModulus">The new plaintext modulus</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetPlainModulus(Microsoft.Research.SEAL.BigUInt)">
            <summary>Sets the plaintext modulus parameter to the specified value (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />).</summary>
            <remarks>
                Sets the plaintext modulus parameter to the specified value (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />).
                Note that the plaintext modulus is one greater than the maximum value allowed for any plaintext 
                coefficient that the library can encrypt or represent. This function automatically invalidates 
                the EncryptionParameters instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary before the 
                parameters can be used.
                </remarks>
            <param name="plainModulus">The new plaintext modulus</param>
            <exception cref="T:System.ArgumentNullException">if plainModulus is null</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus">
            <summary>Returns a copy of the plaintext modulus parameter (represented by a <see cref="T:Microsoft.Research.SEAL.BigUInt" />).</summary>
            <remarks>
                Returns a copy of the plaintext modulus parameter (represented by a <see cref="T:Microsoft.Research.SEAL.BigUInt" />). Note that the
                plaintext modulus is one greater than the maximum value allowed for any plaintext coefficient that the library
                can encrypt or represent.
                </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.UInt64)">
            <summary>Sets the coefficient modulus parameter to the specified value (represented by System::UInt64).</summary>
            <remarks>
                Sets the coefficient modulus parameter to the specified value (represented by System::UInt64).
                Note that the coefficient modulus directly determines the number of bits-per-coefficient of encrypted
                polynomials and the maximum value allowed for <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" /> (which should be significantly
                smaller than CoeffModulus). This function automatically invalidates the EncryptionParameters instance, so
                calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary before the parameters can be used.
                </remarks>
            <param name="coeffModulus">The new coefficient modulus</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(Microsoft.Research.SEAL.BigUInt)">
            <summary>Sets the coefficient modulus parameter to the specified value (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />).</summary>
            <remarks>
                Sets the coefficient modulus parameter to the specified value (represented by <see cref="T:Microsoft.Research.SEAL.BigUInt" />).
                Note that the coefficient modulus directly determines the number of bits-per-coefficient of encrypted 
                polynomials and the maximum value allowed for <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" /> (which should be significantly 
                smaller than CoeffModulus). This function automatically invalidates the EncryptionParameters instance, so 
                calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> is necessary before the parameters can be used.
                </remarks>
            <param name="coeffModulus">The new coefficient modulus</param>
            <exception cref="T:System.ArgumentNullException">if coeffModulus is null</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameters.CoeffModulus">
            <summary>Returns a copy of the coefficient modulus parameter (represented by a <see cref="T:Microsoft.Research.SEAL.BigUInt" />).</summary>
            <remarks>
                Returns a copy of the coefficient modulus parameter (represented by a <see cref="T:Microsoft.Research.SEAL.BigUInt" />). Note that the
                coefficient modulus directly determines the number of bits-per-coefficient of encrypted polynomials and the
                maximum value allowed for <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" /> (which should be significantly smaller than CoeffModulus).
                </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetPolyModulus(System.String)">
            <summary>Sets the polynomial modulus parameter to the specified value (represented by System::String).</summary>
            <remarks>
                Sets the polynomial modulus parameter to the specified value (represented by System::String).
                Note that the polynomial modulus directly determines the number of coefficients of encrypted polynomials,
                and the maximum number of coefficients for plaintext polynomials that are representable by the library.
                This function automatically invalidates the EncryptionParameters instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" />
                is necessary before the parameters can be used.
                </remarks>
            <param name="polyModulus">The new polynomial modulus</param>
            <exception cref="T:System.ArgumentNullException">if polyModulus is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.SetPolyModulus(Microsoft.Research.SEAL.BigPoly)">
            <summary>Sets the polynomial modulus parameter to the specified value (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />).</summary>
            <remarks>
Sets the polynomial modulus parameter to the specified value (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />).
Note that the polynomial modulus directly determines the number of coefficients of encrypted polynomials, 
and the maximum number of coefficients for plaintext polynomials that are representable by the library. 
This function automatically invalidates the EncryptionParameters instance, so calling <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" />
is necessary before the parameters can be used.
</remarks>
            <param name="polyModulus">The new polynomial modulus</param>
            <exception cref="T:System.ArgumentNullException">if polyModulus is null</exception>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameters.PolyModulus">
            <summary>Returns a reference to the polynomial modulus (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />).</summary>
            <remarks>
                Returns a copy of the polynomial modulus parameter (represented by <see cref="T:Microsoft.Research.SEAL.BigPoly" />). Note that
                the polynomial modulus directly determines the number of coefficients of encrypted polynomials, and the
                maximum number of coefficients for plaintext polynomials that are representable by the library.
                </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.Set(Microsoft.Research.SEAL.EncryptionParameters)">
            <summary>Overwrites the EncryptionParameters instance with the specified instance.</summary>
            <param name="assign">The EncryptionParameters instance that should be assigned to the current instance</param>
            <exception cref="T:System.ArgumentNullException">if assign is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.#ctor(Microsoft.Research.SEAL.EncryptionParameters)">
            <summary>Creates a copy of a EncryptionParameters.</summary>
            <param name="copy">The EncryptionParameters to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.#ctor(Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates an empty EncryptionParameters instance.</summary>
            <remarks>
                Creates an empty EncryptionParameters instance. The user can give a reference to a <see cref="T:Microsoft.Research.SEAL.MemoryPoolHandle" /> 
                object to use a custom memory pool instead of the global memory pool (default).
                </remarks>
            <param name="pool">The memory pool handle</param>
            <exception cref="T:System.ArgumentNullException">if pool is null</exception>
            <seealso cref="T:Microsoft.Research.SEAL.MemoryPoolHandle">See MemoryPoolHandle for more details on memory pool handles.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameters.#ctor">
            <summary>Creates an empty EncryptionParameters instance.</summary>
        </member>
        <member name="T:Microsoft.Research.SEAL.EncryptionParameters">
            <summary>Represents the user-customizable encryption scheme settings.</summary>
            <remarks>
                <para>
            Represents the user-customizable encryption scheme settings. Several settings (e.g., <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PolyModulus" />,
            <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.CoeffModulus" />, <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />) significantly affect the performance, capabilities, and
            security of the encryption scheme. KeyGenerator, Encryptor, Decryptor, Evaluator, and other objects in the library 
            all require the EncryptionParameters object to specify and agree on the encryption scheme settings.
            </para>
                <para>
            Picking appropriate encryption parameters is essential to enable a particular application while balancing performance
            and security. Some encryption settings will not allow some inputs (e.g., attempting to encrypt a polynomial with more
            coefficients than <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PolyModulus" /> or larger coefficients than <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />) or support some
            computations (with noise growing too fast as determined by <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.CoeffModulus" /> and
            <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.DecompositionBitCount" />). The <see cref="T:Microsoft.Research.SEAL.ChooserPoly" /> and <see cref="T:Microsoft.Research.SEAL.ChooserEvaluator" /> classes provide
            functionality to help determine the best encryption parameters for an application. Additionally, please refer to
            external documentation for more details on how to determine the best parameters.
            </para>
                <para>
            After the user has set at least the <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PolyModulus" />, the <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.CoeffModulus" />, and the 
            <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.PlainModulus" />, and in many cases also the <see cref="P:Microsoft.Research.SEAL.EncryptionParameters.DecompositionBitCount" />, the parameters need to 
            be validated for correctness and functionality. This can be done using the function <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" />, which 
            returns an instance of EncryptionParameterQualifiers. If the returned instance of EncryptionParameterQualifiers has 
            the EncryptionParameterQualifiers::ParametersSet flag set to true, the parameter set is valid and ready to be used. 
            If the parameters were for some reason not appropriately set, the returned EncryptionParameterQualifiers instance 
            will have EncryptionParameterQualifiers::ParametersSet set to false. Any change to an already validated instance 
            of EncryptionParameters immediately invalidates it, requiring another call to <see cref="M:Microsoft.Research.SEAL.EncryptionParameters.Validate" /> before the
            parameters can be used.
            </para>
                <para>
            In general, reading from EncryptionParameters is thread-safe, while mutating is not. 
            </para>
                <para>
            Choosing inappropriate EncryptionParameters may load to an encryption scheme that is not secure, does not perform
            well, and/or does not support the input and computation of the application.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameterQualifiers.#ctor(seal.EncryptionParameterQualifiers!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of the C++ EncryptionParameterQualifiers.</summary>
            <remarks>
                Creates a deep copy of a EncryptionParameterQualifiers. The created EncryptionParameterQualifiers 
                will have the same values as the original.
                </remarks>
            <param name="value">The EncryptionParameterQualifiers to copy from</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameterQualifiers.GetQualifiers">
            <summary>Returns a reference to the underlying C++ EncryptionParameterQualifiers.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameterQualifiers.Finalize">
            <summary>Destroys the EncryptionParameterQualifiers.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.EncryptionParameterQualifiers.Dispose">
            <summary>Destroys the EncryptionParameterQualifiers.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameterQualifiers.EnableNTTInMultiply">
            <summary>This variable has currently no effect.</summary>
            <remarks>
                This variable has currently no effect (see SEAL/util/defines.h).
                </remarks>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameterQualifiers.EnableBatching">
            <summary>If the plaintext modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial modulus and N is a power
                of two, then it is possible to use PolyCRTBuilder to do batching, which is a fundamental technique in homomorphic
                encryption to enable powerful SIMD functionality.</summary>
            <remarks>
                If the plaintext modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial
                modulus and N is a power of two, then it is possible to use PolyCRTBuilder to do batching,
                which is a fundamental technique in homomorphic encryption to enable powerful SIMD
                functionality, often called "batching" in homomorphic encryption literature. In this
                case the variable enable_batching will be set to true.
                </remarks>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameterQualifiers.EnableNTT">
            <summary>If the coefficient modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial modulus and N is
                a power of two, then the number-theoretic transform (NTT) can be used for fast multiplications of polynomials 
                modulo the polynomial modulus and coefficient modulus.</summary>
            <remarks>
                If the coefficient modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial modulus and N is a power of two,
                then the number-theoretic transform (NTT) can be used for fast multiplications of polynomials modulo the polynomial
                modulus and coefficient modulus. In this case the variable EnableNtt will be true.
                </remarks>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameterQualifiers.EnableNussbaumer">
            <summary>If the polynomial modulus is of the form X^N+1, where N is a power of two, then Nussbaumer 
                convolution can be used for fast multiplication of polynomials modulo the polynomial modulus.</summary>
            <remarks>
                If the polynomial modulus is of the form X^N+1, where N is a power of two, then Nussbaumer convolution can be 
                used for fast multiplication of polynomials modulo the polynomial modulus. In this case the variable EnableNussbaumer 
                will be true. However, currently SEAL requires the polynomial modulus to be of this form to even consider the
                parameters to be valid. Therefore, ParametersSet can only be true if EnableNussbaumer is true.
                </remarks>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameterQualifiers.EnableRelinearization">
            <summary>If EncryptionParameters::DecompositionBitCount is set to a positive value, the variable 
EnableRelinearization will be true.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.EncryptionParameterQualifiers.ParametersSet">
            <summary>If the encryption parameters are set in a way that is considered valid by SEAL, the 
variable ParametersSet will be true.</summary>
        </member>
        <member name="T:Microsoft.Research.SEAL.EncryptionParameterQualifiers">
            <summary>Stores a set of attributes (qualifiers) of a set of encryption parameteres.</summary>
            <remarks>
            Stores a set of attributes (qualifiers) of a set of encryption parameteres. These parameters are used in various parts
            of the library, e.g. to determine which algorithms can be used. The qualifiers are silently passed on to classes such
            as <see cref="T:Microsoft.Research.SEAL.Encryptor" />, <see cref="T:Microsoft.Research.SEAL.Evaluator" />, and <see cref="T:Microsoft.Research.SEAL.Decryptor" />, and the only way to change them is 
            by changing the encryption parameters accordingly.
            </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.EncryptionParameters">See EncryptionParameters for the class that stores the encryption parameters
            themselves.</seealso>
            <seealso>See EncryptionParameters::GetQualifiers() for obtaining the EncryptionParameterQualifiers 
            corresponding to a certain parameter set.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.MemoryPoolHandle.GetHandle">
            <summary>Returns a reference to the underlying C++ MemoryPoolHandle.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.MemoryPoolHandle.AcquireNew">
            <summary>Returns a MemoryPoolHandle pointing to a new memory pool.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.MemoryPoolHandle.AcquireGlobal">
            <summary>Returns a MemoryPoolHandle pointing to the global memory pool.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.MemoryPoolHandle.#ctor(Microsoft.Research.SEAL.MemoryPoolHandle)">
            <summary>Creates a copy of a MemoryPoolHandle.</summary>
            <param name="copy">The MemoryPoolHandle to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.MemoryPoolHandle.Finalize">
            <summary>Destroys the MemoryPoolHandle.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.MemoryPoolHandle.Dispose">
            <summary>Destroys the MemoryPoolHandle.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.MemoryPoolHandle.#ctor">
            <summary>Creates a new MemoryPoolHandle pointing to the global memory pool.</summary>
        </member>
        <member name="T:Microsoft.Research.SEAL.MemoryPoolHandle">
            <summary>Provides the functionality for creating and using local memory pools.</summary>
            <remarks>
                <para>
            SEAL uses memory pools for improved performance due to the large number of memory allocations needed
            by the homomorphic encryption operations, and the underlying polynomial arithmetic. The library
            automatically creates a shared global memory pool, that is by default used by all instances of the
            computation-heavy classes such as Encryptor, Evaluator, and PolyCRTBuilder. However, sometimes the
            user might want to use local memory pools with some of these classes. For example, in heavily
            multi-threaded applications the global memory pool might become clogged due to concurrent allocations.
            Instead, the user might want to create a separate---say Evaluator---object for each thread, and have it
            use a thread-local memory pool. The MemoryPoolHandle class provides the functionality for doing this.
            </para>
                <para>
            For example, the user can create a MemoryPoolHandle that points to a new local memory pool by calling
            the static function acquire_new(). The MemoryPoolHandle it returns (or copies of it) can now be passed
            on as an argument to the constructors of one or more classes (such as Encryptor, Evaluator, and PolyCRTBuilder).
            </para>
                <para>
            Internally, a MemoryPoolHandle simply wraps a shared pointer to a util::MemoryPool object. This way
            the local memory pool will be automatically destroyed, and the memory released, as soon as no existing
            handles point to it. Since the global memory pool is a static object, it will always have a positive
            reference count, and thus will not be destroyed until the program terminates.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.#ctor(seal.BigPolyArray*)">
            <summary>Initializes the BigPolyArray to use the specified C++ BigPolyArray.</summary>
            <remarks>
Initializes the BigPolyArray to use the specified C++ BigPolyArray. This constructor does not copy the C++ BigPolyArray but actually
uses the specified C++ BigPolyArray as the backing data. Upon destruction, the managed BigPolyArray will not destroy the C++
BigPolyArray.
</remarks>
            <param name="value">The BigPolyArray to use as the backing BigPolyArray</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.#ctor(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of a C++ BigPolyArray instance.</summary>
            <param name="value">The BigPolyArray instance to copy from</param>
            <exception cref="T:System.ArgumentNullException">If copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.GetArray">
            <summary>Returns a reference to the underlying C++ BigPolyArray.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.Finalize">
            <summary>Destroys the BigPolyArray, including deallocating any internally allocated space.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.Dispose">
            <summary>Destroys the BigPolyArray, including deallocating any internally allocated space.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.Load(System.IO.Stream)">
            <summary>Loads an BigPolyArray instance from an input stream overwriting the current BigPolyArray
instance.</summary>
            <param name="stream">The stream to load the BigPolyArray instance from</param>
            <exception cref="T:System.ArgumentNullException">If stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.BigPolyArray.Save(System.IO.Stream)">See Save() to save an BigPolyArray instance.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.Save(System.IO.Stream)">
            <summary>Saves the BigPolyArray instance to an output stream.</summary>
            <remarks>
                Saves the BigPolyArray instance to an output stream. The output is in binary format and not human-readable. The
                output stream must have the "binary" flag set.
                </remarks>
            <param name="stream">The stream to save the BigPolyArray to</param>
            <exception cref="T:System.ArgumentNullException">If stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.BigPolyArray.Load(System.IO.Stream)">See Load() to load a saved BigPolyArray instance.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.Set(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Overwrites the BigPolyArray instance with a specified BigPolyArray instance.</summary>
            <remarks>
                Overwrites the BigPolyArray instance with the BigPolys in the specified BigPolyArray instance. After assignment,
                the size of BigPolyArray matches the size of the assigned BigPolyArray instance.
                </remarks>
            <param name="assign">The BigPolyArray instance to whose value should be assigned to the current BigPolyArray
                instance</param>
            <exception cref="T:System.ArgumentNullException">if assign is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.Reset">
            <summary>Resets the BigPolyArray instance to an empty, zero-sized instance.</summary>
            <remarks>
                Resets the BigPolyArray instance to an empty, zero-sized instance. Any space allocated by the BigPolyArray instance
                is deallocated.
                </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.Resize(System.Int32,System.Int32,System.Int32)">
            <summary>Resizes the BigPolyArray internal array to store the specified number of polynomials of the specified size,
copying over the old polynomials as much as will fit.</summary>
            <param name="size">The number of polynomials to allocate space for</param>
            <param name="coeffCount">The number of coefficients allocated for each polynomial in the array</param>
            <param name="coeffBitCount">The bit count of each polynomial in the array</param>
            <exception cref="T:System.ArgumentException">if size is negative</exception>
            <exception cref="T:System.ArgumentException">if coeffCount is negative</exception>
            <exception cref="T:System.ArgumentException">if coeffBitCount is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.SetZero(System.Int32)">
            <summary>Sets the polynomial with index polyIndex to have value zero.</summary>
            <remarks>
                Sets the polynomial with index polyIndex to have value zero. This does not resize the BigPolyArray or modify the other
                polynomials.
                </remarks>
            <param name="polyIndex">The index of the polynomial to set to zero</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If polyIndex is not within [0, size())</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.SetZero">
            <summary>Sets all polynomials to have a value of zero.</summary>
            <remarks>
                <para>
                Sets all polynomials to have a value of zero. This does not resize the BigPolyArray.
                </para>
            </remarks>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPolyArray.default(System.Int32)">
            <summary>Returns a reference to the BigPoly at index polyIndex in the array.</summary>
            <remarks>
                <para>
                Returns a reference to the BigPoly at index polyIndex in the array. The returned BigPoly is an alias backed by 
                the BigPolyArray internal array. As such, it is only valid until the BigPolyArray instance is resized or destroyed.
                </para>
            </remarks>
            <exception cref="T:System.ArgumentOutOfRangeException">if polyIndex is not within [0, <see cref="P:Microsoft.Research.SEAL.BigPolyArray.Size" />)</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.UInt64Count">
            <summary>Returns the number of System::UInt64 allocated for the entire array of polynomials.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.PolyUInt64Count">
            <summary>Returns the number of System::UInt64 allocated for each polynomial.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.CoeffUInt64Count">
            <summary>Returns the number of System::UInt64 allocated for each coefficient of each polynomial.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPolyArray.CoeffBitCount">
            <summary>Returns the coefficient bit count of the polynomials.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPolyArray.CoeffCount">
            <summary>Returns the number of coefficients in the polynomials.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPolyArray.Size">
            <summary>Returns the number of polynomials.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.#ctor(Microsoft.Research.SEAL.BigPolyArray)">
            <summary>Creates a deep copy of an BigPolyArray instance.</summary>
            <remarks>Creates a deep copy of an BigPolyArray instance.</remarks>
            <param name="copy">The BigPolyArray instance to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.#ctor(System.Int32,System.Int32,System.Int32)">
            <summary>Creates a zero-initialized BigPolyArray instance with the specified size.</summary>
            <param name="size">The number of polynomials to allocate space for</param>
            <param name="coeffCount">The number of coefficients allocated for each polynomial in the array</param>
            <param name="coeffBitCount">The bit count of each polynomial in the array</param>
            <exception cref="T:System.ArgumentException">if size is negative</exception>
            <exception cref="T:System.ArgumentException">if coeffCount is negative</exception>
            <exception cref="T:System.ArgumentException">if coeffBitCount is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPolyArray.#ctor">
            <summary>Creates an empty BigPolyArray instance with a size of zero.</summary>
            <remarks>
                Creates an empty BigPolyArray instance with a size of zero. No memory is allocated by this constructor.
                </remarks>
        </member>
        <member name="T:Microsoft.Research.SEAL.BigPolyArray">
            <summary>Represents an array of BigPoly objects.</summary>
            <remarks>
                <para>
            Represents an array of BigPoly objects. The BigPolyArray class provides all of the functionality of a BigPoly array.
            The size of the array (which can be read with <see cref="P:Microsoft.Research.SEAL.BigPolyArray.Size" />) is set initially by the constructor and can be 
            resized either with the <see cref="M:Microsoft.Research.SEAL.BigPolyArray.Resize(System.Int32,System.Int32,System.Int32)" /> function or with the <see cref="M:Microsoft.Research.SEAL.BigPolyArray.Set(Microsoft.Research.SEAL.BigPolyArray)" /> function. 
            Each polynomial in the array must have the same coefficient count and coefficient bit count, which can be set in the 
            constructor or with the <see cref="M:Microsoft.Research.SEAL.BigPolyArray.Resize(System.Int32,System.Int32,System.Int32)" /> function, and read with <see cref="P:Microsoft.Research.SEAL.BigPolyArray.CoeffCount" /> and <see cref="P:Microsoft.Research.SEAL.BigPolyArray.CoeffBitCount" />.
            The index functions allow reading/writing individual BigPoly's in the array by returning references to them. 
            The array can be saved and loaded from a stream with the <see cref="M:Microsoft.Research.SEAL.BigPolyArray.Save(System.IO.Stream)" /> and <see cref="M:Microsoft.Research.SEAL.BigPolyArray.Load(System.IO.Stream)" /> functions.
            </para>
                <para>
            All of the polynomials in the array are stored in one continuous block in memory.
            </para>
                <para>
            In general, reading from a BigPolyArray instance is thread-safe while mutating is not. Specifically, the array may be freed
            whenever a <see cref="M:Microsoft.Research.SEAL.BigPolyArray.Resize(System.Int32,System.Int32,System.Int32)" /> occurs, the BigPolyArray instance is destroyed, or an assignment operation occurs, which 
            will invalidate the aliased BigPolys returned by the index functions.
            </para>
            </remarks>
        </member>
        <member name="F:seal.BigPolyArray.coeff_bit_count_">
The coefficient bit count of each polynomial in the BigPolyArray.

</member>
        <member name="F:seal.BigPolyArray.coeff_count_">
The coefficient count of each polynomial in the BigPolyArray.

</member>
        <member name="F:seal.BigPolyArray.size_">
The number of polynomials stored in the BigPolyArray.

</member>
        <member name="F:seal.BigPolyArray.polys_">
Points to an array of BigPolys for the return value of the operator[] function. Each BigPoly in polys_ is an alias that
points to the corresponding polynomial's location in the backing array value_. This pointer will be set to nullptr
if and only if size is zero.

</member>
        <member name="F:seal.BigPolyArray.value_">
The backing array for all of the polynomials in the BigPolyArray.

</member>
        <member name="M:seal.BigPolyArray.load(std.basic_istream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Loads an BigPolyArray instance from an input stream overwriting the current BigPolyArray instance.

		@param[in] stream The stream to load the BigPolyArray instance from
		@see save() to save an BigPolyArray instance.

</member>
        <member name="M:seal.BigPolyArray.save(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Saves the BigPolyArray instance to an output stream. The output is in binary format and not human-readable. The output
		stream must have the "binary" flag set.

		@param[in] stream The stream to save the BigPolyArray to
		@see load() to load a saved BigPolyArray instance.

</member>
        <member name="M:seal.BigPolyArray.op_Assign(seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Overwrites the BigPolyArray instance by moving the specified BigPolyArray instance. After assignment, the
		size of BigPolyArray matches the size of the original assigned BigPolyArray instance, and the memory location of
		the backing array is the same. The assigned instance is reset.

		@param[in] assign The BigPolyArray instance to whose value should be assigned to the current BigPolyArray instance

</member>
        <member name="M:seal.BigPolyArray.op_Assign(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Overwrites the BigPolyArray instance with a specified BigPolyArray instance. After assignment, the
		size of BigPolyArray matches the size of the assigned BigPolyArray instance.

		@param[in] assign The BigPolyArray instance to whose value should be assigned to the current BigPolyArray instance

</member>
        <member name="M:seal.BigPolyArray.reset">
Resets the BigPolyArray instance to an empty, zero-sized instance. Any space allocated by the BigPolyArray instance is
deallocated.

</member>
        <member name="M:seal.BigPolyArray.resize(System.Int32,System.Int32,System.Int32)">
		Resizes the BigPolyArray internal array to store the specified number of polynomials of the specified size, copying
		over the old polynomials as much as will fit.

		@param[in] size The number of polynomials to allocate space for
		@param[in] coeff_count The number of coefficients allocated for each polynomial in the array
		@param[in] coeff_bit_count The bit count of each polynomial in the array
		@throws std::invalid_argument if size is negative
		@throws std::invalid_argument if coeff_count is negative
		@throws std::invalid_argument if coeff_bit_count is negative

</member>
        <member name="M:seal.BigPolyArray.set_zero(System.Int32)">
		Sets the polynomial with index poly_index to have value zero. This does not resize the BigPolyArray or
		modify the other polynomials.

		@param[in] poly_index The index of the polynomial to set to zero
		@throws std::out_of_range If poly_index is not within [0, size())

</member>
        <member name="M:seal.BigPolyArray.set_zero">
Sets all polynomials to have a value of zero. This does not resize the BigPolyArray.

</member>
        <member name="M:seal.BigPolyArray.op_Subscript(System.Int32)">
		Returns a reference to the BigPoly at index poly_index in the array.

		@warning The returned BigPoly is an alias backed by the BigPolyArray internal array. As such, it is only valid until
		the BigPolyArray instance is resized or destroyed.
		@throws std::out_of_range If poly_index is not within [0, size())


		Returns a const reference to the BigPoly at index poly_index in the array.

		@warning The returned BigPoly is an alias backed by the BigPolyArray internal array. As such, it is only valid until
		the BigPolyArray instance is resized or destroyed.
		@throws std::out_of_range If poly_index is not within [0, size())

</member>
        <member name="M:seal.BigPolyArray.pointer(System.Int32)">
		Returns a pointer to the backing array storing all of the polynomials. The pointer points to the beginning
		of the backing array of the constant term of the polynomial at index given by parameter poly_index. The return value
		will be nullptr if the coefficient count and/or bit count is zero.

		@warning The pointer is valid only until the backing array is freed, which occurs when the BigPolyArray is resized or destroyed.
		@throws std::out_of_range If poly_index is not within [0, size())


		Returns a const pointer to the backing array storing all of the polynomials. The pointer points to the beginning
		of the backing array of the constant term of the polynomial at index given by parameter poly_index. The return value
		will be nullptr if the coefficient count and/or bit count is zero.

		@warning The pointer is valid only until the backing array is freed, which occurs when the BigPolyArray is resized or destroyed.
		@throws std::out_of_range If poly_index is not within [0, size())

</member>
        <member name="M:seal.BigPolyArray.uint64_count">
Returns the number of std::uint64_t allocated for the entire array of polynomials.

</member>
        <member name="M:seal.BigPolyArray.poly_uint64_count">
Returns the number of std::uint64_t allocated for each polynomial.

</member>
        <member name="M:seal.BigPolyArray.coeff_uint64_count">
Returns the number of std::uint64_t allocated for each coefficient of each polynomial.

</member>
        <member name="M:seal.BigPolyArray.coeff_bit_count">
Returns the coefficient bit count of the polynomials.

</member>
        <member name="M:seal.BigPolyArray.coeff_count">
Returns the number of coefficients in the polynomials.

</member>
        <member name="M:seal.BigPolyArray.size">
Returns the number of polynomials.

</member>
        <member name="M:seal.BigPolyArray.Dispose">
Destroys the BigPolyArray instance and deallocates the contained array.

</member>
        <member name="M:seal.BigPolyArray.#ctor(seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Creates a new BigPolyArray by moving from another instance. The BigPolyArray source will be reset.

		@param[in] source The BigPolyArray instance to move from

</member>
        <member name="M:seal.BigPolyArray.#ctor(seal.BigPolyArray!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
		Creates a deep copy of an BigPolyArray instance.

		@param[in] copy The BigPolyArray instance to copy from

</member>
        <member name="M:seal.BigPolyArray.#ctor(System.Int32,System.Int32,System.Int32)">
		Creates a zero-initialized BigPolyArray instance with the specified size.

		@param[in] size The number of polynomials to allocate space for
		@param[in] coeff_count The number of coefficients allocated for each polynomial in the array
		@param[in] coeff_bit_count The bit count of each polynomial in the array
		@throws std::invalid_argument if size is negative
		@throws std::invalid_argument if coeff_count is negative
		@throws std::invalid_argument if coeff_bit_count is negative

</member>
        <member name="M:seal.BigPolyArray.#ctor">
Creates an empty BigPolyArray instance with a size of zero. No memory is allocated by this constructor.

</member>
        <member name="T:seal.BigPolyArray">
	Represents an array of BigPoly objects. The BigPolyArray class provides all of the functionality of a BigPoly array. The size of
	the array (which can be read with size()) is set initially by the constructor and can be resized either with the resize()
	function or with assignment (operator=()). Each polynomial in the array must have the same coefficient count and coefficient
	bit count, which can be set in the constructor or with the resize() function, and read with coeff_count() and coeff_bit_count().
	The operator[] indexer functions allow reading/writing individual BigPoly's in the array by returning references to them.
	The array can be saved and loaded from a stream with the save() and load() functions.

	All of the polynomials in the array are stored in one continuous block in memory.

	@par Thread Safety
	In general, reading from a BigPolyArray instance is thread-safe while mutating is not. Specifically, the array may be freed
	whenever a resize() occurs, the BigPolyArray instance is destroyed, or an assignment operation occurs, which will invalidate
	the aliased BigPolys returned by operator[] function.

</member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.#ctor(seal.BigPoly*)">
            <summary>Initializes the BigPoly to use the specified C++ BigPoly.</summary>
            <remarks>
Initializes the BigPoly to use the specified C++ BigPoly. This constructor does not copy the C++ BigPoly but actually
uses the specified C++ BigPoly as the backing data. Upon destruction, the managed BigPoly will not destroy the C++
BigPoly.
</remarks>
            <param name="value">The BigPoly to use as the backing BigPoly</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.#ctor(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of a C++ BigPoly.</summary>
            <remarks>
                Creates a deep copy of a C++ BigPoly. The created BigPoly will have the same coefficient count, coefficient bit count,
                and coefficient values as the original.
                </remarks>
            <param name="value">The BigPoly to copy from</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.DuplicateFrom(Microsoft.Research.SEAL.BigPoly)">
            <summary>Duplicates a given BigPoly.</summary>
            <remarks>
Duplicates a given BigPoly. The coefficient count, the coefficient bit count,
and the value of the current BigPoly are set to be exactly the same as in the given one.
</remarks>
            <param name="value">The BigPoly to duplicate</param>
            <exception cref="T:System.ArgumentNullException">if value is null</exception>
            <exception cref="T:System.InvalidOperationException">if the current BigPoly is an alias</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.DuplicateTo(Microsoft.Research.SEAL.BigPoly)">
            <summary>Duplicates the current BigPoly.</summary>
            <remarks>
Duplicates the current BigPoly. The coefficient count, the coefficient bit count, and the value of the given BigPoly
are set to be exactly the same as in the current one.
</remarks>
            <param name="destination">The BigPoly to overwrite with the duplicate</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
            <exception cref="T:System.InvalidOperationException">if the destination BigPoly is an alias</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.GetPolynomial">
            <summary>Returns a reference to the underlying C++ BigPoly.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Finalize">
            <summary>Destroys the BigPoly, including deallocating any internally allocated space.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Dispose">
            <summary>Destroys the BigPoly, including deallocating any internally allocated space.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.GetHashCode">
            <summary>Returns a hash-code based on the value of the BigPoly.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.ToString">
            <summary>Returns a human-readable string description of the BigPoly.</summary>
            <remarks>
                <para>
                Returns a human-readable string description of the BigPoly.
                </para>
                <para>
                The returned string is of the form "7FFx^3 + 1x^1 + 3" with a format summarized by the following:
                <list type="number"><item><description>Terms are listed in order of strictly decreasing exponent</description></item><item><description>Coefficient values are non-negative and in hexadecimal format (hexadecimal letters are in upper-case)</description></item><item><description>Exponents are positive and in decimal format</description></item><item><description>Zero coefficient terms (including the constant term) are omitted unless the BigPoly is exactly 0 (see rule 9)</description></item><item><description>Term with the exponent value of one is written as x^1</description></item><item><description>Term with the exponent value of zero (the constant term) is written as just a hexadecimal number without x or exponent</description></item><item><description>Terms are separated exactly by &lt;space&gt;+&lt;space&gt;</description></item><item><description>Other than the +, no other terms have whitespace</description></item><item><description>If the BigPoly is exactly 0, the string "0" is returned</description></item></list></para>
            </remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Equals(System.Object)">
            <summary>Returns whether or not the BigPoly has the same value as a specified BigPoly.</summary>
            <remarks>
                Returns whether or not the BigPoly has the same value as a specified BigPoly. Value equality is not determined by the
                raw coefficient count or bit count, but rather if the significant bits of non-zero coefficients have the same value.
                </remarks>
            <param name="compare">The BigPoly to compare against</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Equals(Microsoft.Research.SEAL.BigPoly)">
            <summary>Returns whether or not the BigPoly has the same value as a specified BigPoly.</summary>
            <remarks>
                Returns whether or not the BigPoly has the same value as a specified BigPoly. Value equality is not determined by the
                raw coefficient count or bit count, but rather if the significant bits of non-zero coefficients have the same value.
                </remarks>
            <param name="compare">The BigPoly to compare against</param>
            <exception cref="T:System.ArgumentNullException">if compare is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Resize(System.Int32,System.Int32)">
            <summary>Resizes a BigPoly to the specified coefficient count and bit width, copying over and resizing existing coefficient values
                as much as will fit.</summary>
            <remarks>
                Resizes a BigPoly to the specified coefficient count and bit width, copying over and resizing existing coefficient values
                as much as will fit. If coefficient count is reduced, the leading coefficients are dropped. If coefficient count increases,
                the new coefficients are initialized to zero.
                </remarks>
            <param name="coeffCount">The number of coefficients</param>
            <param name="coeffBitCount">The bit width of each coefficient</param>
            <exception cref="T:System.ArgumentException">if either coeffCount or coeffBitCount is negative</exception>
            <exception cref="T:System.InvalidOperationException">if the BigPoly is an alias</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Load(System.IO.Stream)">
            <summary>Loads a BigPoly from an input stream overwriting the current BigPoly and enlarging if needed to fit the loaded
                BigPoly.</summary>
            <param name="stream">The stream to load the BigPoly from</param>
            <exception cref="T:System.ArgumentNullException">if stream is null</exception>
            <exception cref="T:System.InvalidOperationException">if BigPoly is an alias and the loaded polynomial is too large to fit the
                current coefficient count and/or bit width</exception>
            <seealso cref="M:Microsoft.Research.SEAL.BigPoly.Save(System.IO.Stream)">See Save() to save a BigPoly.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Save(System.IO.Stream)">
            <summary>Saves the BigPoly to an output stream.</summary>
            <remarks>
                Saves the BigPoly to an output stream. The full state of the BigPoly is serialized, including leading zero
                coefficients and insignificant coefficient bits. The output is in binary format and not human-readable. The
                output stream must have the "binary" flag set.
                </remarks>
            <param name="stream">The stream to save the BigPoly to</param>
            <exception cref="T:System.ArgumentNullException">if stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.BigPoly.Load(System.IO.Stream)">See Load() to load a saved BigPoly.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.SetZero(System.Int32,System.Int32)">
            <summary>Sets all coefficients within [startCoeff, startCoeff + length) to have a value of zero.</summary>
            <remarks>
                Sets all coefficients within [startCoeff, startCoeff + length) to have a value of zero. This does not resize the BigPoly
                or modify the other coefficients.
                </remarks>
            <param name="startCoeff">The index of the first coefficient to set to zero</param>
            <param name="coeffCount">The number of coefficients to set to zero</param>
            <exception cref="T:System.ArgumentOutOfRangeException">if startCoeff is not within [0, <see cref="P:Microsoft.Research.SEAL.BigPoly.CoeffCount" />]</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">if length is negative or start_coeff + length is not within
                [0, <see cref="P:Microsoft.Research.SEAL.BigPoly.CoeffCount" />]</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.SetZero(System.Int32)">
            <summary>Sets all coefficients within [startCoeff, coefficient count) to have a value of zero.</summary>
            <remarks>
                Sets all coefficients within [startCoeff, coefficient count) to have a value of zero. This does not resize the BigPoly or
                modify the other coefficients.
                </remarks>
            <param name="startCoeff">The index of the first coefficient to set to zero</param>
            <exception cref="T:System.ArgumentOutOfRangeException">if startCoeff is not within [0, <see cref="P:Microsoft.Research.SEAL.BigPoly.CoeffCount" />]</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.SetZero">
            <summary>Sets all coefficients to have a value of zero.</summary>
            <remarks>Sets all coefficients to have a value of zero. This does not resize the BigPoly.</remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Set(System.String)">
            <summary>Overwrites the BigPoly with the value of the polynomial described by the formatted string, enlarging if needed to fit
                the assigned value.</summary>
            <remarks>
                <para>
                Overwrites the BigPoly with the value of the polynomial described by the formatted string, enlarging if needed to fit
                the assigned value.
                </para>
                <para>
                The string description of the polynomial must adhere to the format returned by <see cref="M:Microsoft.Research.SEAL.BigPoly.ToString" />, which is of the form
                "7FFx^3 + 1x^1 + 3" and summarized by the following rules:
                <list type="number"><item><description>Terms are listed in order of strictly decreasing exponent</description></item><item><description>Coefficient values are non-negative and in hexadecimal format (upper and lower case letters are both supported)</description></item><item><description>Exponents are positive and in decimal format</description></item><item><description>Zero coefficient terms (including the constant term) may be (but do not have to be) omitted</description></item><item><description>Term with the exponent value of one is written as x^1</description></item><item><description>Term with the exponent value of zero (the constant term) is written as just a hexadecimal number without x or exponent</description></item><item><description>Terms are separated exactly by &lt;space&gt;+&lt;space&gt;</description></item><item><description>Other than the +, no other terms have whitespace</description></item></list></para>
            </remarks>
            <param name="assign">The formatted polynomial string specifying the value to set</param>
            <exception cref="T:System.ArgumentNullException">if assign is null</exception>
            <exception cref="T:System.ArgumentException">if assign does not adhere to the expected format</exception>
            <exception cref="T:System.InvalidOperationException">if BigPoly is an alias and the assigned polynomial is too large to fit the
                current coefficient count and/or bit width</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.Set(Microsoft.Research.SEAL.BigPoly)">
            <summary>Overwrites the BigPoly with the value of the specified BigPoly, enlarging if needed to fit the assigned value.</summary>
            <remarks>
                Overwrites the BigPoly with the value of the specified BigPoly, enlarging if needed to fit the assigned value.
                Only significant coefficients and significant coefficient bit counts are used to size the BigPoly.
                </remarks>
            <param name="assign">The BigPoly whose value should be assigned to the current BigPoly</param>
            <exception cref="T:System.ArgumentNullException">if assign is null</exception>
            <exception cref="T:System.InvalidOperationException">if BigPoly is an alias and the assigned BigPoly is too large to fit the current
                coefficient count and/or bit width</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.GetSignificantCoeffBitCount">
            <summary>Returns the number of significant bits of the largest coefficient in the BigPoly.</summary>
            <seealso cref="P:Microsoft.Research.SEAL.BigPoly.CoeffBitCount">See CoeffBitCount to instead return the coefficient bit count regardless of leading zero bits.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.GetSignificantCoeffCount">
            <summary>Returns the coefficient count for the BigPoly ignoring all of the highest coefficients that have value zero.</summary>
            <seealso cref="P:Microsoft.Research.SEAL.BigPoly.CoeffCount">See CoeffCount to instead return the coefficient count regardless of the number of leading zero terms.
                </seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPoly.default(System.Int32)">
            <summary>Returns a BigUInt that can read or write the coefficient at the specified index.</summary>
            <remarks>
                <para>
                Returns a BigUInt that can read or write the coefficient at the specified index. The BigUInt is an aliased BigUInt that points
                directly to the backing array of the BigPoly.
                </para>
                <para>
                The returned BigUInt is an alias backed by a region of the BigPoly's backing array. As such, it is only valid until
                the BigPoly is resized or destroyed.
                </para>
            </remarks>
            <param name="index">The index of the coefficient to read/write</param>
            <exception cref="T:System.ArgumentOutOfRangeException">if index is not within [0, <see cref="P:Microsoft.Research.SEAL.BigPoly.CoeffCount" />)</exception>
            <seealso cref="T:Microsoft.Research.SEAL.BigUInt">See BigUInt for operations that can be performed on the coefficients.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPoly.IsZero">
            <summary>Returns whether or not the BigPoly has all zero coefficients.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPoly.Pointer">
            <summary>Returns a pointer to the backing array storing all of the coefficient values.</summary>
            <remarks>
                <para>
                Returns a pointer to the backing array storing all of the coefficient values. The pointer points to the beginning of the
                backing array where all coefficients are stored sequentially. The pointer points to the coefficient for the constant
                (degree 0) term of the BigPoly. Note that the return value will be null if the coefficient count and/or bit count is zero.
                </para>
                <para>
                The pointer is valid only until the backing array is freed, which occurs when the BigPoly is resized or destroyed.
                </para>
            </remarks>
            <seealso cref="P:Microsoft.Research.SEAL.BigPoly.CoeffUInt64Count">See CoeffUInt64Count to determine the number of System::UInt64 values used for each
                coefficient in the backing array.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.BigPoly">See BigPoly for a more detailed description of the format of the backing array.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPoly.CoeffUInt64Count">
            <summary>Returns the number of System::UInt64 in the backing array used to store each coefficient.</summary>
            <seealso cref="P:Microsoft.Research.SEAL.BigPoly.UInt64Count">See UInt64Count to determine the total number of System::UInt64 values used to
                store all of the coefficients.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.BigPoly">See BigPoly for a more detailed description of the format of the backing array.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPoly.UInt64Count">
            <summary>Returns the total number of System::UInt64 in the backing array to store all of the coefficients of the BigPoly.</summary>
            <seealso cref="P:Microsoft.Research.SEAL.BigPoly.CoeffUInt64Count">See CoeffUInt64Count to determine the number of System::UInt64 values used for each
                individual coefficient.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.BigPoly">See BigPoly for a more detailed description of the format of the backing array.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPoly.CoeffBitCount">
            <summary>Returns the number of bits per coefficient.</summary>
            <seealso cref="M:Microsoft.Research.SEAL.BigPoly.GetSignificantCoeffBitCount">See GetSignificantCoeffBitCount() to instead get the number of significant bits of the
                largest coefficient in the BigPoly.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPoly.CoeffCount">
            <summary>Returns the coefficient count for the BigPoly.</summary>
            <seealso cref="M:Microsoft.Research.SEAL.BigPoly.GetSignificantCoeffCount">See GetSignificantCoeffCount() to instead ignore the leading coefficients that have a value
                of zero.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigPoly.IsAlias">
            <summary>Returns whether or not the BigPoly is an alias.</summary>
            <seealso cref="T:Microsoft.Research.SEAL.BigPoly">See BigPoly for a detailed description of aliased BigPolys.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.#ctor(Microsoft.Research.SEAL.BigPoly)">
            <summary>Creates a deep copy of a BigPoly.</summary>
            <remarks>
                Creates a deep copy of a BigPoly. The created BigPoly will have the same coefficient count, coefficient bit count,
                and coefficient values as the original.
                </remarks>
            <param name="copy">The BigPoly to copy from</param>
            <exception cref="T:System.ArgumentNullException">if copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.#ctor(System.Int32,System.Int32,System.String)">
            <summary>Creates a BigPoly of the specified coefficient count and bit width and initializes it with the polynomial described by
                the formatted string.</summary>
            <remarks>
                <para>
                Creates a BigPoly of the specified coefficient count and bit width and initializes it with the polynomial described by
                the formatted string.
                </para>
                <para>
                The string description of the polynomial must adhere to the format returned by <see cref="M:Microsoft.Research.SEAL.BigPoly.ToString" />, which is of the form
                "7FFx^3 + 1x^1 + 3" and summarized by the following rules:
                <list type="number"><item><description>Terms are listed in order of strictly decreasing exponent</description></item><item><description>Coefficient values are non-negative and in hexadecimal format (upper and lower case letters are both supported)</description></item><item><description>Exponents are positive and in decimal format</description></item><item><description>Zero coefficient terms (including the constant term) may be (but do not have to be) omitted</description></item><item><description>Term with the exponent value of one is written as x^1</description></item><item><description>Term with the exponent value of zero (the constant term) is written as just a hexadecimal number without x or exponent</description></item><item><description>Terms are separated exactly by &lt;space&gt;+&lt;space&gt;</description></item><item><description>Other than the +, no other terms have whitespace</description></item></list></para>
            </remarks>
            <param name="coeffCount">The number of coefficients</param>
            <param name="coeffBitCount">The bit width of each coefficient</param>
            <param name="hexPoly">The formatted polynomial string specifying the initial value</param>
            <exception cref="T:System.ArgumentException">if either coeffCount or coeffBitCount is negative</exception>
            <exception cref="T:System.ArgumentNullException">if hexPoly is null</exception>
            <exception cref="T:System.ArgumentException">if hexPoly does not adhere to the expected format</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.#ctor(System.String)">
            <summary>Creates a BigPoly populated and minimally sized to fit the polynomial described by the formatted string.</summary>
            <remarks>
                <para>
                Creates a BigPoly populated and minimally sized to fit the polynomial described by the formatted string.
                </para>
                <para>
                The string description of the polynomial must adhere to the format returned by <see cref="M:Microsoft.Research.SEAL.BigPoly.ToString" />, which is of the form
                "7FFx^3 + 1x^1 + 3" and summarized by the following rules:
                <list type="number"><item><description>Terms are listed in order of strictly decreasing exponent</description></item><item><description>Coefficient values are non-negative and in hexadecimal format (upper and lower case letters are both supported)</description></item><item><description>Exponents are positive and in decimal format</description></item><item><description>Zero coefficient terms (including the constant term) may be (but do not have to be) omitted</description></item><item><description>Term with the exponent value of one is written as x^1</description></item><item><description>Term with the exponent value of zero (the constant term) is written as just a hexadecimal number without x or exponent</description></item><item><description>Terms are separated exactly by &lt;space&gt;+&lt;space&gt;</description></item><item><description>Other than the +, no other terms have whitespace</description></item></list></para>
            </remarks>
            <param name="hexPoly">The formatted polynomial string specifying the initial value</param>
            <exception cref="T:System.ArgumentNullException">if hexPoly is null</exception>
            <exception cref="T:System.ArgumentException">if hexPoly does not adhere to the expected format</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.#ctor(System.Int32,System.Int32)">
            <summary>Creates a zero-initialized BigPoly of the specified coefficient count and bit width.</summary>
            <param name="coeffCount">The number of coefficients</param>
            <param name="coeffBitCount">The bit width of each coefficient</param>
            <exception cref="T:System.ArgumentException">if either coeffCount or coeffBitCount is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigPoly.#ctor">
            <summary>Creates an empty BigPoly with zero coefficients and zero coefficient bit width.</summary>
            <remarks>
Creates an empty BigPoly with zero coefficients and zero coefficient bit width. No memory is allocated by this
constructor.
</remarks>
        </member>
        <member name="T:Microsoft.Research.SEAL.BigPoly">
            <summary>Represents a polynomial consisting of a set of unsigned integer coefficients with a specified bit width.</summary>
            <remarks>
                <para>
            Represents a polynomial consisting of a set of unsigned integer coefficients with a specified bit width.
            BigPolys are mutable and able to be resized. Individual coefficients can be read/written through the
            indexer property. A BigPoly has a set coefficient count (which can be read with <see cref="P:Microsoft.Research.SEAL.BigPoly.CoeffCount" />)
            and coefficient bit width (which can be read with <see cref="P:Microsoft.Research.SEAL.BigPoly.CoeffBitCount" />), and all coefficients in a BigPoly have
            the same bit width. The coefficient count and bit width of a BigPoly is set initially by the constructor, and
            can be resized either explicitly with the <see cref="M:Microsoft.Research.SEAL.BigPoly.Resize(System.Int32,System.Int32)" /> function, or implicitly with for example 
            assignment.
            </para>
                <para>
            A BigPoly's coefficients are stored sequentially, index-zero coefficient first, in a contiguous System::UInt64
            array. The width of each coefficient is rounded up to the next System::UInt64 width (i.e., to the next 64-bit
            boundary). The <see cref="P:Microsoft.Research.SEAL.BigPoly.CoeffUInt64Count" /> function returns the number of System::UInt64 values used per
            coefficient. The <see cref="P:Microsoft.Research.SEAL.BigPoly.UInt64Count" /> function returns the number of System::UInt64 values used to store
            all coefficients. Each coefficient is stored in an identical format to <see cref="T:Microsoft.Research.SEAL.BigUInt" />, with the least quad word first
            and the order of bits for each quad word dependent on the architecture's System::UInt64 representation. For
            each coefficient, the bits higher than the coefficient bit count must be set to zero to prevent undefined behavior. The
            <see cref="P:Microsoft.Research.SEAL.BigPoly.Pointer" /> function returns a pointer to the first System::UInt64 of the array.
            </para>
                <para>
            Both the copy constructor and the Set function allocate more memory for the backing array when needed, 
            i.e. when the source polynomial has a larger backing array than the destination. Conversely, when the destination 
            backing array is already large enough, the data is only copied and the unnecessary higher degree coefficients 
            are set to zero. When new memory has to be allocated, only the significant coefficients of the source polynomial
            are taken into account. This is is important, because it avoids unnecessary zero coefficients to be included
            in the destination, which in some cases could accumulate and result in very large unnecessary allocations.
            However, sometimes it is necessary to preserve the original coefficient count, even if some of the
            leading coefficients are zero. This comes up for example when copying individual polynomials of ciphertext
            <see cref="T:Microsoft.Research.SEAL.BigPolyArray" /> objects, as these polynomials need to have the leading coefficient equal to zero to 
            be considered valid by classes such as <see cref="T:Microsoft.Research.SEAL.Evaluator" /> and <see cref="T:Microsoft.Research.SEAL.Decryptor" />. For this purpose 
            BigPoly contains functions <see cref="M:Microsoft.Research.SEAL.BigPoly.DuplicateFrom(Microsoft.Research.SEAL.BigPoly)" /> and <see cref="M:Microsoft.Research.SEAL.BigPoly.DuplicateTo(Microsoft.Research.SEAL.BigPoly)" />, which create an exact 
            copy of the source BigPoly.
            </para>
                <para>
            An aliased BigPoly (which can be determined with <see cref="P:Microsoft.Research.SEAL.BigPoly.IsAlias" />) is a special type of BigPoly that does not manage
            its underlying System::UInt64 pointer that stores the coefficients. An aliased BigPoly supports most of the
            same operations as a non-aliased BigPoly, including reading/writing the coefficients and assignment, however an
            aliased BigPoly does not internally allocate or deallocate its backing array and, therefore, does not support resizing.
            Any attempt, either explicitly or implicitly, to resize the BigPoly will result in an exception being thrown. Aliased
            BigPoly's are only created internally.
            </para>
                <para>
            In general, reading a BigPoly is thread-safe while mutating is not. Specifically, the backing array may be freed
            whenever a resize occurs or the BigPoly is destroyed, which would invalidate the address returned by <see cref="P:Microsoft.Research.SEAL.BigPoly.Pointer" />
            and the coefficients returned by the indexer property. When it is known a resize will not occur, concurrent reading and
            mutating is safe as long as it is known that concurrent reading and mutating for the same coefficient will not occur,
            as the reader may see a partially updated coefficient value.
            </para>
            </remarks>
            <seealso cref="T:Microsoft.Research.SEAL.BigPolyArithmetic">See BigPolyArithmetic for arithmetic and modular functions on BigPolys.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.BigUInt">See BigUInt for more details on the coefficients returned by this[int].</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor(seal.BigUInt*)">
            <summary>Initializes the BigUInt to use the specified C++ BigUInt.</summary>
            <remarks>
Initializes the BigUInt to use the specified C++ BigUInt. This constructor does not copy the C++ BigUInt but actually
uses the specified C++ BigUInt as the backing data. Upon destruction, the managed BigUInt will not destroy the C++
BigUInt.
</remarks>
            <param name="value">The BigUInt to use as the backing BigUInt</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
            <summary>Creates a deep copy of a C++ BigUInt.</summary>
            <remarks>
                Creates a deep copy of a BigUInt. The created BigUInt will have the same bit count and value as the original.
                </remarks>
            <param name="value">The BigUInt to copy from</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.DuplicateFrom(Microsoft.Research.SEAL.BigUInt)">
            <summary>Duplicates a given BigUInt.</summary>
            <remarks>
Duplicates a given BigUInt. The bit count and the value of the current BigUInt
are set to be exactly the same as in the given one.
</remarks>
            <param name="value">The BigUInt to duplicate</param>
            <exception cref="T:System.ArgumentNullException">if value is null</exception>
            <exception cref="T:System.InvalidOperationException">if the current BigUInt is an alias</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.DuplicateTo(Microsoft.Research.SEAL.BigUInt)">
            <summary>Duplicates the current BigUInt.</summary>
            <remarks>
Duplicates the current BigUInt. The bit count and the value of the given BigUInt are set to be exactly the same as in
the current one.
</remarks>
            <param name="destination">The BigUInt to overwrite with the duplicate</param>
            <exception cref="T:System.ArgumentNullException">if destination is null</exception>
            <exception cref="T:System.InvalidOperationException">if the destination BigUInt is an alias</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.GetUInt">
            <summary>Returns a reference to the underlying C++ BigUInt.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Of(System.UInt64)">
            <summary>Creates a minimally sized BigUInt initialized to the specified unsigned integer value.</summary>
            <param name="value">The value to initialized the BigUInt to</param>
            <exception cref="T:System.ArgumentNullException">If value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Explicit(Microsoft.Research.SEAL.BigUInt)~System.Int32">
            <summary>Returns the lower 32-bits of a BigUInt value as a signed-integer.</summary>
            <remarks>
Returns the lower 32-bits of a BigUInt value as a signed-integer. Note that if the value is greater than
32-bits, the result may be negative and the higher bits are dropped.
</remarks>
            <param name="value">The value to convert</param>
            <exception cref="T:System.ArgumentNullException">If value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Explicit(Microsoft.Research.SEAL.BigUInt)~System.UInt32">
            <summary>Returns the lower 32-bits of a BigUInt value.</summary>
            <remarks>
Returns the lower 32-bits of a BigUInt value. Note that if the value is greater than 32-bits,
the higher bits are dropped.
</remarks>
            <param name="value">The value to convert</param>
            <exception cref="T:System.ArgumentNullException">If value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Explicit(Microsoft.Research.SEAL.BigUInt)~System.Int64">
            <summary>Returns the lower 64-bits of a BigUInt value as a signed-integer.</summary>
            <remarks>
Returns the lower 64-bits of a BigUInt value as a signed-integer. Note that if the value is greater than
64-bits, the result may be negative and the higher bits are dropped.
</remarks>
            <param name="value">The value to convert</param>
            <exception cref="T:System.ArgumentNullException">If value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Explicit(Microsoft.Research.SEAL.BigUInt)~System.UInt64">
            <summary>Returns the lower 64-bits of a BigUInt value.</summary>
            <remarks>
Returns the lower 64-bits of a BigUInt value. Note that if the value is greater than 64-bits,
the higher bits are dropped.
</remarks>
            <param name="value">The value to convert</param>
            <exception cref="T:System.ArgumentNullException">If value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Explicit(Microsoft.Research.SEAL.BigUInt)~System.Single">
            <summary>Returns the BigUInt value as a float.</summary>
            <remarks>
Returns the BigUInt value as a float. Note that precision may be lost during the conversion.
</remarks>
            <param name="value">The value to convert</param>
            <exception cref="T:System.ArgumentNullException">If value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Explicit(Microsoft.Research.SEAL.BigUInt)~System.Double">
            <summary>Returns the BigUInt value as a double.</summary>
            <remarks>
Returns the BigUInt value as a double. Note that precision may be lost during the conversion.
</remarks>
            <param name="value">The value to convert</param>
            <exception cref="T:System.ArgumentNullException">If value is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_RightShift(Microsoft.Research.SEAL.BigUInt,System.Int32)">
            <summary>Returns a right-shifted copy of the BigUInt.</summary>
            <remarks>
                Returns a right-shifted copy of the BigUInt. The bit count of the returned value is the original significant bit count
                subtracted by the shift amount (clipped to zero if negative).
                </remarks>
            <param name="operand1">The operand to right-shift</param>
            <param name="shift">The number of bits to shift by</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
            <exception cref="T:System.ArgumentException">If shift is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_LeftShift(Microsoft.Research.SEAL.BigUInt,System.Int32)">
            <summary>Returns a left-shifted copy of the BigUInt.</summary>
            <remarks>
                Returns a left-shifted copy of the BigUInt. The bit count of the returned value is the sum of the original significant
                bit count and the shift amount.
                </remarks>
            <param name="operand1">The operand to left-shift</param>
            <param name="shift">The number of bits to shift by</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
            <exception cref="T:System.ArgumentException">If shift is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_BitwiseOr(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Performs a bit-wise OR operation between a BigUInt and an unsigned integer and returns the result.</summary>
            <remarks>
                Performs a bit-wise OR operation between a BigUInt and an unsigned integer and returns the result. The input operands
                are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.
                </remarks>
            <param name="operand1">The first operand to OR</param>
            <param name="operand2">The second operand to OR</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_BitwiseOr(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Performs a bit-wise OR operation between two BigUInts and returns the result.</summary>
            <remarks>
                Performs a bit-wise OR operation between two BigUInts and returns the result. The input operands are not modified. The
                bit count of the result is set to the maximum of the two input operand bit counts.
                </remarks>
            <param name="operand1">The first operand to OR</param>
            <param name="operand2">The second operand to OR</param>
            <exception cref="T:System.ArgumentNullException">If operand1 or operand2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_BitwiseAnd(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Performs a bit-wise AND operation between a BigUInt and an unsigned integer and returns the result.</summary>
            <remarks>
                Performs a bit-wise AND operation between a BigUInt and an unsigned integer and returns the result. The input operands
                are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.
                </remarks>
            <param name="operand1">The first operand to AND</param>
            <param name="operand2">The second operand to AND</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_BitwiseAnd(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Performs a bit-wise AND operation between two BigUInts and returns the result.</summary>
            <remarks>
                Performs a bit-wise AND operation between two BigUInts and returns the result. The input operands are not modified. The
                bit count of the result is set to the maximum of the two input operand bit counts.
                </remarks>
            <param name="operand1">The first operand to AND</param>
            <param name="operand2">The second operand to AND</param>
            <exception cref="T:System.ArgumentNullException">If operand1 or operand2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_ExclusiveOr(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Performs a bit-wise XOR operation between a BigUInt and an unsigned integer and returns the result.</summary>
            <remarks>
                Performs a bit-wise XOR operation between a BigUInt and an unsigned integer and returns the result. The input operands
                are not modified. The bit count of the result is set to the maximum of the two input operand bit counts.
                </remarks>
            <param name="operand1">The first operand to XOR</param>
            <param name="operand2">The second operand to XOR</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_ExclusiveOr(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Performs a bit-wise XOR operation between two BigUInts and returns the result.</summary>
            <remarks>
                Performs a bit-wise XOR operation between two BigUInts and returns the result. The input operands are not modified. The
                bit count of the result is set to the maximum of the two input operand bit counts.
                </remarks>
            <param name="operand1">The first operand to XOR</param>
            <param name="operand2">The second operand to XOR</param>
            <exception cref="T:System.ArgumentNullException">If operand1 or operand2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Modulus(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Divides a BigUInt and an unsigned integer and returns the remainder.</summary>
            <remarks>
                Divides a BigUInt and an unsigned integer and returns the remainder. The input operands are not modified. The bit count
                of the remainder is set to be the significant bit count of the first input operand.
                </remarks>
            <param name="operand1">The first operand to divide</param>
            <param name="operand2">The second operand to divide</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
            <exception cref="T:System.ArgumentException">If operand2 is zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Modulus(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Divides two BigUInts and returns the remainder.</summary>
            <remarks>
                Divides two BigUInts and returns the remainder. The input operands are not modified. The bit count of the remainder is
                set to be the significant bit count of the first input operand.
                </remarks>
            <param name="operand1">The first operand to divide</param>
            <param name="operand2">The second operand to divide</param>
            <exception cref="T:System.ArgumentNullException">If operand1 or operand2 is null</exception>
            <exception cref="T:System.ArgumentException">If operand2 is zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Division(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Divides a BigUInt and an unsigned integer and returns the quotient.</summary>
            <remarks>
                Divides a BigUInt and an unsigned integer and returns the quotient. The input operands are not modified. The bit count
                of the quotient is set to be the significant bit count of the first input operand.
                </remarks>
            <param name="operand1">The first operand to divide</param>
            <param name="operand2">The second operand to divide</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
            <exception cref="T:System.ArgumentException">If operand2 is zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Division(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Divides two BigUInts and returns the quotient.</summary>
            <remarks>
                Divides two BigUInts and returns the quotient. The input operands are not modified. The bit count of the quotient is
                set to be the significant bit count of the first input operand.
                </remarks>
            <param name="operand1">The first operand to divide</param>
            <param name="operand2">The second operand to divide</param>
            <exception cref="T:System.ArgumentNullException">If operand1 or operand2 is null</exception>
            <exception cref="T:System.ArgumentException">If operand2 is zero</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Multiply(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Multiplies a BigUInt and an unsigned integer and returns the product.</summary>
            <remarks>
                Multiplies a BigUInt and an unsigned integer and returns the product. The input operands are not modified. The bit
                count of the product is set to be the sum of the significant bit counts of the two input operands.
                </remarks>
            <param name="operand1">The first operand to multiply</param>
            <param name="operand2">The second operand to multiply</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Multiply(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Multiplies two BigUInts and returns the product.</summary>
            <remarks>
                Multiplies two BigUInts and returns the product. The input operands are not modified. The bit count of the product is
                set to be the sum of the significant bit counts of the two input operands.
                </remarks>
            <param name="operand1">The first operand to multiply</param>
            <param name="operand2">The second operand to multiply</param>
            <exception cref="T:System.ArgumentNullException">If operand1 or operand2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Subtraction(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Subtracts a BigUInt and an unsigned integer and returns the difference.</summary>
            <remarks>
                Subtracts a BigUInt and an unsigned integer and returns the difference. The input operands are not modified. The bit
                count of the difference is set to be the significant bit count of the larger of the two operands.
                </remarks>
            <param name="operand1">The first operand to subtract</param>
            <param name="operand2">The second operand to subtract</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Subtraction(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Subtracts two BigUInts and returns the difference.</summary>
            <remarks>
                Subtracts two BigUInts and returns the difference. The input operands are not modified. The bit count of the difference
                is set to be the significant bit count of the larger of the two input operands.
                </remarks>
            <param name="operand1">The first operand to subtract</param>
            <param name="operand2">The second operand to subtract</param>
            <exception cref="T:System.ArgumentNullException">If operand1 or operand2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Addition(Microsoft.Research.SEAL.BigUInt,System.UInt64)">
            <summary>Adds a BigUInt and an unsigned integer and returns the sum.</summary>
            <remarks>
                Adds a BigUInt and an unsigned integer and returns the sum. The input operands are not modified. The bit count of the
                sum is set to be one greater than the significant bit count of the larger of the two operands.
                </remarks>
            <param name="operand1">The first operand to add</param>
            <param name="operand2">The second operand to add</param>
            <exception cref="T:System.ArgumentNullException">If operand1 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Addition(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Adds two BigUInts and returns the sum.</summary>
            <remarks>
                Adds two BigUInts and returns the sum. The input operands are not modified. The bit count of the sum is set to be one
                greater than the significant bit count of the larger of the two input operands.
                </remarks>
            <param name="operand1">The first operand to add</param>
            <param name="operand2">The second operand to add</param>
            <exception cref="T:System.ArgumentNullException">If operand1 or operand2 is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Decrement(Microsoft.Research.SEAL.BigUInt)">
            <summary>Decrements the BigUInt and returns the decremented value.</summary>
            <remarks>
                Decrements the BigUInt and returns the decremented value. The bit count does not change.
                </remarks>
            <param name="operand">The operand to decrement</param>
            <exception cref="T:System.ArgumentNullException">If operand is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_Increment(Microsoft.Research.SEAL.BigUInt)">
            <summary>Increments the BigUInt and returns the incremented value.</summary>
            <remarks>
                Increments the BigUInt and returns the incremented value. The BigUInt will increment the bit count if needed to fit the
                carry.
                </remarks>
            <param name="operand">The operand to increment</param>
            <exception cref="T:System.ArgumentNullException">If operand is null</exception>
            <exception cref="T:System.InvalidOperationException">If BigUInt is an alias and a carry occurs requiring the BigUInt to
                be resized</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_OnesComplement(Microsoft.Research.SEAL.BigUInt)">
            <summary>Returns an inverted copy of the BigUInt value.</summary>
            <remarks>
                Returns an inverted copy of the BigUInt value. The bit count does not change.
                </remarks>
            <param name="operand">The operand to invert</param>
            <exception cref="T:System.ArgumentNullException">If operand is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_UnaryNegation(Microsoft.Research.SEAL.BigUInt)">
            <summary>Returns a negated copy of the BigUInt value.</summary>
            <remarks>
                Returns a negated copy of the BigUInt value. The bit count does not change.
                </remarks>
            <param name="operand">The operand to negate</param>
            <exception cref="T:System.ArgumentNullException">If operand is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.op_UnaryPlus(Microsoft.Research.SEAL.BigUInt)">
            <summary>Returns a copy of the BigUInt value resized to the significant bit count.</summary>
            <param name="operand">The operand to copy</param>
            <exception cref="T:System.ArgumentNullException">If operand is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.TryModuloInvert(System.UInt64,Microsoft.Research.SEAL.BigUInt)">
            <summary>Attempts to calculate the inverse of a BigUInt with respect to the specified modulus, returning whether or not
                the inverse was successful and setting the inverse parameter to the inverse.</summary>
            <remarks>
                Attempts to calculate the inverse of a BigUInt with respect to the specified modulus, returning whether or not the
                inverse was successful and setting the inverse parameter to the inverse. The original BigUInt is not modified. The
                inverse parameter is resized if and only if its bit count is smaller than the significant bit count of the modulus.
                </remarks>
            <param name="modulus">The modulus to calculate the inverse with respect to</param>
            <param name="inverse">Stores the inverse if the inverse operation was successful</param>
            <exception cref="T:System.ArgumentNullException">If inverse is null</exception>
            <exception cref="T:System.ArgumentException">If modulus is zero</exception>
            <exception cref="T:System.ArgumentException">If modulus is not greater than the BigUInt value</exception>
            <exception cref="T:System.InvalidOperationException">If the inverse is an alias which the function attempts to enlarge
                to fit the result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.TryModuloInvert(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Attempts to calculate the inverse of a BigUInt with respect to the specified modulus, returning whether or not
                the inverse was successful and setting the inverse parameter to the inverse.</summary>
            <remarks>
                Attempts to calculate the inverse of a BigUInt with respect to the specified modulus, returning whether or not the
                inverse was successful and setting the inverse parameter to the inverse. The original BigUInt is not modified. The
                inverse parameter is resized if and only if its bit count is smaller than the significant bit count of the modulus.
                </remarks>
            <param name="modulus">The modulus to calculate the inverse with respect to</param>
            <param name="inverse">Stores the inverse if the inverse operation was successful</param>
            <exception cref="T:System.ArgumentNullException">If modulus or inverse is null</exception>
            <exception cref="T:System.ArgumentException">If modulus is zero</exception>
            <exception cref="T:System.ArgumentException">If modulus is not greater than the BigUInt value</exception>
            <exception cref="T:System.InvalidOperationException">If the inverse is an alias which the function attempts to enlarge
                to fit the result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.ModuloInvert(System.UInt64)">
            <summary>Returns the inverse of a BigUInt with respect to the specified modulus.</summary>
            <remarks>
                Returns the inverse of a BigUInt with respect to the specified modulus. The original BigUInt is not modified. The bit
                count of the inverse is set to be the significant bit count of the modulus.
                </remarks>
            <param name="modulus">The modulus to calculate the inverse with respect to</param>
            <exception cref="T:System.ArgumentException">If modulus is zero</exception>
            <exception cref="T:System.ArgumentException">If modulus is not greater than the BigUInt value</exception>
            <exception cref="T:System.ArgumentException">If the BigUInt value and modulus are not co-prime</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.ModuloInvert(Microsoft.Research.SEAL.BigUInt)">
            <summary>Returns the inverse of a BigUInt with respect to the specified modulus.</summary>
            <remarks>
                Returns the inverse of a BigUInt with respect to the specified modulus. The original BigUInt is not modified. The bit
                count of the inverse is set to be the significant bit count of the modulus.
                </remarks>
            <param name="modulus">The modulus to calculate the inverse with respect to</param>
            <exception cref="T:System.ArgumentNullException">If modulus is null</exception>
            <exception cref="T:System.ArgumentException">If modulus is zero</exception>
            <exception cref="T:System.ArgumentException">If modulus is not greater than the BigUInt value</exception>
            <exception cref="T:System.ArgumentException">If the BigUInt value and modulus are not co-prime</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.DivideRemainder(System.UInt64,Microsoft.Research.SEAL.BigUInt)">
            <summary>Divides a BigUInt and an unsigned integer and returns the quotient and sets the remainder parameter to the
                remainder.</summary>
            <remarks>
                Divides a BigUInt and an unsigned integer and returns the quotient and sets the remainder parameter to the remainder.
                The bit count of the quotient is set to be the significant bit count of the BigUInt. The remainder is resized if and
                only if it is smaller than the bit count of the BigUInt.
                </remarks>
            <param name="operand2">The second operand to divide</param>
            <param name="remainder">The BigUInt to store the remainder</param>
            <exception cref="T:System.ArgumentNullException">If remainder is null</exception>
            <exception cref="T:System.ArgumentException">If operand2 is zero</exception>
            <exception cref="T:System.InvalidOperationException">If the remainder is an alias which the function attempts to enlarge
                to fit the result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.DivideRemainder(Microsoft.Research.SEAL.BigUInt,Microsoft.Research.SEAL.BigUInt)">
            <summary>Divides two BigUInts and returns the quotient and sets the remainder parameter to the remainder.</summary>
            <remarks>
                Divides two BigUInts and returns the quotient and sets the remainder parameter to the remainder. The bit count of the
                quotient is set to be the significant bit count of the BigUInt. The remainder is resized if and only if it is smaller
                than the bit count of the BigUInt.
                </remarks>
            <param name="operand2">The second operand to divide</param>
            <param name="remainder">The BigUInt to store the remainder</param>
            <exception cref="T:System.ArgumentNullException">If operand2 or remainder is null</exception>
            <exception cref="T:System.ArgumentException">If operand2 is zero</exception>
            <exception cref="T:System.InvalidOperationException">If the remainder is an alias and the operator attempts to enlarge
                the BigUInt to fit the result</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.CompareTo(System.UInt64)">
            <summary>Compares a BigUInt and an unsigned integer and returns -1, 0, or 1 if the BigUInt is less-than, equal-to, or
                greater-than the second operand respectively.</summary>
            <remarks>
                Compares a BigUInt and an unsigned integer and returns -1, 0, or 1 if the BigUInt is less-than, equal-to, or
                greater-than the second operand respectively. The input operands are not modified.
                </remarks>
            <param name="compare">The value to compare against</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.CompareTo(Microsoft.Research.SEAL.BigUInt)">
            <summary>Compares two BigUInts and returns -1, 0, or 1 if the BigUInt is less-than, equal-to, or greater-than the
                second operand respectively.</summary>
            <remarks>
                Compares two BigUInts and returns -1, 0, or 1 if the BigUInt is less-than, equal-to, or greater-than the second
                operand respectively. The input operands are not modified.
                </remarks>
            <param name="compare">The value to compare against</param>
            <exception cref="T:System.ArgumentNullException">If compare is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Finalize">
            <summary>Destroys the BigUInt, including deallocating any internally allocated space.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Dispose">
            <summary>Destroys the BigUInt, including deallocating any internally allocated space.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.GetHashCode">
            <summary>Returns a hash-code based on the value of the BigUInt.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.ToDecimalString">
            <summary>Returns the BigUInt value as a decimal string.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.ToString">
            <summary>Returns the BigUInt value as a hexadecimal string.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.ToBigInteger">
            <summary>Returns the BigUInt value as a <see cref="T:System.Numerics.BigInteger" />.</summary>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Equals(System.Object)">
            <summary>Returns whether or not a BigUInt is equal to a second BigUInt.</summary>
            <remarks>
                Returns whether or not a BigUInt is equal to a second BigUInt. The input operands are not modified.
                </remarks>
            <param name="compare">The value to compare against</param>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Equals(Microsoft.Research.SEAL.BigUInt)">
            <summary>Returns whether or not a BigUInt is equal to a second BigUInt.</summary>
            <remarks>
                Returns whether or not a BigUInt is equal to a second BigUInt. The input operands are not modified.
                </remarks>
            <param name="compare">The value to compare against</param>
            <exception cref="T:System.ArgumentNullException">If compare is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Resize(System.Int32)">
            <summary>Resizes the BigUInt to the specified bit width, copying over the old value as much as will fit.</summary>
            <param name="bitCount">The bit width</param>
            <exception cref="T:System.ArgumentException">if bitCount is negative</exception>
            <exception cref="T:System.InvalidOperationException">If the BigUInt is an alias</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Load(System.IO.Stream)">
            <summary>Loads a BigUInt from an input stream overwriting the current BigUInt and enlarging if needed to fit the loaded
                BigUInt.</summary>
            <param name="stream">The stream to load the BigUInt from</param>
            <exception cref="T:System.ArgumentNullException">If stream is null</exception>
            <exception cref="T:System.InvalidOperationException">If BigUInt is an alias and the loaded BigUInt is too large to fit
                with the current bit width</exception>
            <seealso cref="M:Microsoft.Research.SEAL.BigUInt.Save(System.IO.Stream)">See Save() to save a BigUInt.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Save(System.IO.Stream)">
            <summary>Saves the BigUInt to an output stream.</summary>
            <remarks>
                Saves the BigUInt to an output stream. The full state of the BigUInt is serialized, including insignificant bits. The
                output is in binary format and not human-readable. The output stream must have the "binary" flag set.
                </remarks>
            <param name="stream">The stream to save the BigUInt to</param>
            <exception cref="T:System.ArgumentNullException">If stream is null</exception>
            <seealso cref="M:Microsoft.Research.SEAL.BigUInt.Load(System.IO.Stream)">See Load() to load a saved BigUInt.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.SetZero">
            <summary>Sets the BigUInt value to zero.</summary>
            <remarks>
Sets the BigUInt value to zero. This does not resize the BigUInt.
</remarks>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Set(System.UInt64)">
            <summary>Overwrites the BigUInt with the specified integer value, enlarging if needed to fit the value.</summary>
            <param name="assign">The value to assign</param>
            <exception cref="T:System.InvalidOperationException">If BigUInt is an alias and the significant bit count of assign is
                too large to fit the current bit width</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Set(System.String)">
            <summary>Overwrites the BigUInt with the unsigned hexadecimal value specified by the string, enlarging if needed to fit
                the assigned value.</summary>
            <remarks>
                Overwrites the BigUInt with the unsigned hexadecimal value specified by the string, enlarging if needed to fit the
                assigned value. The string must match the format returned by <see cref="M:Microsoft.Research.SEAL.BigUInt.ToString" /> and must consist of only the
                characters 0-9, A-F, or a-f, most-significant nibble first.
                </remarks>
            <param name="assign">The hexadecimal integer string specifying the value to assign</param>
            <exception cref="T:System.ArgumentNullException">If assign is null</exception>
            <exception cref="T:System.ArgumentException">If assign does not adhere to the expected format</exception>
            <exception cref="T:System.InvalidOperationException">If BigUInt is an alias and the assigned value is too large to fit
                the current bit width</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.Set(Microsoft.Research.SEAL.BigUInt)">
            <summary>Overwrites the BigUInt with the value of the specified BigUInt, enlarging if needed to fit the assigned
                value.</summary>
            <remarks>
                Overwrites the BigUInt with the value of the specified BigUInt, enlarging if needed to fit the assigned value. Only
                significant bits are used to size the BigUInt.
                </remarks>
            <param name="assign">The BigUInt whose value should be assigned to the current BigUInt</param>
            <exception cref="T:System.ArgumentNullException">If assign is null</exception>
            <exception cref="T:System.InvalidOperationException">If BigUInt is an alias and the assigned BigUInt is too large to fit
                the current bit width</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.GetSignificantBitCount">
            <summary>Returns the number of significant bits for the BigUInt.</summary>
            <seealso cref="P:Microsoft.Research.SEAL.BigUInt.BitCount">See BitCount to instead return the bit count regardless of leading zero bits.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigUInt.default(System.Int32)">
            <summary>Gets/sets the byte at the corresponding byte index of the BigUInt's integer value.</summary>
            <remarks>
                Gets/sets the byte at the corresponding byte index of the BigUInt's integer value. The bytes of the BigUInt are indexed
                least-significant byte first.
                </remarks>
            <param name="index">The index of the byte to get/set</param>
            <exception cref="T:System.ArgumentOutOfRangeException">If index is not within [0, <see cref="P:Microsoft.Research.SEAL.BigUInt.ByteCount" />)</exception>
            <seealso cref="T:Microsoft.Research.SEAL.BigUInt">See BigUInt for a detailed description of the format of the backing array.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigUInt.IsZero">
            <summary>Returns whether or not the BigUInt has the value zero.</summary>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigUInt.Pointer">
            <summary>Returns a pointer to the backing array storing the BigUInt value.</summary>
            <remarks>
                Returns a pointer to the backing array storing the BigUInt value. The pointer points to the beginning of the backing
                array at the least-significant quad word. The pointer is valid only until the backing array is freed, which occurs
                when the BigUInt is resized or destroyed.
                </remarks>
            <seealso cref="P:Microsoft.Research.SEAL.BigUInt.UInt64Count">See UInt64Count to determine the number of System::UInt64 values in the
                backing array.</seealso>
            <seealso cref="T:Microsoft.Research.SEAL.BigUInt">See BigUInt for a detailed description of the format of the backing array.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigUInt.UInt64Count">
            <summary>Returns the number of System::UInt64 in the backing array used to store the BigUInt value.</summary>
            <seealso cref="T:Microsoft.Research.SEAL.BigUInt">See BigUInt for a detailed description of the format of the backing array.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigUInt.ByteCount">
            <summary>Returns the number of bytes in the backing array used to store the BigUInt value.</summary>
            <seealso cref="T:Microsoft.Research.SEAL.BigUInt">See BigUInt for a detailed description of the format of the backing array.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigUInt.BitCount">
            <summary>Returns the bit count for the BigUInt.</summary>
            <seealso cref="M:Microsoft.Research.SEAL.BigUInt.GetSignificantBitCount">See GetSignificantBitCount() to instead ignore leading zero bits.</seealso>
        </member>
        <member name="P:Microsoft.Research.SEAL.BigUInt.IsAlias">
            <summary>Returns whether or not the BigUInt is an alias.</summary>
            <seealso cref="T:Microsoft.Research.SEAL.BigUInt">See BigUInt for a detailed description of aliased BigUInt.</seealso>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor(Microsoft.Research.SEAL.BigUInt)">
            <summary>Creates a deep copy of a BigUInt.</summary>
            <remarks>
                Creates a deep copy of a BigUInt. The created BigUInt will have the same bit count and value as the original.
                </remarks>
            <param name="copy">The BigUInt to copy from</param>
            <exception cref="T:System.ArgumentNullException">If copy is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor(System.ValueType!System.Numerics.BigInteger!System.Runtime.CompilerServices.IsBoxed)">
            <summary>Creates a BigUInt initialized and minimally sized to fit the unsigned hexadecimal integer specified by the
<see cref="T:System.Numerics.BigInteger" />.</summary>
            <param name="bigInteger">The initial value of the BigUInt</param>
            <exception cref="T:System.ArgumentNullException">If bigInteger is null</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor(System.String)">
            <summary>Creates a BigUInt initialized and minimally sized to fit the unsigned hexadecimal integer specified by the
                string.</summary>
            <remarks>
                Creates a BigUInt initialized and minimally sized to fit the unsigned hexadecimal integer specified by the string. The
                string matches the format returned by <see cref="M:Microsoft.Research.SEAL.BigUInt.ToString" /> and must consist of only the characters 0-9, A-F, or
                a-f, most-significant nibble first.
                </remarks>
            <param name="hexString">The hexadecimal integer string specifying the initial value</param>
            <exception cref="T:System.ArgumentNullException">If hexString is null</exception>
            <exception cref="T:System.ArgumentException">If hexString does not adhere to the expected format</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor(System.Int32,System.UInt64)">
            <summary>Creates a BigUInt of the specified bit width and initializes it to the specified unsigned integer
                value.</summary>
            <param name="bitCount">The bit width</param>
            <param name="value">The initial value to set the BigUInt</param>
            <exception cref="T:System.ArgumentException">if bitCount is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor(System.Int32,System.String)">
            <summary>Creates a BigUInt of the specified bit width and initializes it with the unsigned hexadecimal integer
                specified by the string.</summary>
            <remarks>
                Creates a BigUInt of the specified bit width and initializes it with the unsigned hexadecimal integer specified by the
                string. The string must match the format returned by <see cref="M:Microsoft.Research.SEAL.BigUInt.ToString" /> and must consist of only the characters 0-9, A-F, or
                a-f, most-significant nibble first.
                </remarks>
            <param name="bitCount">The bit width</param>
            <param name="hexString">The hexadecimal integer string specifying the initial value</param>
            <exception cref="T:System.ArgumentNullException">If hexString is null</exception>
            <exception cref="T:System.ArgumentException">if bitCount is negative</exception>
            <exception cref="T:System.ArgumentException">If hexString does not adhere to the expected format</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor(System.Int32)">
            <summary>Creates a zero-initialized BigUInt of the specified bit width.</summary>
            <param name="bitCount">The bit width</param>
            <exception cref="T:System.ArgumentException">if bitCount is negative</exception>
        </member>
        <member name="M:Microsoft.Research.SEAL.BigUInt.#ctor">
            <summary>Creates an empty BigUInt with zero bit width.</summary>
            <remarks>
Creates an empty BigUInt with zero bit width. No memory is allocated by this constructor.
</remarks>
        </member>
        <member name="T:Microsoft.Research.SEAL.BigUInt">
            <summary>Represents an unsigned integer with a specified bit width.</summary>
            <remarks>
                <para>
            Represents an unsigned integer with a specified bit width. BigUInts are mutable and able to be resized. The
            bit count for a BigUInt (which can be read with <see cref="P:Microsoft.Research.SEAL.BigUInt.BitCount" />) is set initially by the constructor and can
            be resized either explicitly with the <see cref="M:Microsoft.Research.SEAL.BigUInt.Resize(System.Int32)" /> function or implicitly with an assignment operation
            (e.g., one of the Set() functions). A rich set of unsigned integer operations are provided by the BigUInt class,
            including comparison, traditional arithmetic (addition, subtraction, multiplication, division), and modular
            arithmetic functions.
            </para>
                <para>
            The backing array for a BigUInt stores its unsigned integer value as a contiguous System::UInt64 array.
            Each System::UInt64 in the array sequentially represents 64-bits of the integer value, with the least
            significant quad-word storing the lower 64-bits and the order of the bits for each quad word dependent on the
            architecture's System::UInt64 representation. The size of the array equals the bit count of the BigUInt
            (which can be read with <see cref="P:Microsoft.Research.SEAL.BigUInt.BitCount" />) rounded up to the next System::UInt64 boundary (i.e.,
            rounded up to the next 64-bit boundary). The <see cref="P:Microsoft.Research.SEAL.BigUInt.UInt64Count" /> property returns the number of
            System::UInt64 in the backing array. The <see cref="P:Microsoft.Research.SEAL.BigUInt.Pointer" /> property returns a pointer to the first
            System::UInt64 in the array. Additionally, the index property allows accessing the individual bytes of
            the integer value in a platform-independent way - for example, reading the third byte will always return bits 16-24
            of the BigUInt value regardless of the platform being little-endian or big-endian.
            </para>
                <para>
            Both the copy constructor and the Set function allocate more memory for the backing array when needed, 
            i.e. when the source BigUInt has a larger backing array than the destination. Conversely, when the destination backing
            array is already large enough, the data is only copied and the unnecessary higher order bits are set
            to zero. When new memory has to be allocated, only the significant bits of the source BigUInt are taken
            into account. This is is important, because it avoids unnecessary zero bits to be included in the destination,
            which in some cases could accumulate and result in very large unnecessary allocations.
            However, sometimes it is necessary to preserve the original size, even if some of the leading bits are zero.
            For this purpose BigUInt contains functions <see cref="M:Microsoft.Research.SEAL.BigUInt.DuplicateFrom(Microsoft.Research.SEAL.BigUInt)" /> and <see cref="M:Microsoft.Research.SEAL.BigUInt.DuplicateTo(Microsoft.Research.SEAL.BigUInt)" />, which 
            create an exact copy of the source BigUInt.
            </para>
                <para>
            An aliased BigUInt (which can be determined with <see cref="P:Microsoft.Research.SEAL.BigUInt.IsAlias" />) is a special type of BigUInt that does not
            manage its underlying System::UInt64 pointer used to store the value. An aliased BigUInt supports most
            of the same operations as a non-aliased BigUInt, including reading and writing the value, however an aliased BigUInt
            does not internally allocate or deallocate its backing array and, therefore, does not support resizing. Any attempt,
            either explicitly or implicitly, to resize the BigUInt will result in an exception being thrown. Aliased BigUInt's
            are only created internally. Aliasing is useful in cases where it is desirable to not have each BigUInt manage its
            own memory allocation and/or to prevent unnecessary copying. For example, <see cref="T:Microsoft.Research.SEAL.BigPoly" /> uses aliased
            BigUInt's to return BigUInt representations of its coefficients, where the aliasing allows read/writes to the
            BigUInt to refer directly to the coefficient's corresponding region in the backing array of the <see cref="T:Microsoft.Research.SEAL.BigPoly" />.
            </para>
                <para>
            In general, reading a BigUInt is thread-safe while mutating is not. Specifically, the backing array may be freed
            whenever a resize occurs or the BigUInt is destroyed, which would invalidate the address returned by
            <see cref="P:Microsoft.Research.SEAL.BigUInt.Pointer" />. When it is known that a resize will not occur, concurrent reading and mutating will not
            inherently fail but it is possible for a read to see a partially updated value from a concurrent write.
            </para>
            </remarks>
        </member>
        <member name="M:seal.SimulationEvaluator.relinearize(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32)">
        Simulates noise budget consumption in Evaluator::relinearize() and returns the result.

        @param[in] simulation The Simulation object to relinearize
        @param[in] destination_size The size of the ciphertext (represented by the output simulation) after relinearization, defaults to 2
        @throws std::invalid_argument if destination_size is less than 2 or greater than that of the ciphertext represented by simulation 
        @throws std::invalid_argument if simulation has size() less than 2
        @see Evaluator::relinearize() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.square(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::square() and returns the result.

        @param[in] simulation The Simulation object to square
        @throws std::invalid_argument if simulation has size() less than 2
        @see Evaluator::square() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.multiply(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::multiply() and returns the result.

        @param[in] simulation1 The first Simulation object to multiply
        @param[in] simulation2 The second Simulation object to multiply
        @throws std::invalid_argument if simulation1 and simulation2 were constructed with different encryption parameters
        @throws std::invalid_argument if simulation1 or simulation2 has size() less than 2
        @see Evaluator::multiply() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.negate(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::negate() and returns the result.

        @param[in] simulation The Simulation object to negate
        @throws std::invalid_argument if simulation has size() less than 2
        @see Evaluator::negate() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.exponentiate(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.UInt64)">
        Simulates noise budget consumption in Evaluator::exponentiate() and returns the result.

        @param[in] simulation The Simulation object to raise to a power
        @param[in] exponent The power to raise the Simulation object to
        @throws std::invalid_argument if exponent is zero
        @throws std::invalid_argument if simulation has size() less than 2
        @see Evaluator::exponentiate() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.sub_plain(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.UInt64)">
        Simulates noise budget consumption in Evaluator::sub_plain() and returns the result.

        @param[in] simulation The Simulation object to subtract from
        @param[in] plain_max_coeff_count An upper bound on the number of non-zero coefficients in the plain polynomial to subtract
        @param[in] plain_max_abs_value An upper bound (represented by std::uint64_t) on the absolute value of coefficients in the plain polynomial to subtract
        @throws std::invalid_argument if simulation has size() less than 2
        @throws std::invalid_argument if plain_max_coeff_count is out of range
        @see Evaluator::sub_plain() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.sub_plain(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::sub_plain() and returns the result.

        @param[in] simulation The Simulation object to subtract from
        @param[in] plain_max_coeff_count An upper bound on the number of non-zero coefficients in the plain polynomial to subtract
        @param[in] plain_max_abs_value An upper bound (represented by BigUInt) on the absolute value of coefficients in the plain polynomial to subtract
        @throws std::invalid_argument if simulation has size() less than 2
        @throws std::invalid_argument if plain_max_coeff_count is out of range
        @see Evaluator::sub_plain() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.add_plain(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.UInt64)">
        Simulates noise budget consumption in Evaluator::add_plain() and returns the result.

        @param[in] simulation The Simulation object to add to
        @param[in] plain_max_coeff_count An upper bound on the number of non-zero coefficients in the plain polynomial to add
        @param[in] plain_max_abs_value An upper bound (represented by std::uint64_t) on the absolute value of coefficients in the plain polynomial to add
        @throws std::invalid_argument if simulation has size() less than 2
        @throws std::invalid_argument if plain_max_coeff_count is out of range
        @see Evaluator::add_plain() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.add_plain(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::add_plain() and returns the result.

        @param[in] simulation The Simulation object to add to
        @param[in] plain_max_coeff_count An upper bound on the number of non-zero coefficients in the plain polynomial to add
        @param[in] plain_max_abs_value An upper bound (represented by BigUInt) on the absolute value of coefficients in the plain polynomial to add
        @throws std::invalid_argument if simulation has size() less than 2
        @throws std::invalid_argument if plain_max_coeff_count is out of range
        @see Evaluator::add_plain() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.multiply_plain(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.UInt64)">
        Simulates noise budget consumption in Evaluator::multiply_plain() given an upper bound for the maximum number of
        non-zero coefficients and an upper bound for their absolute value (represented by std::uint64_t) in the encoding of
        the plain-text multiplier and returns the result.

        @param[in] simulation The Simulation object to multiply
        @param[in] plain_max_coeff_count An upper bound on the number of non-zero coefficients in the plain polynomial to multiply
        @param[in] plain_max_abs_value An upper bound (represented by std::uint64_t) on the absolute value of coefficients in the plain polynomial to multiply
        @throws std::invalid_argument if plain_max_coeff_count is out of range
        @throws std::invalid_argument if plain_max_coeff_count or plain_max_abs_value is zero
        @throws std::invalid_argument if simulation has size() less than 2
        @see Evaluator::multiply_plain() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.multiply_plain(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::multiply_plain() given an upper bound for the maximum number of
        non-zero coefficients and an upper bound for their absolute value (represented by BigUInt) in the encoding of
        the plaintext multiplier and returns the result.

        @param[in] simulation The Simulation object to multiply
        @param[in] plain_max_coeff_count An upper bound on the number of non-zero coefficients in the plain polynomial to multiply
        @param[in] plain_max_abs_value An upper bound (represented by BigUInt) on the absolute value of coefficients in the plain polynomial to multiply
        @throws std::invalid_argument if plain_max_coeff_count is out of range
        @throws std::invalid_argument if plain_max_coeff_count or plain_max_abs_value is zero
        @throws std::invalid_argument if simulation has size() less than 2
        @see Evaluator::multiply_plain() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.sub(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::sub() and returns the result.

        @param[in] simulation1 The Simulation object to subtract from
        @param[in] simulation2 The Simulation object to subtract
        @throws std::invalid_argument if simulation1 and simulation2 were constructed with different encryption parameters
        @throws std::invalid_argument if simulation1 or simulation2 has size() less than 2
        @see Evaluator::sub() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.add_many(std.vector&lt;seal.Simulation,std.allocator&lt;seal.Simulation&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::add_many() and returns the result.

        @param[in] simulations The simulations to add
        @throws std::invalid_argument if simulations is empty
        @throws std::invalid_argument if not all elements of simulations were constructed with the same encryption parameters
        @throws std::invalid_argument if any of the elements in the simulations vector has size() less than 2
        @see Evaluator::add_many() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.add(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Simulates noise budget consumption in Evaluator::add() and returns the result.

        @param[in] simulation1 The first Simulation object to add
        @param[in] simulation2 The second Simulation object to add
        @throws std::invalid_argument if simulation1 and simulation2 were constructed with different encryption parameters
        @throws std::invalid_argument if simulation1 or simulation2 has size() less than 2
        @see Evaluator::add() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.multiply_many(std.vector&lt;seal.Simulation,std.allocator&lt;seal.Simulation&gt;&gt;)">
        Simulates noise budget consumption in Evaluator::multiply_many() and returns the result.

        @param[in] simulations The vector of Simulation objects to multiply
        @throws std::invalid_argument if the simulations vector is empty
        @throws std::invalid_argument if at least two of the elements in the simulations vector were 
        constructed with different encryption parameters
        @throws std::invalid_argument if any of elements in the simulations vector has size() less than 2
        @see Evaluator::multiply_many() for the corresponding operation on ciphertexts.

</member>
        <member name="M:seal.SimulationEvaluator.get_fresh(seal.EncryptionParameters*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.UInt64)">
        Creates a Simulation object corresponding to a freshly encrypted ciphertext. The noise is estimated
        based on the given encryption parameters, and size parameters of a virtual input plaintext polynomial,
        namely an upper bound plain_max_coeff_count on the number of non-zero coefficients in the polynomial,
        and an upper bound plain_max_abs_value (represented by std::uint64_t) on the absolute value (modulo the 
        plaintext modulus) of the polynomial coefficients.

        @param[in] parms The encryption parameters
        @param[in] plain_max_coeff_count An upper bound on the number of non-zero coefficients in the underlying plaintext
        @param[in] plain_max_abs_value An upper bound on the absolute value of the coefficients in the underlying plaintext
        @throws std::invalid_argument if plain_max_coeff_count is negative or bigger than the degree of the polynomial modulus
        @throws std::invalid_argument if plain_max_abs_value is bigger than plaintext modulus divided by 2

</member>
        <member name="M:seal.SimulationEvaluator.get_fresh(seal.EncryptionParameters*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a Simulation object corresponding to a freshly encrypted ciphertext. The noise is estimated
        based on the given encryption parameters, and size parameters of a virtual input plaintext polynomial, 
        namely an upper bound plain_max_coeff_count on the number of non-zero coefficients in the polynomial, 
        and an upper bound plain_max_abs_value (represented by BigUInt) on the absolute value (modulo the plaintext 
        modulus) of the polynomial coefficients.

        @param[in] parms The encryption parameters
        @param[in] plain_max_coeff_count An upper bound on the number of non-zero coefficients in the underlying plaintext
        @param[in] plain_max_abs_value An upper bound on the absolute value of the coefficients in the underlying plaintext
        @throws std::invalid_argument if plain_max_coeff_count is negative or bigger than the degree of the polynomial modulus
        @throws std::invalid_argument if plain_max_abs_value is bigger than the plaintext modulus divided by 2

</member>
        <member name="M:seal.SimulationEvaluator.#ctor(seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new SimulationEvaluator. Optionally, the user can give a reference to a MemoryPoolHandle 
        object to use a custom memory pool instead of the global memory pool (default).

        @param[in] pool The memory pool handle
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.SimulationEvaluator">
    Manipulates instances of Simulation with a public API similar to how Evaluator manipulates
    ciphertexts (represented by BigPoly). This makes existing code easy to run on Simulation
    objects instead of running it on actual encrypted data.
    
    Simulation objects model the invariant noise budget in a ciphertext based on given encryption parameters.
    When performing homomorphic operations on encrypted data, the quality of the ciphertexts will degrade,
    i.e. the invariant noise budget will be consumed, until at a certain point the budget will reach 0, and
    decryption will fail to work. The Simulation object together with SimulationEvaluator can help the user 
    understand how the noise budget is consumed in different homomorphic operations, and to adjust the 
    encryption parameters accordingly.

    SimulationEvaluator allows the user to simulate the effect of homomorphic operations on the invariant
    noise budget in encrypted data. These homomorphic operations include addition, multiplication, 
    subtraction, negation, etc., and the result is always a new Simulation object whose noise budget
    is obtained using heuristic worst-case analysis of the encryption scheme.

    @par Invariant Noise Budget
    The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
    a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
    of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
    the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
    invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
    starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
    computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
    correctly.

    @par Thread Safety
    The SimulationEvaluator class is not thread-safe and a separate SimulationEvaluator instance is needed
    for each potentially concurrent usage.

    @see Simulation for the object modeling the noise in ciphertexts.

</member>
        <member name="F:seal.Simulation.noise_">
Stores the current noise scaled by coeff_modulus_.

</member>
        <member name="M:seal.Simulation.compare_encryption_parameters(seal.Simulation!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
Compares the encryption parameters given in the constructor to those of the argument simulation.

</member>
        <member name="M:seal.Simulation.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double,System.Int32,System.Int32)">
Creates a simulation of a ciphertext encrypted with the specified encryption parameters and given
invariant noise. The invariant noise is interpreted as having been scaled by the coefficient modulus.

</member>
        <member name="M:seal.Simulation.size">
Returns the size of the ciphertext whose noise is modeled by the simulation.
@see BigPolyArray::size() for the corresponding function on BigPolyArray objects.

</member>
        <member name="M:seal.Simulation.decrypts(System.Int32)">
        Returns true or false depending on whether the encryption parameters were large enough to support 
        the performed homomorphic operations. The budget_gap parameter can be used to ensure that a certain
        amount of noise budget remains unused.

        @param[in] budget_gap The amount of noise budget (bits) that should remain unused
        @throws std::invalid_argument if budget_gap is negative

</member>
        <member name="M:seal.Simulation.invariant_noise_budget">
Returns the invariant noise budget that is being simulated. If the returned value is less than or equal to 0,
the encryption parameters used are possibly not large enough to support the performed homomorphic operations.

</member>
        <member name="M:seal.Simulation.#ctor(seal.EncryptionParameters*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Int32)">
        Creates a simulation of a ciphertext encrypted with the specified encryption parameters and given
        invariant noise budget. The given noise budget must be at least zero, and at most the significant
        bit count of the coefficient modulus minus two.

        @param[in] parms The encryption parameters
        @param[in] noise_budget The invariant noise budget of the created ciphertext
        @param[in] ciphertext_size The size of the created ciphertext
        @throws std::invalid_argument if encryption parameters are not valid
        @throws std::invalid_argument if noise_budget is not in the valid range
        @throws std::invalid_argument if ciphertext_size is less than 2
        @see EncryptionParameters for more details on valid encryption parameters.

</member>
        <member name="T:seal.Simulation">
    Models the invariant noise budget in a ciphertext based on given EncryptionParameters object.
    When performing arithmetic operations on encrypted data, the quality of the ciphertexts will degrade,
    i.e. the invariant noise budget will be consumed, until at a certain point the budget will reach 0, and
    decryption will fail to work. The Simulation object together with SimulationEvaluator can help the user 
    understand how the invariant noise budget is consumed in different homomorphic operations, and to adjust 
    the encryption parameters accordingly.
    
    Instances of Simulation can be manipulated using SimulationEvaluator, which has a public API similar 
    to Evaluator, making existing code easy to run on simulations instead of running it on actual encrypted 
    data. In other words, using SimulationEvaluator, simulations can be added, multiplied, subtracted, 
    negated, etc., and the result is always a new Simulation object whose noise budget is obtained using 
    heuristic worst-case analysis of the noise behavior in the encryption scheme.

    @par Invariant Noise Budget
    The invariant noise polynomial of a ciphertext is a rational coefficient polynomial, such that
    a ciphertext decrypts correctly as long as the coefficients of the invariant noise polynomial are
    of absolute value less than 1/2. Thus, we call the infinity-norm of the invariant noise polynomial
    the invariant noise, and for correct decryption require it to be less than 1/2. If v denotes the
    invariant noise, we define the invariant noise budget as -log2(2v). Thus, the invariant noise budget
    starts from some initial value, which depends on the encryption parameters, and decreases to 0 when
    computations are performed. When the budget reaches 0, the ciphertext becomes too noisy to decrypt
    correctly.

    @see SimulationEvaluator for manipulating instances of Simulation.

</member>
        <member name="M:seal.EncryptionParameters.invalidate">
Invalidates the current encryption parameters. Calling validate() is necessary before the parameters 
can be used again.

</member>
        <member name="M:seal.EncryptionParameters.inherent_noise_max(seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Computes the maximum amount of inherent noise supported by the current encryption parameters and stores
        it in the given BigUInt. Any ciphertext with larger inherent noise is impossible to decrypt, even with 
        the correct secret key. The function Decryptor::inherent_noise_bits() can be used to compute the number 
        of bits of inherent noise in a given ciphertext.

        @param[in] destination The BigUInt to overwrite with the maximum inherent noise
        @throws std::logic_error if the encryption parameters are not valid
        @see inherent_noise_bits_max for returning instead the significant bit count of the maximum size of inherent noise.

</member>
        <member name="M:seal.EncryptionParameters.inherent_noise_bits_max">
        Computes and returns the maximum number of bits of inherent noise supported by the current encryption
        parameters. Any ciphertext with larger inherent noise is impossible to decrypt, even with the correct 
        secret key. The function Decryptor::inherent_noise_bits() can be used to compute the number of bits
        of inherent noise in a given ciphertext.

        @throws std::logic_error if the encryption parameters are not valid
        @see inherent_noise_max for computing the exact maximum size of inherent noise.

</member>
        <member name="M:seal.EncryptionParameters.get_qualifiers">
        Returns the set of qualifiers (as an instance of EncryptionParameterQualifiers) for the current
        encryption parameters. Note that to get an updated set of qualifiers it is necessary to call
        validate() after any change to the encryption parameters.

        @see EncryptionParameterQualifiers for more details on the qualifiers.

</member>
        <member name="M:seal.EncryptionParameters.load(std.basic_istream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Loads the EncryptionParameters from an input stream overwriting the current EncryptionParameters. 
        This function automatically invalidates the EncryptionParameters instance, so calling validate() 
        is necessary before the parameters can be used.

        @param[in] stream The stream to load the EncryptionParameters from
        @see save() to save an EncryptionParameters instance.

</member>
        <member name="M:seal.EncryptionParameters.save(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Saves the EncryptionParameters to an output stream. The output is in binary format and is not 
        human-readable. The output stream must have the "Binary" flag set.

        @param[in] stream The stream to save the EncryptionParameters to
        @see load() to load a saved EncryptionParameters instance.

</member>
        <member name="M:seal.EncryptionParameters.random_generator">
Returns the random number generator factory to use for encryption. By default, the random generator is set to
UniformRandomGeneratorFactory::default_factory(). Setting this value allows a user to specify a custom random number
generator source.

</member>
        <member name="M:seal.EncryptionParameters.decomposition_bit_count">
Returns the decomposition bit count which directly determines the number of evaluation keys required by
the scheme. Smaller decomposition bit count reduces the accumulation of noise during multiplication
operations, but can also significantly increase the time required to perform multiplication.

</member>
        <member name="M:seal.EncryptionParameters.noise_max_deviation">
Returns the maximum deviation of normalized noise used during key generation and encryption.

</member>
        <member name="M:seal.EncryptionParameters.noise_standard_deviation">
Returns the standard deviation of normalized noise used during key generation and encryption.

</member>
        <member name="M:seal.EncryptionParameters.plain_modulus">
Returns a constant reference to the plaintext modulus parameter (represented by a BigUInt). Note that the
plaintext modulus is one greater than the maximum value allowed for any plaintext coefficient that the library
can encrypt or represent.

</member>
        <member name="M:seal.EncryptionParameters.coeff_modulus">
Returns a constant reference to the coefficient modulus parameter (represented by a BigUInt). Note that the
coefficient modulus directly determines the number of bits-per-coefficient of encrypted polynomials and the 
maximum value allowed for plain_modulus() (which should be significantly smaller than coeff_modulus()).

</member>
        <member name="M:seal.EncryptionParameters.poly_modulus">
Returns a constant reference to the polynomial modulus parameter (represented by BigPoly). Note that 
the polynomial modulus directly determines the number of coefficients of encrypted polynomials, and the
maximum number of coefficients for plaintext polynomials that are representable by the library.

</member>
        <member name="M:seal.EncryptionParameters.validate">
        Validates the parameters set in the current EncryptionParameters instance, and returns a populated instance
        of EncryptionParameterQualifiers. It is necessary to call this function before using the the encryption
        parameters to create other classes such as KeyGenerator, Encryptor, and Evaluator. Note also that any change
        to the parameters requires the validate() function to be called again before the parameters can be used.

        @see EncryptionParameterQualifiers for more details on the returned qualifiers.

</member>
        <member name="M:seal.EncryptionParameters.set_random_generator(seal.UniformRandomGeneratorFactory*)">
        Sets the random number generator factory to use for encryption. By default, the random generator is set to
        UniformRandomGeneratorFactory::default_factory(). Setting this value allows a user to specify a custom random number
        generator source. This function automatically invalidates the EncryptionParameters instance, so calling validate() 
        is necessary before the parameters can be used.

        @param[in] random_generator Pointer to the random generator factory

</member>
        <member name="M:seal.EncryptionParameters.set_noise_max_deviation(System.Double)">
        Sets the maximum deviation of normalized noise used during key generation and encryption. This function
        automatically invalidates the EncryptionParameters instance, so calling validate() is necessary before the
        parameters can be used.

        @param[in] noise_max_deviation The new maximum deviation

</member>
        <member name="M:seal.EncryptionParameters.set_noise_standard_deviation(System.Double)">
        Sets the standard deviation of normalized noise used during key generation and encryption. This function 
        automatically invalidates the EncryptionParameters instance, so calling validate() is necessary before the 
        parameters can be used.

        @param[in] noise_standard_deviation The new standard deviation

</member>
        <member name="M:seal.EncryptionParameters.set_decomposition_bit_count(System.Int32)">
        Sets the decomposition bit count parameter to the specified value. The decomposition bit count directly
        determines the number of evaluation keys required by the scheme. Smaller decomposition bit count reduces 
        the accumulation of noise during multiplication operations, but can also significantly increase the time 
        required to perform multiplication. This function automatically invalidates the EncryptionParameters 
        instance, so calling validate() is necessary before the parameters can be used.

        @param[in] decomposition_bit_count The new decomposition bit count

</member>
        <member name="M:seal.EncryptionParameters.set_plain_modulus(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Sets the plaintext modulus parameter to the specified value (represented by std::string). Note that the
        plaintext modulus is one greater than the maximum value allowed for any plaintext coefficient that
        the library can encrypt or represent. This function automatically invalidates the EncryptionParameters
        instance, so calling validate() is necessary before the parameters can be used.

        @param[in] plain_modulus The new plaintext modulus

</member>
        <member name="M:seal.EncryptionParameters.set_plain_modulus(System.UInt64)">
        Sets the plaintext modulus parameter to the specified value (represented by std::uint64_t). Note that the
        plaintext modulus is one greater than the maximum value allowed for any plaintext coefficient that
        the library can encrypt or represent. This function automatically invalidates the EncryptionParameters
        instance, so calling validate() is necessary before the parameters can be used.

        @param[in] plain_modulus The new plaintext modulus

</member>
        <member name="M:seal.EncryptionParameters.set_plain_modulus(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Sets the plaintext modulus parameter to the specified value (represented by BigUInt). Note that the
        plaintext modulus is one greater than the maximum value allowed for any plaintext coefficient that 
        the library can encrypt or represent. This function automatically invalidates the EncryptionParameters 
        instance, so calling validate() is necessary before the parameters can be used.

        @param[in] plain_modulus The new plaintext modulus

</member>
        <member name="M:seal.EncryptionParameters.set_coeff_modulus(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Sets the coefficient modulus parameter to the specified value (represented by std::string). Note that the
        coefficient modulus directly determines the number of bits-per-coefficient of encrypted polynomials and
        the maximum value allowed for plain_modulus() (which should be significantly smaller than coeff_modulus()).
        This function automatically invalidates the EncryptionParameters instance, so calling validate() is
        necessary before the parameters can be used.

        @param[in] coeff_modulus The new coefficient modulus

</member>
        <member name="M:seal.EncryptionParameters.set_coeff_modulus(System.UInt64)">
        Sets the coefficient modulus parameter to the specified value (represented by std::uint64_t). Note that the
        coefficient modulus directly determines the number of bits-per-coefficient of encrypted polynomials and
        the maximum value allowed for plain_modulus() (which should be significantly smaller than coeff_modulus()).
        This function automatically invalidates the EncryptionParameters instance, so calling validate() is
        necessary before the parameters can be used.

        @param[in] coeff_modulus The new coefficient modulus

</member>
        <member name="M:seal.EncryptionParameters.set_coeff_modulus(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Sets the coefficient modulus parameter to the specified value (represented by BigUInt). Note that the
        coefficient modulus directly determines the number of bits-per-coefficient of encrypted polynomials and 
        the maximum value allowed for plain_modulus() (which should be significantly smaller than coeff_modulus()).
        This function automatically invalidates the EncryptionParameters instance, so calling validate() is
        necessary before the parameters can be used.

        @param[in] coeff_modulus The new coefficient modulus

</member>
        <member name="M:seal.EncryptionParameters.set_poly_modulus(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Sets the polynomial modulus parameter to the specified value (represented by std::string). Note that the
        polynomial modulus directly determines the number of coefficients of encrypted polynomials, and the
        maximum number of coefficients for plaintext polynomials that are representable by the library.
        This function automatically invalidates the EncryptionParameters instance, so calling validate() is
        necessary before the parameters can be used.

        @param[in] poly_modulus The new polynomial modulus

</member>
        <member name="M:seal.EncryptionParameters.set_poly_modulus(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a copy of a EncryptionParameters.

        @param[in] copy The EncryptionParameters to copy from

        Overwrites the EncryptionParameters instance with the specified instance.

        @param[in] assign The EncryptionParameters instance that should be assigned to the current instance

        Creates a new EncryptionParameters by moving an old one.

        @param[in] source The EncryptionParameters to move from

        Moves an old EncryptionParameters instance to the current one.

        @param[in] assign The EncryptionParameters to move from

        Sets the polynomial modulus parameter to the specified value (represented by BigPoly). Note that the
        polynomial modulus directly determines the number of coefficients of encrypted polynomials, and the
        maximum number of coefficients for plaintext polynomials that are representable by the library.
        This function automatically invalidates the EncryptionParameters instance, so calling validate() is 
        necessary before the parameters can be used.

        @param[in] poly_modulus The new polynomial modulus

</member>
        <member name="M:seal.EncryptionParameters.#ctor(seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates an empty EncryptionParameters instance. Optionally, the user can give a reference to a 
        MemoryPoolHandle object to use a custom memory pool instead of the global memory pool (default).

        @param[in] pool The memory pool handle
        @see MemoryPoolHandle for more details on memory pool handles.

</member>
        <member name="T:seal.EncryptionParameters">
    Represents the user-customizable encryption scheme settings. The parameters (e.g., poly_modulus(), coeff_modulus(),
    plain_modulus()) significantly affect the performance, capabilities, and security of the encryption scheme. KeyGenerator,
    Encryptor, Decryptor, Evaluator, and other objects in the library all require the EncryptionParameters object to specify
    and agree on the encryption scheme settings.

    Picking appropriate encryption parameters is essential to enable a particular application while balancing performance and
    security. Some encryption settings will not allow some inputs (e.g., attempting to encrypt a polynomial with more
    coefficients than poly_modulus() or larger coefficients than plain_modulus()) or support some computations (with noise
    growing too fast as determined by coeff_modulus() and decomposition_bit_count()). The ChooserPoly and ChooserEvaluator
    classes provide functionality to help determine the best encryption parameters for an application. Additionally, please 
    refer to external documentation to determine the best parameters.

    @par Validating Parameters
    After the user has set at least the poly_modulus(), the coeff_modulus(), and the plain_modulus() using the functions 
    set_poly_modulus(), set_coeff_modulus(), and set_plain_modulus(), respectively, and in many cases also the 
    decomposition_bit_count() using set_decomposition_bit_count(), the parameters need to be validated for correctness
    and functionality. This can be done using the function validate(), which returns an instance of EncryptionParameterQualifiers.
    If the returned instance of EncryptionParameterQualifiers has the EncryptionParameterQualifiers::parameters_set flag 
    set to true, the parameter set is valid and ready to be used. If the parameters were for some reason not appropriately
    set, the returned EncryptionParameterQualifiers instance will have EncryptionParameterQualifiers::parameters_set set to false.
    Any change to an already validated instance of EncryptionParameters immediately invalidates it, requiring another call
    to validate() before the parameters can be used.

    @par Thread Safety
    In general, reading from EncryptionParameters is thread-safe, while mutating is not.

    @warning Choosing inappropriate EncryptionParameters may load to an encryption scheme that is not secure, does not perform
    well, and/or does not support the input and computation of the application.

</member>
        <member name="F:seal.EncryptionParameterQualifiers.enable_ntt_in_multiply">
This variable has currently no effect (see util/defines.h).

</member>
        <member name="F:seal.EncryptionParameterQualifiers.enable_batching">
If the plaintext modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial
modulus and N is a power of two, then it is possible to use PolyCRTBuilder to do batching,
which is a fundamental technique in homomorphic encryption to enable powerful SIMD
functionality, often called "batching" in homomorphic encryption literature. In this 
case the variable enable_batching will be set to true.

</member>
        <member name="F:seal.EncryptionParameterQualifiers.enable_ntt">
If the coefficient modulus is congruent to 1 modulo 2N, where X^N+1 is the polynomial
modulus and N is a power of two, then the number-theoretic transform (NTT) can be used
for fast multiplications of polynomials modulo the polynomial modulus and coefficient
modulus. In this case the variable enable_ntt will be set to true.

</member>
        <member name="F:seal.EncryptionParameterQualifiers.enable_nussbaumer">
If the polynomial modulus is of the form X^N+1, where N is a power of two, then
Nussbaumer convolution can be used for fast multiplication of polynomials modulo
the polynomial modulus. In this case the variable enable_nussbaumer will be set to true.
However, currently SEAL requires the polynomial modulus to be of this form to even
consider the parameters to be valid. Therefore, parameters_set can only be true if
enable_nussbaumer is true.

</member>
        <member name="F:seal.EncryptionParameterQualifiers.enable_relinearization">
If EncryptionParameters::decomposition_bit_count is set to a positive value, the variable
enable_relinearization will be set to true.

</member>
        <member name="F:seal.EncryptionParameterQualifiers.parameters_set">
If the encryption parameters are set in a way that is considered valid by SEAL, the
variable parameters_set will be set to true.

</member>
        <member name="T:seal.EncryptionParameterQualifiers">
    Stores a set of attributes (qualifiers) of a set of encryption parameteres.
    These parameters are used in various parts of the library, e.g. to determine which
    algorithms can be used. The qualifiers are silently passed on to classes such as
    Encryptor, Evaluator, and Decryptor, and the only way to change them is by changing
    the encryption parameters accordingly. In other words, a user will never have to 
    create their own instance of EncryptionParameterQualifiers.

    @see EncryptionParameters for the class that stores the encryption parameters themselves.
    @see EncryptionParameters::GetQualifiers for obtaining the EncryptionParameterQualifiers 
    corresponding to a certain parameter set.

</member>
        <member name="M:seal.MemoryPoolHandle.op_Implicit~seal.util.MemoryPool*!System.Runtime.CompilerServices.IsImplicitlyDereferenced">
Returns a reference to the internal util::MemoryPool that the MemoryPoolHandle points to.

</member>
        <member name="M:seal.MemoryPoolHandle.acquire_new">
Returns a MemoryPoolHandle pointing to a new memory pool.

</member>
        <member name="M:seal.MemoryPoolHandle.acquire_global">
Returns a MemoryPoolHandle pointing to the global memory pool.

</member>
        <member name="M:seal.MemoryPoolHandle.#ctor(seal.MemoryPoolHandle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new MemoryPoolHandle by moving an old one.

        @param[in] source The MemoryPoolHandle to move from

</member>
        <member name="M:seal.MemoryPoolHandle.#ctor(seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a copy of a MemoryPoolHandle.

        @param[in] copy The MemoryPoolHandle to copy from

</member>
        <member name="M:seal.MemoryPoolHandle.op_Assign(seal.MemoryPoolHandle*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Overwrites the MemoryPoolHandle instance with the specified instance, so that the current instance 
        will point to the same underlying memory pool as the assigned instance.

        @param[in] assign The MemoryPoolHandle instance that should be assigned to the current instance

</member>
        <member name="M:seal.MemoryPoolHandle.op_Assign(seal.MemoryPoolHandle!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Overwrites the MemoryPoolHandle instance with the specified instance, so that the current instance 
        will point to the same underlying memory pool as the assigned instance.

        @param[in] assign The MemoryPoolHandle instance that should be assigned to the current instance

</member>
        <member name="M:seal.MemoryPoolHandle.#ctor">
Creates a new MemoryPoolHandle pointing to the global memory pool.

</member>
        <member name="T:seal.MemoryPoolHandle">
    SEAL uses memory pools for improved performance due to the large number of memory allocations needed
    by the homomorphic encryption operations, and the underlying polynomial arithmetic. The library 
    automatically creates a shared global memory pool, that is by default used by all instances of the 
    computation-heavy classes such as Encryptor, Evaluator, and PolyCRTBuilder. However, sometimes the 
    user might want to use local memory pools with some of these classes. For example, in heavily 
    multi-threaded applications the global memory pool might become clogged due to concurrent allocations. 
    Instead, the user might want to create a separate---say Evaluator---object for each thread, and have it
    use a thread-local memory pool. The MemoryPoolHandle class provides the functionality for doing this.

    For example, the user can create a MemoryPoolHandle that points to a new local memory pool by calling
    the static function acquire_new(). The MemoryPoolHandle it returns (or copies of it) can now be passed 
    on as an argument to the constructors of one or more classes (such as Encryptor, Evaluator, and PolyCRTBuilder). 

    Internally, a MemoryPoolHandle simply wraps a shared pointer to a util::MemoryPool object. This way
    the local memory pool will be automatically destroyed, and the memory released, as soon as no existing 
    handles point to it. Since the global memory pool is a static object, it will always have a positive 
    reference count, and thus will not be destroyed until the program terminates.

</member>
        <member name="M:seal.UniformRandomGeneratorFactory.default_factory">
Returns the default random number generator factory. This instance should not be destroyed.

</member>
        <member name="M:seal.UniformRandomGeneratorFactory.Dispose">
Destroys the random number generator factory.

</member>
        <member name="M:seal.UniformRandomGeneratorFactory.create">
Creates a new uniform random number generator. The caller of create needs to ensure the returned instance is destroyed
once it is no longer in-use to prevent a memory leak.

</member>
        <member name="T:seal.UniformRandomGeneratorFactory">
Provides the base-class for a factory instance that creates instances of UniformRandomGenerator. This class is meant for
users to sub-class to implement their own random number generators. Note that each instance returned may be used concurrently
across separate threads, but each individual instance does not need to be thread-safe.
@see UniformRandomGenerator for details relating to the random number generator instances.
@see StandardRandomAdapterFactory for an implementation of UniformRandomGeneratorFactory that supports the standard C++
library's random number generators.

</member>
        <member name="M:seal.UniformRandomGenerator.Dispose">
Destroys the random number generator.

</member>
        <member name="M:seal.UniformRandomGenerator.generate">
Generates a new uniform unsigned 32-bit random number. Note that the implementation does not need to be thread-safe.

</member>
        <member name="T:seal.UniformRandomGenerator">
Provides the base-class for a uniform random number generator. Instances of this class are typically returned from the
UniformRandomGeneratorFactory class. This class is meant for users to sub-class to implement their own random number
generators. The implementation should provide a uniform random unsigned 32-bit value for each call to generate(). Note
that the library will never make concurrent calls to generate() to the same instance (but individual instances of the
same class may have concurrent calls). The uniformity and unpredictability of the numbers generated is essential for
making a secure cryptographic system.

@see UniformRandomGeneratorFactory for the base-class of a factory class that generates UniformRandomGenerator
instances.
@see StandardRandomAdapter for an implementation of UniformRandomGenerator to support the C++ standard library's random
number generators.

</member>
        <member name="F:seal.BigPoly.is_alias_">
        Specifies whether or not the BigPoly is an alias. An alias BigPoly does not allocate its own backing array
        and instead uses the pointer of a backing array passed in to the constructor or alias() function.

        @see BigPoly for more information about the format of the backing array.

</member>
        <member name="F:seal.BigPoly.coeff_bit_count_">
        The number of bits per coefficient. Note that storage requirements may be more than the bit count because the space
        reserved for each coefficient is rounded up to the next std::uint64_t boundary (i.e., the next 64-bit boundary).

        @see BigPoly for more information about the format of the backing array.

</member>
        <member name="F:seal.BigPoly.coeff_count_">
The number of coefficients in the BigPoly.

</member>
        <member name="F:seal.BigPoly.coeffs_">
Points to an array of BigUInt's for the return value of the operator[] function. This array is always allocated and
deallocated by the BigPoly regardless of whether or not it is an alias. Each BigUInt is itself an alias that
points to the corresponding coefficient's location in the backing array value_. This pointer will be set to nullptr
if and only if the coefficient count is zero.

</member>
        <member name="F:seal.BigPoly.value_">
        Points to the backing array for the coefficients. This pointer will be set to nullptr if and only if the coefficient
        count or coefficient bit count is zero. This pointer is automatically allocated and freed by the BigPoly if and
        only if the BigPoly is not an alias. If the BigPoly is an alias, then the pointer was passed-in to a constructor
        or alias() call, and will not be deallocated by the BigPoly.

        @see BigPoly for more information about aliased BigPolys or the format of the backing array.

</member>
        <member name="M:seal.BigPoly.reset">
Resets the entire state of the BigPoly to an empty, zero-sized state, freeing any memory it internally allocated.
If the BigPoly was an alias, the backing array is not freed but the alias is no longer referenced.

</member>
        <member name="M:seal.BigPoly.#ctor(seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new BigPoly by moving an old one.

        @param[in] source The BigPoly to move from

</member>
        <member name="M:seal.BigPoly.op_Assign(seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Moves an old BigPoly to the current one.

        @param[in] assign The BigPoly to move from

</member>
        <member name="M:seal.BigPoly.duplicate_from(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Duplicates a given BigPoly. The coefficient count, the coefficient bit count,
        and the value of the current BigPoly are set to be exactly the same as in the given one.

        @param[in] value The BigPoly to duplicate
        @throws std::logic_error if the current BigPoly is an alias

</member>
        <member name="M:seal.BigPoly.duplicate_to(seal.BigPoly*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Duplicates the current BigPoly. The coefficient count, the coefficient bit count,
        and the value of the given BigPoly are set to be exactly the same as in the current one.

        @param[out] destination The BigPoly to overwrite with the duplicate
        @throws std::logic_error if the destination BigPoly is an alias

</member>
        <member name="M:seal.BigPoly.load(std.basic_istream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Loads a BigPoly from an input stream overwriting the current BigPoly and enlarging if needed to fit the loaded
        BigPoly.

        @param[in] stream The stream to load the BigPoly from
        @throws std::logic_error if BigPoly is an alias and the loaded polynomial is too large to fit the current coefficient count
        and/or bit width
        @see save() to save a BigPoly.

</member>
        <member name="M:seal.BigPoly.save(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Saves the BigPoly to an output stream. The full state of the BigPoly is serialized, including leading zero
        coefficients and insignificant coefficient bits. The output is in binary format and not human-readable. The
        output stream must have the "binary" flag set.

        @param[in] stream The stream to save the BigPoly to
        @see load() to load a saved BigPoly.

</member>
        <member name="M:seal.BigPoly.op_Assign(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Overwrites the BigPoly with the value of the specified BigPoly, enlarging if needed to fit the assigned value.
        Only significant coefficients and significant coefficient bit counts are used to size the BigPoly.

        @param[in] assign The BigPoly whose value should be assigned to the current BigPoly
        @throws std::logic_error if BigPoly is an alias and the assigned BigPoly is too large to fit the current coefficient count
        and/or bit width

</member>
        <member name="M:seal.BigPoly.unalias">
        Resets an aliased BigPoly into an empty non-alias BigPoly with coefficient count and bit count of zero.

        @throws std::logic_error if BigPoly is not an alias

</member>
        <member name="M:seal.BigPoly.alias(System.Int32,System.Int32,System.UInt64*)">
        Makes the BigPoly an aliased BigPoly with the specified coefficient count, bit width, and backing array. An aliased BigPoly
        does not internally allocate or deallocate the backing array, and instead uses the specified backing array for all
        read/write operations. Note that resizing is not supported by an aliased BigPoly and any required deallocation of the
        specified backing array must occur externally after the aliased BigPoly is no longer in use.

        @param[in] coeff_count The number of coefficients
        @param[in] coeff_bit_count The bit width of each coefficient
        @param[in] value The backing array to use
        @throws std::invalid_argument if coeff_count or coeff_bit_count is negative or value is null
        @see BigPoly for a more detailed description of aliased BigPolys.

</member>
        <member name="M:seal.BigPoly.resize(System.Int32,System.Int32)">
        Resizes a BigPoly to the specified coefficient count and bit width, copying over and resizing existing coefficient values
        as much as will fit. If coefficient count is reduced, the leading coefficients are dropped. If coefficient count increases,
        the new coefficients are initialized to zero.

        @param[in] coeff_count The number of coefficients
        @param[in] coeff_bit_count The bit width of each coefficient
        @throws std::invalid_argument if either coeff_count or coeff_bit_count is negative
        @throws std::logic_error if the BigPoly is an alias

</member>
        <member name="M:seal.BigPoly.set_zero(System.Int32,System.Int32)">
        Sets all coefficients within [start_coeff, start_coeff + length) to have a value of zero. This does not resize the BigPoly
        or modify the other coefficients.

        @param[in] start_coeff The index of the first coefficient to set to zero
        @param[in] length The number of coefficients to set to zero
        @throws std::out_of_range if start_coeff is not within [0, coeff_count()]
        @throws std::out_of_range if length is negative or start_coeff + length is not within [0, coeff_count()]

</member>
        <member name="M:seal.BigPoly.set_zero(System.Int32)">
        Sets all coefficients within [start_coeff, coefficient count) to have a value of zero. This does not resize the BigPoly or
        modify the other coefficients.

        @param[in] start_coeff The index of the first coefficient to set to zero
        @throws out_of_range if start_coeff is not within [0, coeff_count()]

</member>
        <member name="M:seal.BigPoly.set_zero">
Sets all coefficients to have a value of zero. This does not resize the BigPoly.

</member>
        <member name="M:seal.BigPoly.op_Subscript(System.Int32)">
        Returns a BigUInt that can read the coefficient at the specified index. The BigUInt is an aliased BigUInt that points
        directly to the backing array of the BigPoly.

        @warning The returned BigUInt is an alias backed by a region of the BigPoly's backing array. As such, it is only valid until
        the BigPoly is resized, destroyed, or alias() is called.

        @param[in] coeff_index The index of the coefficient to read
        @throws std::out_of_range if coeff_index is not within [0, coeff_count())
        @see BigUInt for operations that can be performed on the coefficients.


        Returns a BigUInt that can read or write the coefficient at the specified index. The BigUInt is an aliased BigUInt that points
        directly to the backing array of the BigPoly.

        @warning The returned BigUInt is an alias backed by a region of the BigPoly's backing array. As such, it is only valid until
        the BigPoly is resized, destroyed, or alias() is called.

        @param[in] coeff_index The index of the coefficient to read/write
        @throws std::out_of_range if coeff_index is not within [0, coeff_count())
        @see BigUInt for operations that can be performed on the coefficients.

</member>
        <member name="M:seal.BigPoly.is_zero">
Returns whether or not the BigPoly has all zero coefficients.

</member>
        <member name="M:seal.BigPoly.op_Inequality(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns whether or not the BigPoly has a different value than a specified BigPoly. Value equality is not determined by the
        raw coefficient count or bit count, but rather if the significant bits of non-zero coefficients have the same value.

        @param[in] compare The BigPoly to compare against

</member>
        <member name="M:seal.BigPoly.op_Equality(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns whether or not the BigPoly has the same value as a specified BigPoly. Value equality is not determined by the
        raw coefficient count or bit count, but rather if the significant bits of non-zero coefficients have the same value.

        @param[in] compare The BigPoly to compare against

</member>
        <member name="M:seal.BigPoly.significant_coeff_bit_count">
        Returns the number of significant bits of the largest coefficient in the BigPoly.

        @see coeff_bit_count() to instead return the coefficient bit count regardless of leading zero bits.

</member>
        <member name="M:seal.BigPoly.significant_coeff_count">
        Returns the coefficient count for the BigPoly ignoring all of the highest coefficients that have value zero.

        @see coeff_count() to instead return the coefficient count regardless of the number of leading zero terms.

</member>
        <member name="M:seal.BigPoly.coeff_uint64_count">
        Returns the number of std::uint64_t in the backing array used to store each coefficient.

        @see uint64_count() to determine the total number of std::uint64_t values used to store all of the coefficients.
        @see BigPoly for a more detailed description of the format of the backing array.

</member>
        <member name="M:seal.BigPoly.uint64_count">
        Returns the total number of std::uint64_t in the backing array to store all of the coefficients of the BigPoly.

        @see coeff_uint64_count() to determine the number of std::uint64_t values used for each individual coefficient.
        @see BigPoly for a more detailed description of the format of the backing array.

</member>
        <member name="M:seal.BigPoly.pointer">
        Returns a const pointer to the backing array storing all of the coefficient values. The pointer points to the beginning
        of the backing array where all coefficients are stored sequentially. The pointer points to the coefficient for the constant
        (degree 0) term of the BigPoly. Note that the return value will be nullptr if the coefficient count and/or bit count is zero.

        @warning The pointer is valid only until the backing array is freed, which occurs when the BigPoly is resized, destroyed,
        or the alias() function is called.
        @see coeff_uint64_count() to determine the number of std::uint64_t values used for each coefficient in the backing array.
        @see uint64_count() to determine the total number of std::uint64_t values in the backing array.
        @see BigPoly for a more detailed description of the format of the backing array.


        Returns a pointer to the backing array storing all of the coefficient values. The pointer points to the beginning of the
        backing array where all coefficients are stored sequentially. The pointer points to the coefficient for the constant
        (degree 0) term of the BigPoly. Note that the return value will be nullptr if the coefficient count and/or bit count is zero.

        @warning The pointer is valid only until the backing array is freed, which occurs when the BigPoly is resized, destroyed,
        or the alias() function is called.
        @see coeff_uint64_count() to determine the number of std::uint64_t values used for each coefficient in the backing array.
        @see BigPoly for a more detailed description of the format of the backing array.

</member>
        <member name="M:seal.BigPoly.coeff_bit_count">
Returns the number of bits per coefficient.

@see significant_coeff_bit_count() to instead get the number of significant bits of the largest coefficient in the BigPoly.

</member>
        <member name="M:seal.BigPoly.coeff_count">
Returns the coefficient count for the BigPoly.

@see significant_coeff_count() to instead ignore the leading coefficients that have a value of zero.

</member>
        <member name="M:seal.BigPoly.is_alias">
        Returns whether or not the BigPoly is an alias.

        @see BigPoly for a detailed description of aliased BigPolys.

</member>
        <member name="M:seal.BigPoly.Dispose">
Destroys the BigPoly and deallocates the backing array if it is not an aliased BigPoly.

</member>
        <member name="M:seal.BigPoly.#ctor(seal.BigPoly!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a deep copy of a BigPoly. The created BigPoly will have the same coefficient count, coefficient bit count,
        and coefficient values as the original.

        @param[in] copy The BigPoly to copy from

</member>
        <member name="M:seal.BigPoly.#ctor(System.Int32,System.Int32,System.UInt64*)">
        Creates an aliased BigPoly with the specified coefficient count, bit width, and backing array. An aliased BigPoly
        does not internally allocate or deallocate the backing array, and instead uses the specified backing array for all
        read/write operations. Note that resizing is not supported by an aliased BigPoly and any required deallocation of the
        specified backing array must occur externally after the aliased BigPoly is no longer in use.

        @param[in] coeff_count The number of coefficients
        @param[in] coeff_bit_count The bit width of each coefficient
        @param[in] value The backing array to use
        @throws std::invalid_argument if coeff_count or coeff_bit_count is negative or value is null
        @see BigPoly for a more detailed description of aliased BigPolys.

</member>
        <member name="M:seal.BigPoly.#ctor(System.Int32,System.Int32)">
        Creates a zero-initialized BigPoly of the specified coefficient count and bit width.

        @param[in] coeff_count The number of coefficients
        @param[in] coeff_bit_count The bit width of each coefficient
        @throws std::invalid_argument if either coeff_count or coeff_bit_count is negative

</member>
        <member name="M:seal.BigPoly.#ctor">
Creates an empty BigPoly with zero coefficients and zero coefficient bit width. No memory is allocated by this
constructor.

</member>
        <member name="T:seal.BigPoly">
    Represents a polynomial consisting of a set of unsigned integer coefficients with a specified bit width.
    Non-const BigPolys are mutable and able to be resized. Individual coefficients can be read/written through the
    operator[] function. A BigPoly has a set coefficient count (which can be read with coeff_count()) and coefficient
    bit width (which can be read with coeff_bit_count()), and all coefficients in a BigPoly have the same bit width.
    The coefficient count and bit width of a BigPoly is set initially by the constructor, and can be resized either
    explicitly with the resize() function, or implicitly with for example the operator=() function.

    @par Backing Array
    A BigPoly's coefficients are stored sequentially, index-zero coefficient first, in a contiguous std::uint64_t
    array. The width of each coefficient is rounded up to the next std::uint64_t width (i.e., to the next 64-bit
    boundary). The coeff_uint64_count() function returns the number of std::uint64_t values used per coefficient. The
    uint64_count() function returns the number of std::uint64_t values used to store all coefficients. Each
    coefficient is stored in an identical format to BigUInt, with the least quad word first and the order of bits
    for each quad word dependent on the architecture's std::uint64_t representation. For each coefficient, the bits higher
    than the coefficient bit count must be set to zero to prevent undefined behavior. The pointer() function returns 
    a pointer to the first std::uint64_t of the array.

    @par Implicit Resizing
    Both the copy constructor and operator=() allocate more memory for the backing array when needed, i.e. when
    the source polynomial has a larger backing array than the destination. Conversely, when the destination backing 
    array is already large enough, the data is only copied and the unnecessary higher degree coefficients are set
    to zero. When new memory has to be allocated, only the significant coefficients of the source polynomial
    are taken into account. This is is important, because it avoids unnecessary zero coefficients to be included 
    in the destination, which in some cases could accumulate and result in very large unnecessary allocations. 
    However, sometimes it is necessary to preserve the original coefficient count, even if some of the
    leading coefficients are zero. This comes up for example when copying individual polynomials of ciphertext 
    BigPolyArray objects, as these polynomials need to have the leading coefficient equal to zero to be considered
    valid by classes such as Evaluator and Decryptor. For this purpose BigPoly contains functions duplicate_from
    and duplicate_to, which create an exact copy of the source BigPoly.

    @par Alias BigPolys
    An aliased BigPoly (which can be determined with is_alias()) is a special type of BigPoly that does not manage
    its underlying std::uint64_t pointer that stores the coefficients. An aliased BigPoly supports most of the same
    operations as a non-aliased BigPoly, including reading/writing the coefficients and assignment, however an
    aliased BigPoly does not internally allocate or deallocate its backing array and, therefore, does not support resizing.
    Any attempt, either explicitly or implicitly, to resize the BigPoly will result in an exception being thrown.
    An aliased BigPoly can be created with the BigPoly(int, int, std::uint64_t*) constructor or the
    alias() function. Note that the pointer specified to be aliased must be deallocated externally after the BigPoly is
    no longer in use. Aliasing is useful in cases where it is desirable to not have each BigPoly manage its own memory
    allocation and/or to prevent unnecessary coefficient copying.

    @par Thread Safety
    In general, reading a BigPoly is thread-safe while mutating is not. Specifically, the backing array may be freed
    whenever a resize occurs, the BigPoly is destroyed, or alias() is called, which would invalidate the address returned by
    pointer() and the coefficients returned by operator[]. When it is known a resize will not occur, concurrent reading and
    mutating is safe as long as it is known that concurrent reading and mutating for the same coefficient will not occur,
    as the reader may see a partially updated coefficient value.

    @see BigPolyArith for arithmetic and modular functions on BigPolys.
    @see BigUInt for more details on the coefficients returned by operator[]().

</member>
        <member name="F:seal.BigUInt.is_alias_">
        Specifies whether or not the BigUInt is an alias. An alias BigUInt does not allocate its own backing array
        and instead uses the pointer of a backing array passed in to the constructor or alias() function.

        @see BigUInt for more information about the format of the backing array.

</member>
        <member name="F:seal.BigUInt.bit_count_">
The bit count for the BigUInt.

</member>
        <member name="F:seal.BigUInt.value_">
        Points to the backing array for the BigUInt. This pointer will be set to nullptr if and only if the bit count
        is zero. This pointer is automatically allocated and freed by the BigUInt if and only if the BigUInt is not an alias.
        If the BigUInt is an alias, then the pointer was passed-in to a constructor or alias() call, and will not be
        deallocated by the BigUInt.

        @see BigUInt for more information about aliased BigUInts or the format of the backing array.

</member>
        <member name="M:seal.BigUInt.reset">
Resets the entire state of the BigUInt to an empty, zero-sized state, freeing any memory it internally allocated.
If the BigUInt was an alias, the backing array is not freed but the alias is no longer referenced.

</member>
        <member name="M:seal.BigUInt.#ctor(seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a new BigUInt by moving an old one.

        @param[in] source The BigUInt to move from

</member>
        <member name="M:seal.BigUInt.op_Assign(seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Moves an old BigUInt to the current one.

        @param[in] assign The BigUInt to move from

</member>
        <member name="M:seal.BigUInt.duplicate_from(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Duplicates a given BigUInt. The bit count and the value of the current BigUInt
        are set to be exactly the same as in the given one.

        @param[in] value The BigUInt to duplicate
        @throws std::logic_error if the current BigPoly is an alias

</member>
        <member name="M:seal.BigUInt.duplicate_to(seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Duplicates the current BigUInt. The bit count and the value of the given BigUInt
        are set to be exactly the same as in the current one.

        @param[out] destination The BigUInt to overwrite with the duplicate
        @throws std::logic_error if the destination BigPoly is an alias

</member>
        <member name="M:seal.BigUInt.of(System.UInt64)">
Creates a minimally sized BigUInt initialized to the specified unsigned integer value.

@param[in] value The value to initialized the BigUInt to

</member>
        <member name="M:seal.BigUInt.load(std.basic_istream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Loads a BigUInt from an input stream overwriting the current BigUInt and enlarging if needed to fit the loaded
        BigUInt.

        @param[in] stream The stream to load the BigUInt from
        @throws std::logic_error if BigUInt is an alias and the loaded BigUInt is too large to fit with the current bit width
        @see save() to save a BigUInt.

</member>
        <member name="M:seal.BigUInt.save(std.basic_ostream&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte}&gt;*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Saves the BigUInt to an output stream. The full state of the BigUInt is serialized, including insignificant bits. The output
        is in binary format and not human-readable. The output stream must have the "binary" flag set.

        @param[in] stream The stream to save the BigUInt to
        @see load() to load a saved BigUInt.

</member>
        <member name="M:seal.BigUInt.trymodinv(System.UInt64,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Attempts to calculate the inverse of a BigUInt with respect to the specified modulus, returning whether or not the inverse
        was successful and setting the inverse parameter to the inverse. The original BigUInt is not modified. The inverse parameter
        is resized if and only if its bit count is smaller than the significant bit count of the modulus.

        @param[in] modulus The modulus to calculate the inverse with respect to
        @param[out] inverse Stores the inverse if the inverse operation was successful
        @throws std::Invalid_argument if modulus is zero
        @throws std::Invalid_argument if modulus is not greater than the BigUInt value
        @throws std::logic_error if the inverse is an alias which the function attempts to enlarge to fit the result

</member>
        <member name="M:seal.BigUInt.trymodinv(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Attempts to calculate the inverse of a BigUInt with respect to the specified modulus, returning whether or not the inverse
        was successful and setting the inverse parameter to the inverse. The original BigUInt is not modified. The inverse parameter
        is resized if and only if its bit count is smaller than the significant bit count of the modulus.

        @param[in] modulus The modulus to calculate the inverse with respect to
        @param[out] inverse Stores the inverse if the inverse operation was successful
        @throws std::Invalid_argument if modulus is zero
        @throws std::Invalid_argument if modulus is not greater than the BigUInt value
        @throws std::logic_error if the inverse is an alias which the function attempts to enlarge to fit the result

</member>
        <member name="M:seal.BigUInt.modinv(System.UInt64)">
        Returns the inverse of a BigUInt with respect to the specified modulus. The original BigUInt is not modified. The bit
        count of the inverse is set to be the significant bit count of the modulus.

        @param[in] modulus The modulus to calculate the inverse with respect to
        @throws std::Invalid_argument if modulus is zero
        @throws std::Invalid_argument if modulus is not greater than the BigUInt value
        @throws std::Invalid_argument if the BigUInt value and modulus are not co-prime

</member>
        <member name="M:seal.BigUInt.modinv(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns the inverse of a BigUInt with respect to the specified modulus. The original BigUInt is not modified. The bit
        count of the inverse is set to be the significant bit count of the modulus.

        @param[in] modulus The modulus to calculate the inverse with respect to
        @throws std::Invalid_argument if modulus is zero
        @throws std::Invalid_argument if modulus is not greater than the BigUInt value
        @throws std::Invalid_argument if the BigUInt value and modulus are not co-prime

</member>
        <member name="M:seal.BigUInt.divrem(System.UInt64,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides a BigUInt and an unsigned integer and returns the quotient and sets the remainder parameter to the remainder.
        The bit count of the quotient is set to be the significant bit count of the BigUInt. The remainder is resized if and only
        if it is smaller than the bit count of the BigUInt.

        @param[in] operand2 The second operand to divide
        @param[out] remainder The BigUInt to store the remainder
        @throws std::Invalid_argument if operand2 is zero
        @throws std::logic_error if the remainder is an alias which the function attempts to enlarge to fit the result

</member>
        <member name="M:seal.BigUInt.divrem(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigUInt*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides two BigUInts and returns the quotient and sets the remainder parameter to the remainder. The bit count of the
        quotient is set to be the significant bit count of the BigUInt. The remainder is resized if and only if it is smaller
        than the bit count of the BigUInt.

        @param[in] operand2 The second operand to divide
        @param[out] remainder The BigUInt to store the remainder
        @throws std::Invalid_argument if operand2 is zero
        @throws std::logic_error if the remainder is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_RightShiftAssignment(System.Int32)">
        Right-shifts a BigUInt by the specified amount. The BigUInt is never resized.

        @param[in] shift The number of bits to shift by
        @throws std::Invalid_argument if shift is negative

</member>
        <member name="M:seal.BigUInt.op_LeftShiftAssignment(System.Int32)">
        Left-shifts a BigUInt by the specified amount. The BigUInt is resized if and only if its bit count is smaller than the sum of its
        significant bit count and the shift amount.

        @param[in] shift The number of bits to shift by
        @throws std::Invalid_argument if shift is negative
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_BitwiseOrAssignment(System.UInt64)">
        Performs a bit-wise OR operation between a BigUInt and an unsigned integer saving the result to the first operand, returning a
        reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count
        is smaller than the significant bit count of the second operand.

        @param[in] operand2 The second operand to OR
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_BitwiseOrAssignment(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs a bit-wise OR operation between two BigUInts saving the result to the first operand, returning a reference of the first
        operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the
        significant bit count of the second operand.

        @param[in] operand2 The second operand to OR
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_BitwiseAndAssignment(System.UInt64)">
        Performs a bit-wise AND operation between a BigUInt and an unsigned integer saving the result to the first operand, returning a
        reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count
        is smaller than the significant bit count of the second operand.

        @param[in] operand2 The second operand to AND
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_BitwiseAndAssignment(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs a bit-wise AND operation between two BigUInts saving the result to the first operand, returning a reference of the first
        operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the
        significant bit count of the second operand.

        @param[in] operand2 The second operand to AND
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_ExclusiveOrAssignment(System.UInt64)">
        Performs a bit-wise XOR operation between a BigUInt and an unsigned integer saving the result to the first operand, returning a
        reference of the first operand. The second input operand is not modified. The first operand is resized if and only if its bit count
        is smaller than the significant bit count of the second operand.

        @param[in] operand2 The second operand to XOR
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_ExclusiveOrAssignment(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs a bit-wise XOR operation between two BigUInts saving the result to the first operand, returning a reference of the first
        operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than the
        significant bit count of the second operand.

        @param[in] operand2 The second operand to XOR
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_ModulusAssignment(System.UInt64)">
        Divides a BigUInt and an unsigned integer saving the remainder to the first operand, returning a reference of the first operand.
        The second input operand is not modified. The first operand is never resized.

        @param[in] operand2 The second operand to divide
        @throws std::Invalid_argument if operand2 is zero

</member>
        <member name="M:seal.BigUInt.op_ModulusAssignment(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides two BigUInts saving the remainder to the first operand, returning a reference of the first operand. The second
        input operand is not modified. The first operand is never resized.

        @param[in] operand2 The second operand to divide
        @throws std::invalid_argument if operand2 is zero

</member>
        <member name="M:seal.BigUInt.op_DivisionAssignment(System.UInt64)">
        Divides a BigUInt and an unsigned integer saving the quotient to the first operand, returning a reference of the first operand.
        The second input operand is not modified. The first operand is never resized.

        @param[in] operand2 The second operand to divide
        @throws std::invalid_argument if operand2 is zero

</member>
        <member name="M:seal.BigUInt.op_DivisionAssignment(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides two BigUInts saving the quotient to the first operand, returning a reference of the first operand. The second
        input operand is not modified. The first operand is never resized.

        @param[in] operand2 The second operand to divide
        @throws std::invalid_argument if operand2 is zero

</member>
        <member name="M:seal.BigUInt.op_MultiplicationAssignment(System.UInt64)">
        Multiplies a BigUInt and an unsigned integer saving the product to the first operand, returning a reference of the first
        operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than
        the sum of the significant bit counts of the two input operands.

        @param[in] operand2 The second operand to multiply
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_MultiplicationAssignment(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies two BigUInts saving the product to the first operand, returning a reference of the first operand. The second
        input operand is not modified. The first operand is resized if and only if its bit count is smaller than the sum of the
        significant bit counts of the two input operands.

        @param[in] operand2 The second operand to multiply
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_SubtractionAssignment(System.UInt64)">
        Subtracts a BigUInt and an unsigned integer saving the difference to the first operand, returning a reference of the first
        operand. The second input operand is not modified. The first operand is resized if and only if its bit count is smaller than
        the significant bit count of the second operand.

        @param[in] operand2 The second operand to subtract
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_SubtractionAssignment(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts two BigUInts saving the difference to the first operand, returning a reference of the first operand. The second
        input operand is not modified. The first operand is resized if and only if its bit count is smaller than the significant
        bit count of the second operand.

        @param[in] operand2 The second operand to subtract
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_AdditionAssignment(System.UInt64)">
        Adds a BigUInt and an unsigned integer saving the sum to the first operand, returning a reference of the first operand. The
        second input operand is not modified. The first operand is resized if and only if its bit count is smaller than one greater
        than the significant bit count of the larger of the two input operands.

        @param[in] operand2 The second operand to add
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_AdditionAssignment(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds two BigUInts saving the sum to the first operand, returning a reference of the first operand. The second input operand
        is not modified. The first operand is resized if and only if its bit count is smaller than one greater than the significant
        bit count of the larger of the two input operands.

        @param[in] operand2 The second operand to add
        @throws std::logic_error if the BigUInt is an alias and the operator attempts to enlarge the BigUInt to fit the result

</member>
        <member name="M:seal.BigUInt.op_RightShift(System.Int32)">
        Returns a right-shifted copy of the BigUInt. The bit count of the returned value is the original significant bit
        count subtracted by the shift amount (clipped to zero if negative).

        @param[in] shift The number of bits to shift by
        @throws std::invalid_argument if shift is negative

</member>
        <member name="M:seal.BigUInt.op_LeftShift(System.Int32)">
        Returns a left-shifted copy of the BigUInt. The bit count of the returned value is the sum of the original
        significant bit count and the shift amount.

        @param[in] shift The number of bits to shift by
        @throws std::invalid_argument if shift is negative

</member>
        <member name="M:seal.BigUInt.op_Inequality(System.UInt64)">
        Returns whether or not a BigUInt is not equal to an unsigned integer. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_Inequality(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns whether or not a BigUInt is not equal to a second BigUInt. The input operands are not modified.

        @param[in] compare The value to compare against

</member>
        <member name="M:seal.BigUInt.op_Equality(System.UInt64)">
        Returns whether or not a BigUInt is equal to an unsigned integer. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_Equality(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns whether or not a BigUInt is equal to a second BigUInt. The input operands are not modified.

        @param[in] compare The value to compare against

</member>
        <member name="M:seal.BigUInt.op_GreaterThanOrEqual(System.UInt64)">
        Returns whether or not a BigUInt is greater-than or equal to an unsigned integer. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_GreaterThanOrEqual(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns whether or not a BigUInt is greater-than or equal to a second BigUInt. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_LessThanOrEqual(System.UInt64)">
        Returns whether or not a BigUInt is less-than or equal to an unsigned integer. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_LessThanOrEqual(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns whether or not a BigUInt is less-than or equal to a second BigUInt. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_GreaterThan(System.UInt64)">
        Returns whether or not a BigUInt is greater-than an unsigned integer. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_GreaterThan(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns whether or not a BigUInt is greater-than a second BigUInt. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_LessThan(System.UInt64)">
        Returns whether or not a BigUInt is less-than an unsigned integer. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.op_LessThan(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Returns whether or not a BigUInt is less-than a second BigUInt. The input operands are not modified.

        @param[in] operand2 The value to compare against

</member>
        <member name="M:seal.BigUInt.compareto(System.UInt64)">
        Compares a BigUInt and an unsigned integer and returns -1, 0, or 1 if the BigUInt is less-than, equal-to, or greater-than the
        second operand respectively. The input operands are not modified.

        @param[in] compare The value to compare against

</member>
        <member name="M:seal.BigUInt.compareto(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Compares two BigUInts and returns -1, 0, or 1 if the BigUInt is less-than, equal-to, or greater-than the second operand
        respectively. The input operands are not modified.

        @param[in] compare The value to compare against

</member>
        <member name="M:seal.BigUInt.op_BitwiseOr(System.UInt64)">
        Performs a bit-wise OR operation between a BigUInt and an unsigned integer and returns the result. The input operands are not
        modified. The bit count of the result is set to the maximum of the two input operand bit counts.

        @param[in] operand2 The second operand to OR

</member>
        <member name="M:seal.BigUInt.op_BitwiseOr(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs a bit-wise OR operation between two BigUInts and returns the result. The input operands are not modified. The bit count
        of the result is set to the maximum of the two input operand bit counts.

        @param[in] operand2 The second operand to OR

</member>
        <member name="M:seal.BigUInt.op_BitwiseAnd(System.UInt64)">
        Performs a bit-wise AND operation between a BigUInt and an unsigned integer and returns the result. The input operands are not
        modified. The bit count of the result is set to the maximum of the two input operand bit counts.

        @param[in] operand2 The second operand to AND

</member>
        <member name="M:seal.BigUInt.op_BitwiseAnd(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs a bit-wise AND operation between two BigUInts and returns the result. The input operands are not modified. The bit count
        of the result is set to the maximum of the two input operand bit counts.

        @param[in] operand2 The second operand to AND

</member>
        <member name="M:seal.BigUInt.op_ExclusiveOr(System.UInt64)">
        Performs a bit-wise XOR operation between a BigUInt and an unsigned integer and returns the result. The input operands are not
        modified. The bit count of the result is set to the maximum of the two input operand bit counts.

        @param[in] operand2 The second operand to XOR

</member>
        <member name="M:seal.BigUInt.op_ExclusiveOr(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Performs a bit-wise XOR operation between two BigUInts and returns the result. The input operands are not modified. The bit count
        of the result is set to the maximum of the two input operand bit counts.

        @param[in] operand2 The second operand to XOR

</member>
        <member name="M:seal.BigUInt.op_Modulus(System.UInt64)">
        Divides a BigUInt and an unsigned integer and returns the remainder. The input operands are not modified. The bit count of the
        remainder is set to be the significant bit count of the first input operand.

        @param[in] operand2 The second operand to divide
        @throws std::invalid_argument if operand2 is zero

</member>
        <member name="M:seal.BigUInt.op_Modulus(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides two BigUInts and returns the remainder. The input operands are not modified. The bit count of the remainder is set
        to be the significant bit count of the first input operand.

        @param[in] operand2 The second operand to divide
        @throws std::invalid_argument iff operand2 is zero

</member>
        <member name="M:seal.BigUInt.op_Division(System.UInt64)">
        Divides a BigUInt and an unsigned integer and returns the quotient. The input operands are not modified. The bit count of the
        quotient is set to be the significant bit count of the first input operand.

        @param[in] operand2 The second operand to divide
        @throws std::invalid_argument if operand2 is zero

</member>
        <member name="M:seal.BigUInt.op_Division(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Divides two BigUInts and returns the quotient. The input operands are not modified. The bit count of the quotient is set
        to be the significant bit count of the first input operand.

        @param[in] operand2 The second operand to divide
        @throws std::invalid_argument if operand2 is zero

</member>
        <member name="M:seal.BigUInt.op_Multiply(System.UInt64)">
        Multiplies a BigUInt and an unsigned integer and returns the product. The input operands are not modified. The bit count of
        the product is set to be the sum of the significant bit counts of the two input operands.

        @param[in] operand2 The second operand to multiply

</member>
        <member name="M:seal.BigUInt.op_Multiply(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Multiplies two BigUInts and returns the product. The input operands are not modified. The bit count of the product is set
        to be the sum of the significant bit counts of the two input operands.

        @param[in] operand2 The second operand to multiply

</member>
        <member name="M:seal.BigUInt.op_Subtraction(System.UInt64)">
        Subtracts a BigUInt and an unsigned integer and returns the difference. The input operands are not modified. The bit count of
        the difference is set to be the significant bit count of the larger of the two operands.

        @param[in] operand2 The second operand to subtract

</member>
        <member name="M:seal.BigUInt.op_Subtraction(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Subtracts two BigUInts and returns the difference. The input operands are not modified. The bit count of the difference is set
        to be the significant bit count of the larger of the two input operands.

        @param[in] operand2 The second operand to subtract

</member>
        <member name="M:seal.BigUInt.op_Addition(System.UInt64)">
        Adds a BigUInt and an unsigned integer and returns the sum. The input operands are not modified. The bit count of the sum is set
        to be one greater than the significant bit count of the larger of the two operands.

        @param[in] operand2 The second operand to add

</member>
        <member name="M:seal.BigUInt.op_Addition(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Adds two BigUInts and returns the sum. The input operands are not modified. The bit count of the sum is set to be one greater
        than the significant bit count of the larger of the two input operands.

        @param[in] operand2 The second operand to add

</member>
        <member name="M:seal.BigUInt.op_Decrement(System.Int32)">
Decrements the BigUInt but returns its old value. The bit count does not change.

</member>
        <member name="M:seal.BigUInt.op_Increment(System.Int32)">
Increments the BigUInt but returns its old value. The BigUInt will increment the bit count if needed to fit the carry.

</member>
        <member name="M:seal.BigUInt.op_Decrement">
Decrements the BigUInt and returns the decremented value. The bit count does not change.

</member>
        <member name="M:seal.BigUInt.op_Increment">
        Increments the BigUInt and returns the incremented value. The BigUInt will increment the bit count if needed to fit the carry.

        @throws std::logic_error if BigUInt is an alias and a carry occurs requiring the BigUInt to be resized

</member>
        <member name="M:seal.BigUInt.op_OnesComplement">
Returns an inverted copy of the BigUInt value. The bit count does not change.

</member>
        <member name="M:seal.BigUInt.op_UnaryNegation">
Returns a negated copy of the BigUInt value. The bit count does not change.

</member>
        <member name="M:seal.BigUInt.op_UnaryPlus">
Returns a copy of the BigUInt value resized to the significant bit count.

</member>
        <member name="M:seal.BigUInt.op_Assign(System.UInt64)">
        Overwrites the BigUInt with the specified integer value, enlarging if needed to fit the value.

        @param[in] value The value to assign
        @throws std::logic_error if BigUInt is an alias and the significant bit count of value is too large to fit the
        current bit width

</member>
        <member name="M:seal.BigUInt.op_Assign(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Overwrites the BigUInt with the unsigned hexadecimal value specified by the string, enlarging if needed to fit the
        assigned value. The string must match the format returned by to_string() and must consist of only the characters
        0-9, A-F, or a-f, most-significant nibble first.

        @param[in] hex_value The hexadecimal integer string specifying the value to assign
        @throws std::invalid_argument if hex_value does not adhere to the expected format
        @throws std::logic_error if BigUInt is an alias and the assigned value is too large to fit the current bit width

</member>
        <member name="M:seal.BigUInt.op_Assign(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Overwrites the BigUInt with the value of the specified BigUInt, enlarging if needed to fit the assigned
        value. Only significant bits are used to size the BigUInt.

        @param[in] assign The BigUInt whose value should be assigned to the current BigUInt
        @throws std::logic_error if BigUInt is an alias and the assigned BigUInt is too large to fit the current bit width

</member>
        <member name="M:seal.BigUInt.unalias">
        Resets an aliased BigUInt into an empty non-alias BigUInt with bit count of zero.

        @throws std::logic_error if BigUInt is not an alias

</member>
        <member name="M:seal.BigUInt.alias(System.Int32,System.UInt64*)">
        Makes the BigUInt an aliased BigUInt with the specified bit width and backing array. An aliased BigUInt does not
        internally allocate or deallocate the backing array, and instead uses the specified backing array for all
        read/write operations. Note that resizing is not supported by an aliased BigUInt and any required deallocation
        of the specified backing array must occur externally after the aliased BigUInt is no longer in use.

        @param[in] bit_count The bit width
        @param[in] value The backing array to use
        @throws std::invalid_argument if bit_count is negative or value is null
        @see BigUInt for a more detailed description of aliased BigUInts.

</member>
        <member name="M:seal.BigUInt.resize(System.Int32)">
        Resizes the BigUInt to the specified bit width, copying over the old value as much as will fit.

        @param[in] bit_count The bit width
        @throws std::invalid_argument if bit_count is negative
        @throws std::logic_error if the BigUInt is an alias

</member>
        <member name="M:seal.BigUInt.set_zero">
Sets the BigUInt value to zero. This does not resize the BigUInt.

</member>
        <member name="M:seal.BigUInt.op_Subscript(System.Int32)">
        Returns the byte at the corresponding byte index of the BigUInt's integer value. The bytes of the BigUInt
        are indexed least-significant byte first.

        @param[in] index The index of the byte to read
        @throws std::out_of_range if index is not within [0, byte_count())
        @see BigUInt for a detailed description of the format of the backing array.


        Returns an byte reference that can read/write the byte at the corresponding byte index of the BigUInt's integer value.
        The bytes of the BigUInt are indexed least-significant byte first.

        @warning The returned byte is an reference backed by the BigUInt's backing array. As such, it is only valid until the BigUInt
        is resized, destroyed, or alias() is called.

        @param[in] index The index of the byte to read
        @throws std::out_of_range if index is not within [0, byte_count())
        @see BigUInt for a detailed description of the format of the backing array.

</member>
        <member name="M:seal.BigUInt.is_zero">
Returns whether or not the BigUInt has the value zero.

</member>
        <member name="M:seal.BigUInt.to_dec_string">
Returns the BigUInt value as a decimal string.

</member>
        <member name="M:seal.BigUInt.to_string">
Returns the BigUInt value as a hexadecimal string.

</member>
        <member name="M:seal.BigUInt.to_double">
Returns the BigUInt value as a double. Note that precision may be lost during the conversion.

</member>
        <member name="M:seal.BigUInt.significant_bit_count">
        Returns the number of significant bits for the BigUInt.

        @see bit_count() to instead return the bit count regardless of leading zero bits.

</member>
        <member name="M:seal.BigUInt.uint64_count">
        Returns the number of std::uint64_t in the backing array used to store the BigUInt value.

        @see BigUInt for a detailed description of the format of the backing array.

</member>
        <member name="M:seal.BigUInt.byte_count">
        Returns the number of bytes in the backing array used to store the BigUInt value.

        @see BigUInt for a detailed description of the format of the backing array.

</member>
        <member name="M:seal.BigUInt.pointer">
        Returns a const pointer to the backing array storing the BigUInt value. The pointer points to the beginning
        of the backing array at the least-significant quad word.

        @warning The pointer is valid only until the backing array is freed, which occurs when the BigUInt is resized, destroyed,
        or the alias() function is called.

        @see uint64_count() to determine the number of std::uint64_t values in the backing array.
        @see BigUInt for a detailed description of the format of the backing array.


        Returns a pointer to the backing array storing the BigUInt value. The pointer points to the beginning of the backing array
        at the least-significant quad word.

        @warning The pointer is valid only until the backing array is freed, which occurs when the BigUInt is resized, destroyed,
        or the alias() function is called.
        @see uint64_count() to determine the number of std::uint64_t values in the backing array.
        @see BigUInt for a detailed description of the format of the backing array.

</member>
        <member name="M:seal.BigUInt.bit_count">
        Returns the bit count for the BigUInt.

        @see significant_bit_count() to instead ignore leading zero bits.

</member>
        <member name="M:seal.BigUInt.is_alias">
        Returns whether or not the BigUInt is an alias.

        @see BigUInt for a detailed description of aliased BigUInt.

</member>
        <member name="M:seal.BigUInt.Dispose">
Destroys the BigUInt and deallocates the backing array if it is not an aliased BigUInt.

</member>
        <member name="M:seal.BigUInt.#ctor(seal.BigUInt!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a deep copy of a BigUInt. The created BigUInt will have the same bit count and value as the original.

        @param[in] copy The BigUInt to copy from

</member>
        <member name="M:seal.BigUInt.#ctor(System.Int32,System.UInt64)">
        Creates a BigUInt of the specified bit width and initializes it to the specified unsigned integer value.

        @param[in] bit_count The bit width
        @param[in] value The initial value to set the BigUInt
        @throws std::invalid_argument if bit_count is negative

</member>
        <member name="M:seal.BigUInt.#ctor(System.Int32,System.UInt64*)">
        Creates an aliased BigUInt with the specified bit width and backing array. An aliased BigUInt does not
        internally allocate or deallocate the backing array, and instead uses the specified backing array for all
        read/write operations. Note that resizing is not supported by an aliased BigUInt and any required deallocation
        of the specified backing array must occur externally after the aliased BigUInt is no longer in use.

        @param[in] bit_count The bit width
        @param[in] value The backing array to use
        @throws std::invalid_argument if bit_count is negative or value is null
        @see BigUInt for a more detailed description of aliased BigUInts.

</member>
        <member name="M:seal.BigUInt.#ctor(System.Int32,std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a BigUInt of the specified bit width and initializes it with the unsigned hexadecimal integer
        specified by the string. The string must match the format returned by to_string() and must consist of only the
        characters 0-9, A-F, or a-f, most-significant nibble first.

        @param[in] bit_count The bit width
        @param[in] hex_value The hexadecimal integer string specifying the initial value
        @throws std::invalid_argument if bit_count is negative
        @throws std::invalid_argument if hex_value does not adhere to the expected format

</member>
        <member name="M:seal.BigUInt.#ctor(std.basic_string&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator&lt;System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte&gt;&gt;!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)">
        Creates a BigUInt initialized and minimally sized to fit the unsigned hexadecimal integer specified by the
        string. The string matches the format returned by to_string() and must consist of only the characters
        0-9, A-F, or a-f, most-significant nibble first.

        @param[in] hex_value The hexadecimal integer string specifying the initial value
        @throws std::invalid_argument if hex_value does not adhere to the expected format

</member>
        <member name="M:seal.BigUInt.#ctor(System.Int32)">
        Creates a zero-initialized BigUInt of the specified bit width.

        @param[in] bit_count The bit width
        @throws std::invalid_argument if bit_count is negative

</member>
        <member name="M:seal.BigUInt.#ctor">
Creates an empty BigUInt with zero bit width. No memory is allocated by this constructor.

</member>
        <member name="T:seal.BigUInt">
    Represents an unsigned integer with a specified bit width. Non-const BigUInts are mutable and able to be resized.
    The bit count for a BigUInt (which can be read with bit_count()) is set initially by the constructor and can be
    resized either explicitly with the resize() function or implicitly with an assignment operation (e.g., operator=(),
    operator+=(), etc.). A rich set of unsigned integer operations are provided by the BigUInt class, including
    comparison, traditional arithmetic (addition, subtraction, multiplication, division), and modular arithmetic
    functions.

    @par Backing Array
    The backing array for a BigUInt stores its unsigned integer value as a contiguous std::uint64_t array. Each
    std::uint64_t in the array sequentially represents 64-bits of the integer value, with the least significant
    quad-word storing the lower 64-bits and the order of the bits for each quad word dependent on the architecture's
    std::uint64_t representation. The size of the array equals the bit count of the BigUInt (which can be read with
    bit_count()) rounded up to the next std::uint64_t boundary (i.e., rounded up to the next 64-bit boundary). The
    uint64_count() function returns the number of std::uint64_t in the backing array. The pointer() function returns
    a pointer to the first std::uint64_t in the array. Additionally, the operator[] function allows accessing the
    individual bytes of the integer value in a platform-independent way - for example, reading the third
    byte will always return bits 16-24 of the BigUInt value regardless of the platform being little-endian or
    big-endian.

    @par Implicit Resizing
    Both the copy constructor and operator=() allocate more memory for the backing array when needed, i.e. when
    the source BigUInt has a larger backing array than the destination. Conversely, when the destination backing
    array is already large enough, the data is only copied and the unnecessary higher order bits are set
    to zero. When new memory has to be allocated, only the significant bits of the source BigUInt are taken 
    into account. This is is important, because it avoids unnecessary zero bits to be included in the destination,
    which in some cases could accumulate and result in very large unnecessary allocations.
    However, sometimes it is necessary to preserve the original size, even if some of the leading bits are zero. 
    For this purpose BigUInt contains functions duplicate_from and duplicate_to, which create an exact copy of 
    the source BigUInt.

    @par Alias BigUInts
    An aliased BigUInt (which can be determined with is_alias()) is a special type of BigUInt that does not manage
    its underlying std::uint64_t pointer used to store the value. An aliased BigUInt supports most of the same
    operations as a non-aliased BigUInt, including reading and writing the value, however an aliased BigUInt does
    not internally allocate or deallocate its backing array and, therefore, does not support resizing. Any attempt,
    either explicitly or implicitly, to resize the BigUInt will result in an exception being thrown. An aliased
    BigUInt can be created with the BigUInt(int, std::uint64_t*) constructor or the alias() function. Note that the
    pointer specified to be aliased must be deallocated externally after the BigUInt is no longer in use. Aliasing
    is useful in cases where it is desirable to not have each BigUInt manage its own memory allocation and/or to
    prevent unnecessary copying. For example, BigPoly uses aliased BigUInt's to return BigUInt representations of
    its coefficients, where the aliasing allows read/writes to the BigUInt to refer directly to the coefficient's
    corresponding region in the backing array of the BigPoly.

    @par Thread Safety
    In general, reading a BigUInt is thread-safe while mutating is not. Specifically, the backing array may be freed
    whenever a resize occurs, the BigUInt is destroyed, or alias() is called, which would invalidate the address
    returned by pointer() and the byte references returned by operator[]. When it is known that a resize will not occur,
    concurrent reading and mutating will not inherently fail but it is possible for a read to see a partially updated
    value from a concurrent write.

</member>
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'T:seal.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'F:seal.EvaluationKeys.keys_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.BigPolyArray,std.allocator<seal.BigPolyArray>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.BigPolyArray,std.allocator<seal.BigPolyArray>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.Ciphertext,std.allocator<seal.Ciphertext>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.Ciphertext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.Ciphertext,std.allocator<seal.Ciphertext>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.SimulationEvaluator.Relinearize(Microsoft.Research.SEAL.Simulation,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.SimulationEvaluator.AddMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.Simulation})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.SimulationEvaluator.MultiplyMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.Simulation})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.BinaryEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.BalancedEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.BinaryFractionalEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.BinaryFractionalEncoder.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.BinaryFractionalEncoder.Finalize'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.BalancedFractionalEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.IntegerEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.FractionalEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'T:seal.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'F:seal.EvaluationKeys.keys_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.BigPolyArray,std.allocator<seal.BigPolyArray>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.BigPolyArray,std.allocator<seal.BigPolyArray>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.Ciphertext,std.allocator<seal.Ciphertext>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.Ciphertext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.Ciphertext,std.allocator<seal.Ciphertext>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Plaintext.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Plaintext.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Plaintext.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'T:seal.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'F:seal.EvaluationKeys.keys_'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.ChooserEvaluator.select_parameters(std.vector<seal.ChooserPoly,std.allocator<seal.ChooserPoly>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,System.Int32,System.Double,System.Double,std.map<System.Int32,seal.BigUInt,std.less<System.Int32>,std.allocator<std.pair<System.Int32!System.Runtime.CompilerServices.IsConst,seal.BigUInt>>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.EncryptionParameters*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.ChooserEvaluator.default_parameter_options'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'T:seal.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'F:seal.EvaluationKeys.keys_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.BigPolyArray,std.allocator<seal.BigPolyArray>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.BigPolyArray*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.BigPolyArray,std.allocator<seal.BigPolyArray>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.Ciphertext,std.allocator<seal.Ciphertext>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced,seal.Ciphertext*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.Evaluator.add_many(std.vector<seal.Ciphertext,std.allocator<seal.Ciphertext>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.SimulationEvaluator.Relinearize(Microsoft.Research.SEAL.Simulation,System.Int32)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.SimulationEvaluator.AddMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.Simulation})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.SimulationEvaluator.MultiplyMany(System.Collections.Generic.List`1{Microsoft.Research.SEAL.Simulation})'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.BinaryEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.BalancedEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.BinaryFractionalEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.BinaryFractionalEncoder.Dispose'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.BinaryFractionalEncoder.Finalize'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.BalancedFractionalEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.IntegerEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.FractionalEncoder'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'T:seal.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'F:seal.EvaluationKeys.keys_'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.EvaluationKeys'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.#ctor(System.Int32,System.Int32,std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.to_string'. -->
        <!-- Discarding badly formed XML document comment for member 'M:seal.BigPoly.op_Assign(std.basic_string<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte,std.char_traits{System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte},std.allocator<System.SByte!System.Runtime.CompilerServices.IsSignUnspecifiedByte>>!System.Runtime.CompilerServices.IsConst*!System.Runtime.CompilerServices.IsImplicitlyDereferenced)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.MemoryPoolHandle.Set(Microsoft.Research.SEAL.MemoryPoolHandle)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.SetCoeffModulus(System.String)'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.EncryptionParameters.Validate'. -->
        <!-- Discarding badly formed XML document comment for member 'T:Microsoft.Research.SEAL.PolyCRTBuilder'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.PolyCRTBuilder.Decompose(Microsoft.Research.SEAL.BigPoly,System.Collections.Generic.List`1{Microsoft.Research.SEAL.BigUInt})'. -->
        <!-- Discarding badly formed XML document comment for member 'M:Microsoft.Research.SEAL.PolyCRTBuilder.Decompose(Microsoft.Research.SEAL.BigPoly)'. -->
    </members>
</doc>